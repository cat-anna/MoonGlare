/*
  * Generated by cppsrc.sh
  * On 
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include PCH_HEADER
#include "mgdtSettings.h"
#include "RemoteConsole.h"
#include "MainForm.h"
#include <Notifications.h>

using namespace MoonGlare::Debug::InsiderApi;

//-----------------------------------------

struct RemoteConsole::Impl {
	RemoteConsoleState m_State = RemoteConsoleState::NotStarted;
	std::unique_ptr<QUdpSocket> m_Socket;
	std::map<InsiderApi::u32, std::weak_ptr<RemoteConsoleObserver>> m_PendingRequests;

	QHostAddress m_RemoteAddress;
	quint16 m_RemotePort;

	uint64_t m_MessagesSent, m_MessagesRecived, m_MessagesTimedout;
	uint64_t m_BytesSent, m_BytesRecived;

	void SendPacket(InsiderApi::InsiderMessageBuffer &buffer) {
		buffer.GetHeader()->PayloadSize = buffer.PayLoadSize();
		buffer.GetHeader()->Signature = InsiderApi::SignatureValue::Empty;
		m_Socket->writeDatagram(buffer.GetBuffer(), buffer.UsedSize(), m_RemoteAddress, m_RemotePort);
		++m_MessagesSent; 
		m_BytesSent += buffer.UsedSize();
	}
};

//-----------------------------------------

void RemoteConsole::ExecuteCode(const QString &code) {
	if (m_Impl->m_State != RemoteConsoleState::Ready)
		return;	
	
	InsiderApi::InsiderMessageBuffer buffer;
	buffer.Fill(0);

	auto *header = buffer.GetHeader();
	header->MessageType = InsiderApi::MessageTypes::ExecuteCode;
	header->RequestID = 0;
		
	std::string s =	code.toUtf8().constData();
	buffer.PushString(s);

	m_Impl->SendPacket(buffer);
}

void RemoteConsole::RequestTimedout(SharedRemoteConsoleObserver observer) {
	auto it = m_Impl->m_PendingRequests.find(observer->GetRequestID());
	if (it == m_Impl->m_PendingRequests.end())
		return;

	m_Impl->m_PendingRequests.erase(it);
	++m_Impl->m_MessagesTimedout;
}

void RemoteConsole::MakeRequest(SharedRemoteConsoleObserver observer) {
	InsiderApi::InsiderMessageBuffer buffer;
	buffer.Fill(0);

	observer->BuildMessage(buffer);

	auto hdr = buffer.GetHeader();
	hdr->RequestID = observer->GetRequestID();
	hdr->MessageType = observer->GetMessageType();

	m_Impl->m_PendingRequests[observer->GetRequestID()] = observer;
	m_Impl->SendPacket(buffer);
	observer->OnSend();
}

void RemoteConsole::ProcessSelfMessage(InsiderApi::InsiderMessageBuffer &buffer) {
//	auto hdr = buffer.GetHeader();
	//switch (hdr->MessageType) {
	//default:
		//break;
	//}
}

void RemoteConsole::ProcessMessage(InsiderApi::InsiderMessageBuffer &buffer) {
	auto hdr = buffer.GetHeader();
	if (hdr->RequestID == 0) 
		return ProcessSelfMessage(buffer);

	auto it = m_Impl->m_PendingRequests.find(hdr->RequestID);
	if (it == m_Impl->m_PendingRequests.end()) 
		return ProcessSelfMessage(buffer);

	auto obs = it->second;
	auto ptr = obs.lock();
	if (!ptr) {
		m_Impl->m_PendingRequests.erase(it);
		return ProcessSelfMessage(buffer);
	}
	ptr->OnRecive();

	switch (buffer.GetHeader()->MessageType) {
	case InsiderApi::MessageTypes::NotSupported:
		ptr->OnError(RemoteConsoleObserver::ErrorStatus::MessageNotSupported);
		return;
	default:
		auto ret = ptr->ProcessMessage(buffer);
		if (ret == RemoteConsoleObserver::HanderStatus::Remove) {
			m_Impl->m_PendingRequests.erase(it);
		}
	}
}

//-----------------------------------------

RemoteConsole::RemoteConsole() {
	m_Impl = std::make_unique<Impl>();
	Initialize();
}

RemoteConsole::~RemoteConsole() {
	Finalize();
	m_Impl.reset();
}

//-----------------------------------------

bool RemoteConsole::Initialize() {
	if (m_Impl->m_State != RemoteConsoleState::NotStarted)
		return false;
	SetState(RemoteConsoleState::Starting);
	m_Impl->m_Socket.reset();
	m_Impl->m_Socket = std::make_unique<QUdpSocket>();
	m_Impl->m_Socket->bind();
	m_Impl->m_RemoteAddress = QHostAddress::LocalHost;
	m_Impl->m_RemotePort = Debug::InsiderApi::Configuration::Insider_Port; //(quint16)mgdtSettings::get().Connection.RemoteConsolePort;
	connect(m_Impl->m_Socket.get(), SIGNAL(readyRead()), this, SLOT(DataReady()));
	SetState(RemoteConsoleState::Ready);

	m_Impl->m_MessagesRecived = m_Impl->m_MessagesSent = m_Impl->m_MessagesTimedout = 0;
	m_Impl->m_BytesRecived = m_Impl->m_BytesSent = 0;

	m_TickTimer = std::make_unique<QTimer>();
	connect(m_TickTimer.get(), SIGNAL(timeout()), this, SLOT(Tick()));
	m_TickTimer->setInterval(5 * 1000);
	m_TickTimer->setSingleShot(false);
	m_TickTimer->start();

	return true;
}

bool RemoteConsole::Finalize() {
	if (m_Impl->m_State != RemoteConsoleState::Ready)
		return false;

	m_TickTimer.reset();

	SetState(RemoteConsoleState::Stopping);
	m_Impl->m_Socket->close();
	SetState(RemoteConsoleState::NotStarted);
	m_Impl->m_Socket.reset();
	return true;
}

RemoteConsoleState RemoteConsole::GetState() {
	return m_Impl->m_State;
}

void RemoteConsole::SetState(RemoteConsoleState st) {
	m_Impl->m_State = st;
	emit StateChanged(st);
}

void RemoteConsole::DataReady() {
	while (m_Impl->m_Socket->hasPendingDatagrams()) {
		InsiderApi::InsiderMessageBuffer buffer;
		auto s = m_Impl->m_Socket->readDatagram((char*)buffer.GetBuffer(), InsiderApi::Configuration::MaxMessageSize);

		if (s <= 0)
			continue;

		++m_Impl->m_MessagesRecived;
		m_Impl->m_BytesRecived += s;

		ProcessMessage(buffer);
	}
}

void RemoteConsole::Tick() {
	char buffer[64];

	if (m_Impl->m_MessagesRecived > 0) {
		sprintf_s(buffer, "%llu (%.2f kib)", m_Impl->m_MessagesRecived, m_Impl->m_BytesRecived / 1024.0f);
		Notifications::SendSetStateValue("Connection/Recived", buffer);
	}

	if (m_Impl->m_MessagesSent > 0) {
		sprintf_s(buffer, "%llu (%.2f kib)", m_Impl->m_MessagesSent, m_Impl->m_BytesSent / 1024.0f);
		Notifications::SendSetStateValue("Connection/Send", buffer);
	}

	if (m_Impl->m_MessagesTimedout > 0) {
		sprintf_s(buffer, "%llu", m_Impl->m_MessagesTimedout);
		Notifications::SendSetStateValue("Connection/Timedout", buffer);
	}
}

//-----------------------------------------

static RemoteConsole* _instance = nullptr;

RemoteConsole* RemoteConsole::get() {
	if (!_instance) {
		_instance = new RemoteConsole();
	}
	return _instance;
}

void RemoteConsole::Delete() {
	delete _instance;
	_instance = nullptr;
};
