/*
  * Generated by cppsrc.sh
  * On 2015-06-28 18:14:05.54
  * by Immethis
*/
/*--END OF HEADER BLOCK--*/

#include <pch.h>
#include <nfMoonGlare.h>
#include <Engine/iSoundEngine.h>
#include <Core/Scripts/LuaApi.h>

namespace MoonGlare {
namespace Sound {

SPACERTTI_IMPLEMENT_CLASS_SINGLETON(iSoundEngine);
RegisterApiInstance(iSoundEngine, &iSoundEngine::Instance, "SoundEngine");
RegisterApiDerivedClass(iSoundEngine, &iSoundEngine::RegisterScriptApi);

iSoundEngine::iSoundEngine() {
	SetThisAsInstance();
}

iSoundEngine::~iSoundEngine() {

}

bool iSoundEngine::Initialize() {
	return true;
}

bool iSoundEngine::Finalize() {
	return true;
}

void iSoundEngine::EnumerateAudio(EnumerationFunc func) {
};

//----------------------------------------------------------------------------------

void iSoundEngine::RegisterScriptApi(ApiInitializer &api) {
	api
	.deriveClass<ThisClass, BaseClass>("ciSoundEngine")
		.addFunction("PlayMusic", Utils::Template::CastStringParameter<ThisClass, void, &ThisClass::PlayMusic>::get())
		.addFunction("PlayEffect", Utils::Template::CastStringParameter<ThisClass, void, &ThisClass::PlaySound>::get())
		.addFunction("StopMusic", &ThisClass::StopMusic)
		.addFunction("RunPlayList", &ThisClass::RunPlayList)
		.addFunction("SetPlayList", &ThisClass::SetPlayList)
		
		.addFunction("PlayEffectScript", &ThisClass::PlaySoundScript)
		.addFunction("PlayMusicScript", &ThisClass::PlayMusicScript)
#ifdef DEBUG_SCRIPTAPI
		.addFunction("GetEffect", Utils::Template::CastStringParameter<ThisClass, iSound*, &ThisClass::GetSound>::get())
		.addFunction("GetMusic", Utils::Template::CastStringParameter<ThisClass, iSound*, &ThisClass::GetMusic>::get())
#endif
	.endClass()
	;
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------

SPACERTTI_IMPLEMENT_ABSTRACT_CLASS(iSound);
RegisterApiDerivedClass(iSound, &iSound::RegisterScriptApi);

iSound::iSound():
		BaseClass(), 
		m_FileName() {
}

iSound::~iSound() {
}

//----------------------------------------------------------------------------------

void iSound::RegisterScriptApi(ApiInitializer &api)  {
	api
	.deriveClass<ThisClass, BaseClass>("iSound")
		.addFunction("Play", &ThisClass::Play)
		.addFunction("Stop", &ThisClass::Stop)
		.addFunction("Length", &ThisClass::Length)
		.addFunction("SetVolume", &ThisClass::SetVolume)
	.endClass()
	;
}

void iSound::Configure(const string& FileName, const string& Name, SoundType Type, DataPath path) { 
	SetName(Name);
	m_Type = Type;
	FileSystem::DataSubPaths.Translate(m_FileName, FileName, path);
}

//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------

SPACERTTI_IMPLEMENT_CLASS_NOCREATOR(PlayList);
RegisterApiDerivedClass(PlayList, &PlayList::RegisterScriptApi);

PlayList::PlayList():
		BaseClass() {
}

PlayList::~PlayList() {
}

//----------------------------------------------------------------------------------

bool PlayList::LoadMeta(const xml_node node) {
	if (!node) return false;

	const char *mode = node.attribute("Mode").as_string("Sequential");
	m_Mode = Mode::Sequential;
	if (!strcmp(mode, "Random")) m_Mode = Mode::Random;

	XML::ForEachChild(node, "Item", [this](xml_node node)->int{
		const char *str = node.text().as_string();
		if (!str) {
			//ignore case
			return 0;
		}
		m_List.push_back(str);
		return 0;
	});
	return true;
}

//----------------------------------------------------------------------------------

bool PlayList::Next(string &out) const {
	if (m_List.empty()) return false;
	switch (m_Mode) {
	case Mode::Sequential:
		if (m_Current >= m_List.size()) m_Current = 0;
		out = m_List[m_Current];
		++m_Current;
		return true;
	case Mode::Random:
	#pragma warning ( suppress: 4244 )
		srand(time(NULL));
		m_Current = (rand() >> 2) % m_List.size();
		out = m_List[m_Current];
		return true;
	}
	return false;
}

void PlayList::Reset() const {
	m_Current = 0;
}

//----------------------------------------------------------------------------------

void PlayList::Add(const string& name) {
	m_List.push_back(name);
}

void PlayList::ClearList() {
	m_List.clear();
}

//----------------------------------------------------------------------------------

void PlayList::RegisterScriptApi(ApiInitializer &api) {
	api
	.deriveClass<ThisClass, BaseClass>("cPlayList")
		//.addFunction("PlayMusic", Utils::Template::CastStringParameter<ThisClass, void, &ThisClass::PlayMusic>::get())
		//.addFunction("PlayEffect", Utils::Template::CastStringParameter<ThisClass, void, &ThisClass::PlaySound>::get())
	.endClass()
	;
}

} //namespace Sound 
} //namespace MoonGlare 
