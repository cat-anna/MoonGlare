/*
	Generated by cppsrc.sh
	On 
	by Paweu
*/
#include <pch.h>
#include "Pipeline.h"

#include <boost/filesystem.hpp>

namespace modc {
namespace pipeline {	

//---------------------------------------------------------------------------------------
#if 0
void ModelTest(WorkConfiguration &data, const string &file, std::shared_ptr<ValidationStage> stage) {

	auto fr = data.input.container->GetFileReader(file);
	if (!fr) { 
		cout << "File error: file does not exists! [ " << file << " ]\n";
		return;
	}
	Assimp::Importer importer;
	const aiScene* scene = importer.ReadFileFromMemory(
		fr->GetFileData(), fr->Size(),
		aiProcess_JoinIdenticalVertices | aiProcess_Triangulate | aiProcess_SortByPType,
		strrchr(file.c_str(), '.'));

	for (unsigned i = 0; i < scene->mNumMaterials; i++) {
		const aiMaterial* pMaterial = scene->mMaterials[i];
		if (pMaterial->GetTextureCount(aiTextureType_DIFFUSE) <= 0)
			continue;

		aiString Path;
		if (pMaterial->GetTexture(aiTextureType_DIFFUSE, 0, &Path, NULL, NULL, NULL, NULL, NULL) != AI_SUCCESS) {
			//error
			continue;
		}
		stage->RegisterFile(data, Path.data, file);
	}
}

//---------------------------------------------------------------------------------------

void MediaTest::DispatchMediaTest(WorkConfiguration &data, const string &file, std::shared_ptr<ValidationStage> stage) {
	enum class MediaType {
		None, Model, Script, Ignore,
	};
	struct mediakind {
		MediaType type;
		void(*func)(WorkConfiguration &data, const string &file, std::shared_ptr<ValidationStage> stage);
		const char *ExtTable[64];
	};

	static const mediakind MediaTable[] ={
		{ MediaType::Model, &ModelTest, { ".3ds", 0, } },
		{ MediaType::Ignore, 0, { ".obj", 0, } },

		{ MediaType::Ignore, 0, { ".xml", 0 } },

		{ MediaType::Ignore, 0, { ".png", ".jpg", ".tga", 0 } },

		{ MediaType::None, 0, { 0 } },
	};

	const mediakind *table = MediaTable;
	for (; table->type != MediaType::None; ++table) {
		for (auto ext = &table->ExtTable[0]; *ext; ++ext)
			if (*ext && !backstrcmpi(*ext, file.c_str())) {
				if (table->func)
					table->func(data, file, stage);
				return;
			}
	}
	cout << "Warning unknown file type: " << file << "\n";
}
#endif

MediaTest::MediaTest() {
	auto pass = &MediaTest::TestJustPass;
	auto fail = &MediaTest::TestJustFail;
	auto image = &MediaTest::TestImage;
	auto sound = &MediaTest::TestSound;
	auto forceremove = &MediaTest::TestForceRemove;

	m_MediaTesters[".cpp"] = forceremove;

	m_MediaTesters[".lua"] = &MediaTest::TestLua;
	m_MediaTesters[".luac"] = pass;

	m_MediaTesters[".xml"] = &MediaTest::TestXML;

	m_MediaTesters[".jpg"] = image;
	m_MediaTesters[".tga"] = image;
	m_MediaTesters[".png"] = image;

	m_MediaTesters[".it"] = sound;
	m_MediaTesters[".xm"] = sound;
	m_MediaTesters[".mod"] = sound;
	m_MediaTesters[".mp3"] = sound;
	m_MediaTesters[".wav"] = sound;
	m_MediaTesters[".ogg"] = sound;

	m_MediaTesters[".3ds"] = pass;
	m_MediaTesters[".obj"] = pass;

	m_MediaTesters[".img"] = pass;
	m_MediaTesters[".bfd"] = pass;

	m_MediaTesters[".glsl"] = pass;
	m_MediaTesters[".glfx"] = pass;

	m_MediaTesters[".max"] = fail;
}

void MediaTest::ValidateStage(WorkConfiguration &data) {
	if (Verbosity::PrintStep())
		cout << data.StageCounter() << "Performing media testing\n";
	auto fs = shared<MediaTest>();
	for (auto &it : data.FileList) {
		if (it.Ignore) continue; 
		if (it.Correct) continue; 
		const char *cfileext = strrchr(it.Name.c_str(), '.');
		if (!cfileext) {
			cout << data.StageCounter() << "Warning: file: '" << it.Name << "' does not have valid extension. Mediatest skipped\n";
			Error::Warning();
			continue;
		}

		string ext = cfileext;
		std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);

		auto testit = m_MediaTesters.find(ext);
		if (testit == m_MediaTesters.end()) {
			cout << data.StageCounter() << "Warning: Unknown file type: '" << it.Name << "'\n";
			Error::Warning();
			continue;
		}
		auto func = testit->second;
		data->pipeline->QueueAction([fs, &it, func, this](WorkConfiguration &data) {
			auto ptr = fs.get();
			++m_ValidatedFiles;
			(ptr->*func)(data, it);
			it.Tested = true;
		});
	}
	data->pipeline->QueueLastAction([fs](WorkConfiguration &data) { fs->ExitAction(data); });
}

void MediaTest::SkipStage(WorkConfiguration &data) {
	if (Verbosity::PrintStep())
		cout << data.StageCounter() << "Skipping media testing\n";
	for (auto &it : data.FileList)
		it.Correct = true;
}

void MediaTest::ExitAction(WorkConfiguration &data) {
	if (Verbosity::PrintInfo()) {
		cout << data.StageCounter() << m_ValidatedFiles << " files validated\n";
		cout << data.StageCounter() << m_InvalidFiles << " files invalid\n";
	}
}

//---------------------------------------------------------------------------------------

void MediaTest::TestLua(WorkConfiguration &data, FileInfo& fi) {
	if(Scripts::DoNotCheck()) {
		fi.Correct = true;
		return;
	}

	if(Verbosity::PrintStep()) {
		if(Scripts::DoNotCompile())
			cout << data.StageCounter() << "checking script '" << fi.Name << "' syntax \n";
		else
			cout << data.StageCounter() << "compiling script '" << fi.Name << "'\n";
	}

	string infile = fi.Name + ".luac.in";
	string outfile = fi.Name + ".luac.out";

	fi.PreloadData();
	{
		std::ofstream f(infile, std::ios::binary | std::ios::out);
		f << fi.PreloadedData.get();
		f.close();
	}

	char buf[256];
	sprintf(buf, "%s -o %s %s %s",
			data.Scripts.ExecFile.c_str(),
			outfile.c_str(),
			(Scripts::DoNotStripDebugInfo() ? "" : "-s"),
			infile.c_str());

	if(Verbosity::PrintInfo()) 
		cout << data.StageCounter() << "Invoking command: '" << buf << "'\n";
	system(buf);

	{
		std::ifstream f(outfile, std::ios::binary | std::ios::in);
		f.seekg(0, std::ios::end);
		if (f.tellg() <= 0 || f.bad() || f.fail()) {
			cout << data.StageCounter() << "Script '" << fi.Name << "' has syntax error\n";
			fi.ClearPreloaded();
			fi.Correct = false;
			++m_InvalidFiles;
		} else {
			fi.Correct = true;
			if (!Scripts::DoNotCompile()) {
				fi.PreloadedSize = f.tellg();
				f.seekg(0);
				fi.PreloadedData.reset(new char[fi.PreloadedSize + 1]);
				fi.PreloadedData.get()[fi.PreloadedSize] = 0;
				f.read(fi.PreloadedData.get(), fi.PreloadedSize);
				fi.Generated = true;
				fi.Name += "c";
			} else {
				fi.ClearPreloaded();
			}
		}
	}

	boost::filesystem::remove(infile);
	boost::filesystem::remove(outfile);

	if (!fi.Correct)
		Error::Error();
}

void MediaTest::TestForceRemove(WorkConfiguration &data, FileInfo& fi) {
	fi.Correct = true;
	fi.Ignore = true;
	fi.Needed = false;
}

void MediaTest::TestXML(WorkConfiguration &data, FileInfo& fi) {
	fi.Correct = true;
}

void MediaTest::TestImage(WorkConfiguration &data, FileInfo& fi) {
	fi.Correct = true;
}

void MediaTest::TestSound(WorkConfiguration &data, FileInfo& fi) {
	fi.Correct = true;
}

void MediaTest::TestJustPass(WorkConfiguration &data, FileInfo& fi) {
	fi.Correct = true;
}

void MediaTest::TestJustFail(WorkConfiguration &data, FileInfo& fi) {
	fi.Correct = false;
	++m_InvalidFiles;
}

}// namespace pipeline
}// namespace modc
