/*
  * Generated by cppsrc.sh
  * On 2016-10-12 18:39:40,06
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include <pch.h>
#include <nfMoonGlare.h>
#include "DataClasses/StringTable.h"
#include "TextProcessor.h"

namespace MoonGlare {

TextProcessor::TextProcessor(DataClasses::StringTable * Tables) :m_StringTables(Tables) {

}

TextProcessor::~TextProcessor() {}

void TextProcessor::Process(const std::string & input, std::string & out) {
	ASSERT(m_StringTables, "No string tables!");

	if (input.empty()) {
		out.clear();
		return;
	}
	char buffer[4096];

	char *outbuf = buffer;
	size_t capacity = sizeof(buffer);

	const char *inp = input.c_str();

	auto push = [&outbuf, &capacity](char c) {
		if (capacity <= 1)
			return;
		*outbuf = c;
		--capacity;
		++outbuf;
	};

	auto pushstring = [&outbuf, &capacity](const std::string &in) {
		for (const auto &it : in) {
			if (capacity <= 1)
				return;
			*outbuf = it;
			--capacity;
			++outbuf;
		}
	};

	while (capacity > 1) {
		char c = *inp;
		++inp;
		switch (c) {
		case '\0':
			push('\0');
			out = buffer;
			return;
		case '$':
			if (inp[0] == '{') {
				const char *end = strchr(inp + 1, '}');
				if (end) {
					++inp;// skip { char
					//std::string id(inp, end - inp);
					const char *dot = strchr(inp, '.');

					std::string table;
					std::string id;
					if (dot) {
						table = std::string(inp, dot - inp);
						id = std::string(dot +1 , end - dot - 1);
					} else {
						id = std::string(inp, end - inp);
					}
					auto out = m_StringTables->GetString(id, table);
					pushstring(out);
					inp = end + 1;
					continue;
				}
			}
		default:
			push(c);
			continue;
		}
	}
}

} //namespace MoonGlare 
