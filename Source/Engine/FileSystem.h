/*
  * Generated by cppsrc.sh
  * On 2015-02-24 13:06:08,58
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef FileSystem_H
#define FileSystem_H

namespace MoonGlare {
namespace FileSystem {

using XMLFile = std::unique_ptr<pugi::xml_document>;
using TextureFile = std::unique_ptr < Graphic::Texture > ;

struct FileInfo {
	std::string m_FileName;
	std::string m_RelativeFileName;
	StarVFS::FileID m_FID;
	bool m_IsFolder;
};
using FileInfoTable = std::vector<FileInfo>;

//-------------------------------------------------------------------------------------------------

inline std::string MakeContainerFilePathURI(StarVFS::ContainerID cid, const char *fname) {
	char buf[128];
	sprintf_s(buf, "cidfn:/%llu/%s", static_cast<uint64_t>(cid), fname);
	return buf;
}

inline std::string MakeContainerFidURI(StarVFS::ContainerID cid, StarVFS::FileID cfid) {
	char buf[128];
	sprintf_s(buf, "cfid:/%llu/%llu", static_cast<uint64_t>(cid), static_cast<uint64_t>(cfid));
	return buf;
}

inline std::string MakeFidURI(StarVFS::FileID cfid) {
	char buf[128];
	sprintf_s(buf, "fid:/%llu", static_cast<uint64_t>(cfid));
	return buf;
}

inline std::string MakePathHashURI(StarVFS::FilePathHash hash) {
	char buf[128];
	sprintf_s(buf, "hash:/%08x", hash);
	return buf;
}

//-------------------------------------------------------------------------------------------------

/** File system is not yes fully thread-safe! */
class MoonGlareFileSystem : public Space::RTTI::RTTIObject {
	SPACERTTI_DECLARE_CLASS_SINGLETON(MoonGlareFileSystem, Space::RTTI::RTTIObject)
public:
 	MoonGlareFileSystem();
 	virtual ~MoonGlareFileSystem();

	bool LoadContainer(const std::string &URI);

	/** Read raw file data */
	bool OpenFile(const string& FileName, DataPath origin, StarVFS::ByteTable &FileData);
	/** Open an xml document */
	bool OpenXML(XMLFile &doc, const string& FileName, DataPath origin = DataPath::URI);
	/** Open resource xml document in fmt: 'origin/NAME/NAME.xml' [depends on resource type] */
	bool OpenResourceXML(XMLFile &doc, const string& Name, DataPath origin = DataPath::URI);
	/** Open texture */
	bool OpenTexture(TextureFile &tex, const string& FileName, DataPath origin = DataPath::URI, bool ApplyDefaultSettings = true);
	/** Open texture */
	bool OpenTexture(Graphic::Texture &tex, const string& FileName, DataPath origin = DataPath::URI, bool ApplyDefaultSettings = true);
	
	bool OpenXML(XMLFile &doc, string ResName, const string& FileName, DataPath origin = DataPath::URI) {
		return OpenXML(doc, (ResName += '/') += FileName, origin);
	}
	bool OpenFile(string ResName, const string& FileName, DataPath origin, StarVFS::ByteTable &FileData) {
		return OpenFile((ResName += '/') += FileName, origin, FileData);
	}
	bool OpenTexture(TextureFile &tex, string ResName, const string& FileName, DataPath origin = DataPath::URI, bool ApplyDefaultSettings = true) {
		return OpenTexture(tex, (ResName += '/') += FileName, origin, ApplyDefaultSettings);
	}
	bool OpenTexture(Graphic::Texture &tex, string ResName, const string& FileName, DataPath origin = DataPath::URI, bool ApplyDefaultSettings = true) {
		return OpenTexture(tex, (ResName += '/') += FileName, origin, ApplyDefaultSettings);
	}
	bool Initialize();
	bool Finalize();

	bool EnumerateFolder(const string& Path, FileInfoTable &FileTable, bool Recursive);
	bool EnumerateFolder(DataPath origin, FileInfoTable &FileTable, bool Recursive);
	bool EnumerateFolder(const string& SubPath, DataPath origin, FileInfoTable &FileTable, bool Recursive);

	static void RegisterDebugScriptApi(ApiInitializer &api);
	void DumpStructure(std::ostream &out) const;
private:
	struct StarVFSCallback : public StarVFS::StarVFSCallback {
		virtual BeforeContainerMountResult BeforeContainerMount(StarVFS::Containers::iContainer *ptr, const StarVFS::String &MountPoint) override { return m_Owner->BeforeContainerMount(ptr, MountPoint); }
		virtual void AfterContainerMounted(StarVFS::Containers::iContainer *ptr) override { return m_Owner->AfterContainerMounted(ptr); }
		StarVFSCallback(MoonGlareFileSystem *Owner) : m_Owner(Owner) {}
		MoonGlareFileSystem *m_Owner;
	};

	StarVFSCallback::BeforeContainerMountResult BeforeContainerMount(StarVFS::Containers::iContainer *ptr, const StarVFS::String &MountPoint);
	void AfterContainerMounted(StarVFS::Containers::iContainer *ptr);

	StarVFSCallback m_StarVFSCallback;
	std::unique_ptr<StarVFS::StarVFS> m_StarVFS;
};

class DirectoryReader : public cRootClass {
	SPACERTTI_DECLARE_STATIC_CLASS(DirectoryReader, cRootClass);
public:
	DirectoryReader() : m_origin(DataPath::Root), m_OwnerName("") { }
	DirectoryReader(DataPath origin, const string& OwnerName) : m_origin(origin), m_OwnerName(OwnerName) { }

	bool OpenXML(XMLFile &xml, const string& FileName) {
		if (m_OwnerName.empty())
			return MoonGlareFileSystem::Instance()->OpenXML(xml, FileName, m_origin);
		else
			return MoonGlareFileSystem::Instance()->OpenXML(xml, (m_OwnerName + '/') += FileName, m_origin);
	}
	bool OpenFile(const string& FileName, StarVFS::ByteTable &FileData) {
		if (m_OwnerName.empty())
			return MoonGlareFileSystem::Instance()->OpenFile(FileName, m_origin, FileData);
		else
			return MoonGlareFileSystem::Instance()->OpenFile((m_OwnerName + '/') += FileName, m_origin, FileData);
	}
	bool OpenTexture(TextureFile &tex, const string& FileName, bool ApplyDefaultSettings = true) {
		if (m_OwnerName.empty())
			return MoonGlareFileSystem::Instance()->OpenTexture(tex, FileName, m_origin, ApplyDefaultSettings);
		else
			return MoonGlareFileSystem::Instance()->OpenTexture(tex, (m_OwnerName + '/') += FileName, m_origin, ApplyDefaultSettings);
	}
	bool OpenTexture(Graphic::Texture &tex, const string& FileName, bool ApplyDefaultSettings = true) {
		if (m_OwnerName.empty())
			return MoonGlareFileSystem::Instance()->OpenTexture(tex, FileName, m_origin, ApplyDefaultSettings);
		else
			return MoonGlareFileSystem::Instance()->OpenTexture(tex, (m_OwnerName + '/') += FileName, m_origin, ApplyDefaultSettings);
	}
	static void RegisterScriptApi(ApiInitializer &api);
protected:
	DataPath m_origin;
	string m_OwnerName;
};

struct DataPathsTable {
	const string& operator[](DataPath p) const { return m_table[(unsigned)p]; }
	DataPathsTable();
	void Translate(string& out, const string& in, DataPath origin) const;
	void Translate(string& out, DataPath origin) const;
private:
	string m_table[(unsigned)DataPath::MaxValue];
};
extern const DataPathsTable DataSubPaths;

} //namespace FileSystem 

inline FileSystem::MoonGlareFileSystem* GetFileSystem() { return FileSystem::MoonGlareFileSystem::Instance(); }

} //namespace MoonGlare 

using MoonGlare::FileSystem::XMLFile;
using MoonGlare::FileSystem::TextureFile;

#endif
