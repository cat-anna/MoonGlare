/*
  * Generated by cppsrc.sh
  * On 2015-02-24 13:06:08,58
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef FileSystem_H
#define FileSystem_H

#include "libs/InternalFileSystem/InternalFileSystem.h"

namespace MoonGlare {
namespace FileSystem {

using XMLFile = XML;
using TextureFile = std::unique_ptr < Graphic::Texture > ;

//-------------------------------------------------------------------------------------------------

/** Filesystem is not yes fully threadsafe! */
class MoonGlareFileSystem : public InternalFileSystem {
	GABI_DECLARE_CLASS_SINGLETON(MoonGlareFileSystem, InternalFileSystem)
public:
 	MoonGlareFileSystem();
 	virtual ~MoonGlareFileSystem();

	/** Open raw file reader */
	FileReader OpenFile(const string& FileName, DataPath origin);
	/** Open an xml document */
	bool OpenXML(XML &doc, const string& FileName, DataPath origin);
	/** Open resource xml document in fmt: 'origin/NAME/NAME.xml' [depends on resource type] */
	bool OpenResourceXML(XML &doc, const string& Name, DataPath origin);
	/** Open texture */
	bool OpenTexture(TextureFile &tex, const string& FileName, DataPath origin, bool ApplyDefaultSettings = true);
	/** Open texture */
	bool OpenTexture(Graphic::Texture &tex, const string& FileName, DataPath origin, bool ApplyDefaultSettings = true);
	
	bool OpenXML(XML &doc, string ResName, const string& FileName, DataPath origin) {
		return OpenXML(doc, (ResName += '/') += FileName, origin);
	}
	FileReader OpenFile(string ResName, const string& FileName, DataPath origin) {
		return OpenFile((ResName += '/') += FileName, origin);
	}
	bool OpenTexture(TextureFile &tex, string ResName, const string& FileName, DataPath origin, bool ApplyDefaultSettings = true) {
		return OpenTexture(tex, (ResName += '/') += FileName, origin, ApplyDefaultSettings);
	}
	bool OpenTexture(Graphic::Texture &tex, string ResName, const string& FileName, DataPath origin, bool ApplyDefaultSettings = true) {
		return OpenTexture(tex, (ResName += '/') += FileName, origin, ApplyDefaultSettings);
	}
	bool Initialize();
	bool Finalize();

	bool EnumerateFolder(DataPath origin, FileTable &files);
	bool EnumerateFolder(DataPath origin, const string& subpath, FileTable &files);
	using BaseClass::EnumerateFolder;

	static void RegisterDebugScriptApi(ApiInitializer &api);
protected:
	virtual void OnModuleLoad(iContainer *container, unsigned LoadFlags) override;
	ContainerPrecheckStatus OnBeforeContainerAppend(iContainer *container, unsigned LoadFlags) override;
};

class DirectoryReader : public cRootClass {
	GABI_DECLARE_STATIC_CLASS(DirectoryReader, cRootClass);
public:
	DirectoryReader() : m_origin(DataPath::Root), m_OwnerName("") { }
	DirectoryReader(DataPath origin, const string& OwnerName) : m_origin(origin), m_OwnerName(OwnerName) { }

	bool OpenXML(XML &xml, const string& FileName) {
		if (m_OwnerName.empty())
			return MoonGlareFileSystem::Instance()->OpenXML(xml, FileName, m_origin);
		else
			return MoonGlareFileSystem::Instance()->OpenXML(xml, (m_OwnerName + '/') += FileName, m_origin);
	}
	FileReader OpenFile(const string& FileName) {
		if (m_OwnerName.empty())
			return MoonGlareFileSystem::Instance()->OpenFile(FileName, m_origin);
		else
			return MoonGlareFileSystem::Instance()->OpenFile((m_OwnerName + '/') += FileName, m_origin);
	}
	bool OpenTexture(TextureFile &tex, const string& FileName, bool ApplyDefaultSettings = true) {
		if (m_OwnerName.empty())
			return MoonGlareFileSystem::Instance()->OpenTexture(tex, FileName, m_origin, ApplyDefaultSettings);
		else
			return MoonGlareFileSystem::Instance()->OpenTexture(tex, (m_OwnerName + '/') += FileName, m_origin, ApplyDefaultSettings);
	}
	bool OpenTexture(Graphic::Texture &tex, const string& FileName, bool ApplyDefaultSettings = true) {
		if (m_OwnerName.empty())
			return MoonGlareFileSystem::Instance()->OpenTexture(tex, FileName, m_origin, ApplyDefaultSettings);
		else
			return MoonGlareFileSystem::Instance()->OpenTexture(tex, (m_OwnerName + '/') += FileName, m_origin, ApplyDefaultSettings);
	}
	static void RegisterScriptApi(ApiInitializer &api);
protected:
	DataPath m_origin;
	string m_OwnerName;
};

struct DataPathsTable {
	const string& operator[](DataPath p) const { return m_table[(unsigned)p]; }
	DataPathsTable();
	void Translate(string& out, const string& in, DataPath origin) const;
	void Translate(string& out, DataPath origin) const;
private:
	string m_table[(unsigned)DataPath::MaxValue];
};
extern const DataPathsTable DataSubPaths;

} //namespace FileSystem 

inline FileSystem::MoonGlareFileSystem* GetFileSystem() { return FileSystem::MoonGlareFileSystem::Instance(); }

} //namespace MoonGlare 

using MoonGlare::FileSystem::XMLFile;
using MoonGlare::FileSystem::TextureFile;

#endif
