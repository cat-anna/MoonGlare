/*
  * Generated by cppsrc.sh
  * On 2016-05-03 21:31:13,10
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>

#include <nfMoonGlare.h>

#include "World.h"

#include "Core/Configuration.Runtime.h"
#include "Core/InputProcessor.h"
#include "Core/Scene/ScenesManager.h"

#include "Core/Engine.h"
#include "iConsole.h"

#include <Foundation/Component/EntityManager.h>
#include <Foundation/HandleTable.h>

#include <Renderer/Renderer.h>
#include <Renderer/iAsyncLoader.h>
#include <Renderer/iRendererFacade.h>

#include <Foundation/Resources/AsyncLoaderEventObserver.h>
#include <Foundation/Resources/iAsyncLoader.h>

namespace MoonGlare {

World::World()
    : m_ScriptEngine(nullptr) {
    runtimeConfiguration = std::make_unique<Core::RuntimeConfiguration>();
    SetInterface(runtimeConfiguration.get());

    ::OrbitLogger::LogCollector::SetChannelName(OrbitLogger::LogChannels::Event, "EVNT");

    SetSharedInterface(std::make_shared<Component::EventDispatcher>());
    eventDispatcher = GetInterface<Component::EventDispatcher>();
}

World::~World() {
}

//------------------------------------------------------------------------------------------

void World::SetRendererFacade(Renderer::RendererFacade *c) {
    SetInterface(c);
    m_RendererFacade = c;
    auto obs = std::make_shared<Resources::AsyncLoaderEventObserver>(*this);
    auto alR = c->GetAsyncLoader();
        
    auto alF = dynamic_cast<Resources::iAsyncLoader*>(alR);
    SetInterface(alF);
    alF->SetObserver(obs);
    SetSharedInterface(obs);
}

bool World::Initialize() {
    THROW_ASSERT(m_ScriptEngine, "m_ScriptEngine assert failed!");

    entityManager = std::make_unique<Component::EntityManager>(*this);
    SetInterface<Component::EntityManager>(entityManager.get());

    m_InputProcessor = std::make_unique<Core::InputProcessor>();
    if (!m_InputProcessor->Initialize(this)) {
        AddLogf(Error, "Failed to initialize InputProcessor");
        return false;
    }

    CreateObject<HandleTable>();
    CreateObject<Core::PrefabManager>();

    m_ScenesManager = std::make_unique<Core::Scene::ScenesManager>(*this);
    m_ScenesManager->Initialize(&runtimeConfiguration->scene);

    return true;
}

bool World::Finalize() {
    if (m_ScenesManager) 
        m_ScenesManager->Finalize();
    m_ScenesManager.reset();

    if (m_InputProcessor) {

#ifdef DEBUG_DUMP
        pugi::xml_document xdoc;
        m_InputProcessor->Save(xdoc.append_child("KeyConfDump"));
        xdoc.save_file("logs/KeyConfDump.xml");
#endif
        if (!m_InputProcessor->Finalize()) {
            AddLogf(Error, "Failed to finalize InputProcessor");
        }
        m_InputProcessor.reset();
    }

    entityManager.reset();

    ReleaseAllInterfaces();
    return true;
}

void World::PostSystemInit() {
    if (m_ScenesManager)
        m_ScenesManager->PostSystemInit();
    CallPostInit();
}

bool World::PreSystemStart() {
    if (m_ScenesManager)
        m_ScenesManager->PreSystemStart();
    return true;
}

bool World::PreSystemShutdown() {
    if (m_ScenesManager)
        m_ScenesManager->PreSystemShutdown();
    return true;
}

bool World::Step(const Core::MoveConfig & config) {
    m_InputProcessor->Step(config);
    eventDispatcher->Step();
    ((Core::Scene::ScenesManager*)m_ScenesManager.get())->Step(const_cast<Core::MoveConfig&>(config)); //TODO:!
    entityManager->GCStep();
    return true;
}

//------------------------------------------------------------------------------------------

Core::Engine* World::GetEngine() {
    return MoonGlare::Core::GetEngine();
}

} //namespace MoonGlare
