/*
  * Generated by cppsrc.sh
  * On 2016-08-21 12:19:52,68
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>

#include <Renderer/Light.h>
#include <Graphic/Light.h>

#include "LightComponent.h"

#include <Core/Component/ComponentManager.h>
#include <Core/Component/ComponentRegister.h>
#include <Core/Component/TransformComponent.h>

#include <Common.x2c.h>
#include <Math.x2c.h>
#include <ComponentCommon.x2c.h>
#include <LightComponent.x2c.h>

namespace MoonGlare {
namespace Renderer {
namespace Component {

RegisterApiNonClass(LightComponent, &LightComponent::RegisterScriptApi);
RegisterComponentID<LightComponent> LightComponentReg("Light");

LightComponent::LightComponent(ComponentManager * Owner) 
		: AbstractComponent(Owner) {
}

LightComponent::~LightComponent() {
}

//------------------------------------------------------------------------------------------

void LightComponent::RegisterScriptApi(ApiInitializer & root) {
}

//------------------------------------------------------------------------------------------

bool LightComponent::Initialize() {
	m_Array.fill(LightEntry());
	return true;
}

bool LightComponent::Finalize() {
	return true;
}

//------------------------------------------------------------------------------------------

void LightComponent::Step(const Core::MoveConfig & conf) {
	auto *tc = GetManager()->GetTransformComponent();

	size_t LastInvalidEntry = 0;
	size_t InvalidEntryCount = 0;

	for (size_t i = 0; i < m_Array.Allocated(); ++i) {//ignore root entry
		auto &item = m_Array[i];
	
		if (!item.m_Flags.m_Map.m_Valid) {
			//mark and continue
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}
	
		if (!GetHandleTable()->IsValid(this, item.m_SelfHandle)) {
			item.m_Flags.m_Map.m_Valid = false;
			LastInvalidEntry = i;
			++InvalidEntryCount;
			//mark and continue but set valid to false to avoid further checks
			continue;
		}

		if (!item.m_Flags.m_Map.m_Active) {
			continue;
		}
	
		auto *tcentry = tc->GetEntry(item.m_Owner);
		if (!tcentry) {
			item.m_Flags.m_Map.m_Valid = false;
			LastInvalidEntry = i;
			++InvalidEntryCount;
			//mark and continue but set valid to false to avoid further checks
			continue;
		}

		Graphic::Light::LightBase *light;
		switch (item.m_Type) {
		case Light::LightType::Spot:
			conf.m_LightConfig->SpotLights.emplace_back();
			light = &conf.m_LightConfig->SpotLights.back();

			light->m_Attenuation = item.m_LightBase.m_Attenuation;
			break;

		case Light::LightType::Point:
			conf.m_LightConfig->PointLights.emplace_back();
			light = &conf.m_LightConfig->PointLights.back();

			light->m_Attenuation = item.m_LightBase.m_Attenuation;
			break;

		case Light::LightType::Directional:
			conf.m_LightConfig->DirectionalLights.emplace_back();
			light = &conf.m_LightConfig->DirectionalLights.back();

			break;
		default:
			item.m_Flags.m_Map.m_Valid = false;
			LastInvalidEntry = i;
			++InvalidEntryCount;
			//entry is not valid and shall be removed
			continue;
		}
	//	light->CutOff
		light->m_Position = tcentry->m_LocalTransform.getOrigin();
		light->m_Quaternion = tcentry->m_LocalTransform.getRotation();
		light->m_Flags.m_UInt8value = item.m_LightBase.m_Flags.m_UInt8value;
		light->m_Color = item.m_LightBase.m_Color;
		light->m_AmbientIntensity = item.m_LightBase.m_AmbientIntensity;
		light->m_DiffuseIntensity = item.m_LightBase.m_DiffuseIntensity;
	}

	if (InvalidEntryCount > 0) {
		AddLogf(Performance, "MeshComponent:%p InvalidEntryCount:%lu LastInvalidEntry:%lu", this, InvalidEntryCount, LastInvalidEntry);
		ReleaseElement(LastInvalidEntry);
	}
}

bool LightComponent::PushEntryToLua(Handle h, lua_State * lua, int & luarets) {
	return false;
}

bool LightComponent::Load(xml_node node, Entity Owner, Handle & hout) {
	x2c::Component::LightComponent::LightEntry_t le;
	le.ResetToDefault();
	if (!le.Read(node)) {
		AddLogf(Error, "Failed to read LightComponent entry!");
		return false;
	}

	switch (le.m_Type) {
	case Light::LightType::Spot:
	case Light::LightType::Point:
	case Light::LightType::Directional:
		break;
	default:
		AddLogf(Error, "Invalid light type!");
		LogInvalidEnum(le.m_Type);
		return false;
	}

	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}

	auto &entry = m_Array[index];
	entry.m_Flags.ClearAll();

	Handle &ch = hout;
	if (!GetHandleTable()->Allocate(this, Owner, ch, index)) {
		AddLogf(Error, "Failed to allocate handle!");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}

	entry.m_Owner = Owner;
	entry.m_SelfHandle = ch;

	entry.m_LightBase.m_AmbientIntensity = le.m_AmbientIntensity;
	entry.m_LightBase.m_DiffuseIntensity = le.m_DiffuseIntensity;
	entry.m_LightBase.m_Color = le.m_Color;
	entry.m_LightBase.m_Attenuation = le.m_Attenuation;
	entry.m_Type = le.m_Type;

	entry.m_Flags.m_Map.m_Active = le.m_Active;
	entry.m_LightBase.m_Flags.m_CastShadows = le.m_CastShadows;

	m_EntityMapper.SetHandle(entry.m_Owner, ch);
	entry.m_Flags.m_Map.m_Valid = true;
	return true;
}

bool LightComponent::GetInstanceHandle(Entity Owner, Handle & hout) {
	return false;
}

bool LightComponent::Create(Entity Owner, Handle & hout) {
	return false;
}

void LightComponent::ReleaseElement(size_t Index) {
	auto lastidx = m_Array.Allocated() - 1;

	if (lastidx == Index) {
		auto &last = m_Array[lastidx];
		GetHandleTable()->Release(this, last.m_SelfHandle); // handle may be already released; no need to check for failure
		last.Reset();
	} else {
		auto &last = m_Array[lastidx];
		auto &item = m_Array[Index];

		std::swap(last, item);

		if (!GetHandleTable()->SetHandleIndex(this, item.m_SelfHandle, Index)) {
			AddLogf(Error, "Failed to move MeshComponent handle index!");
		}
		GetHandleTable()->Release(this, last.m_SelfHandle); // handle may be already released; no need to check for failure
		last.Reset();
	}
	m_Array.DeallocateLast();
}

} //namespace Component 
} //namespace Renderer 
} //namespace MoonGlare 
