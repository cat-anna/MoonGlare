/*
  * Generated by cppsrc.sh
  * On 2016-08-21 12:19:52,68
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef LightComponent_H
#define LightComponent_H


#include <Core/Component/AbstractComponent.h>

namespace MoonGlare {
namespace Renderer {
namespace Component {

using namespace Core::Component;

class LightComponent 
	: public AbstractComponent
	, public ComponentIDWrap<ComponentIDs::Light> {
public:
	LightComponent(ComponentManager *Owner);
	virtual ~LightComponent();
	virtual bool Initialize() override;
	virtual bool Finalize() override;
	virtual void Step(const Core::MoveConfig &conf) override;
	virtual bool PushEntryToLua(Handle h, lua_State *lua, int &luarets) override;
	virtual bool Load(xml_node node, Entity Owner, Handle &hout) override;
	virtual bool GetInstanceHandle(Entity Owner, Handle &hout) override;
	virtual bool Create(Entity Owner, Handle &hout) override;

	union FlagsMap {
		struct MapBits_t {
			bool m_Valid : 1; //Entity is not valid or requested to be deleted;
			bool m_Active : 1;
			bool m_CastShadows : 1;
		};
		MapBits_t m_Map;
		uint32_t m_UintValue;

		void SetAll() { m_UintValue = 0; m_UintValue = ~m_UintValue; }
		void ClearAll() { m_UintValue = 0; }

		static_assert(sizeof(MapBits_t) <= sizeof(decltype(m_UintValue)), "Invalid Function map elements size!");
	};

	struct LightEntry {
		FlagsMap m_Flags;
		Entity m_Owner;
		Handle m_SelfHandle;

		Light::LightBase m_LightBase;
		Light::LightType m_Type;

		void Reset() {
		}
	};
	//	static_assert((sizeof(MeshEntry) % 16) == 0, "Invalid MeshEntry size!");
	//	static_assert(std::is_pod<MeshEntry>::value, "ScriptEntry must be pod!");

	LightEntry* GetEntry(Handle h);	 //return nullptr if h/e is not valid
	LightEntry* GetEntry(Entity e);	 //return nullptr if h/e is not valid

	static void RegisterScriptApi(ApiInitializer &root);
private:
	template<class T> using Array = Space::Container::StaticVector<T, Configuration::Storage::ComponentBuffer>;

	Array<LightEntry> m_Array;
	Core::EntityMapper m_EntityMapper;

	void ReleaseElement(size_t Index);
};
} //namespace Component 
} //namespace Renderer 
} //namespace MoonGlare 

#endif
