/*
  * Generated by cppsrc.sh
  * On 2016-08-10 17:23:57,17
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>

#include "MeshComponent.h"

#include <Core/Component/SubsystemManager.h>
#include <Core/Component/ComponentRegister.h>
#include <Core/Component/TransformComponent.h>

#include <Engine/Renderer/Dereferred/DereferredPipeline.h>

#include <Renderer/Resources/ResourceManager.h>
#include <Renderer/Resources/MeshResource.h>
#include <Renderer/Renderer.h>

namespace MoonGlare {
namespace Renderer {
namespace Component {

::Space::RTTI::TypeInfoInitializer<MeshComponent, MeshComponentEntry> MeshComponentTypeInfo;
RegisterComponentID<MeshComponent> MeshComponentReg("Mesh", true, &MeshComponent::RegisterScriptApi);

MeshComponent::MeshComponent(SubsystemManager * Owner) 
    : TemplateStandardComponent(Owner)
    , m_TransformComponent(nullptr)
{
}

MeshComponent::~MeshComponent() {
}

//------------------------------------------------------------------------------------------

void MeshComponent::RegisterScriptApi(ApiInitializer & root) {
    root
    .beginClass<MeshEntry>("cMeshEntry")
        .addProperty("Visible", &MeshEntry::IsVisible, &MeshEntry::SetVisible)
        .addProperty("MeshHandle", &MeshEntry::GetMeshHandle, &MeshEntry::SetMeshHandle)
      //  .addFunction("SetModel", &MeshEntry::SetModel)
    .endClass()
    ;
}

//------------------------------------------------------------------------------------------

bool MeshComponent::Initialize() {
    auto &ed = GetManager()->GetEventDispatcher();
    ed.Register<MoonGlare::Component::EntityDestructedEvent>(this);

//	m_Array.MemZeroAndClear();
    m_Array.fill(MeshEntry());
    entityMapper.Fill(ComponentIndex::Zero);

    m_TransformComponent = GetManager()->GetComponent<TransformComponent>();
    if (!m_TransformComponent) {
        AddLog(Error, "Failed to get RectTransformComponent instance!");
        return false;
    }
    
    return true;
}

bool MeshComponent::Finalize() {
    return true;
}

//------------------------------------------------------------------------------------------

void MeshComponent::HandleEvent(const MoonGlare::Component::EntityDestructedEvent &event) {
    auto index = entityMapper.GetIndex(event.entity);
    if (index >= m_Array.Allocated())
        return;

    m_Array[index].m_Flags.m_Map.m_Valid = false;
    entityMapper.SetIndex(event.entity, ComponentIndex::Invalid);
}

//------------------------------------------------------------------------------------------

void MeshComponent::Step(const Core::MoveConfig &conf) {

    size_t LastInvalidEntry = 0;
    size_t InvalidEntryCount = 0;

    for (size_t i = 0; i < m_Array.Allocated(); ++i) {//ignore root entry
        auto &item = m_Array[i];

        if (!item.m_Flags.m_Map.m_Valid) {
            //mark and continue
            LastInvalidEntry = i;
            ++InvalidEntryCount;
            continue;
        }

        if (!item.m_Flags.m_Map.m_Visible) {
            continue;
        }

        auto tindex = m_TransformComponent->GetComponentIndex(item.m_Owner);
        if (tindex == ComponentIndex::Invalid) {
            //item.m_Flags.m_Map.m_Valid = false;
            //LastInvalidEntry = i;
            //++InvalidEntryCount;
            //mark and continue but set valid to false to avoid further checks
            continue;
        }

        auto &tr = m_TransformComponent->GetTransform(tindex);
        if (item.meshHandle.deviceHandle) {//dirty valid check
            conf.deferredSink->Mesh(
                tr.matrix(),
                tr.translation(),
                item.meshHandle);
            continue;
        }
    }

    if (InvalidEntryCount > 0) {
        AddLogf(Performance, "MeshComponent:%p InvalidEntryCount:%lu LastInvalidEntry:%lu", this, InvalidEntryCount, LastInvalidEntry);
        ReleaseElement(LastInvalidEntry);
    }
}

//------------------------------------------------------------------------------------------

bool MeshComponent::Load(xml_node node, Entity Owner, Handle &hout) {	
    std::string meshUri = node.child("Mesh").text().as_string("");
    std::string materialUri = node.child("Material").text().as_string("");
    if (meshUri.empty()) {
        AddLogf(Error, "Attempt to load nameless Mesh!");
        return false;
    }
    size_t index;
    if (!m_Array.Allocate(index)) {
        AddLogf(Error, "Failed to allocate index!");
        return false;
    }

    auto &entry = m_Array[index];
    entry.m_Flags.ClearAll();

    if (meshUri.find("file://") == 0) {
        auto &mm = GetManager()->GetWorld()->GetRendererFacade()->GetResourceManager()->GetMeshManager();
        if (!mm.LoadMesh(meshUri, materialUri, entry.meshHandle)) {
            AddLogf(Error, "Mesh load failed!");
            return false;
        }
    }
    else {
        AddLog(Error, fmt::format("Invalid mesh uri: '{}'", meshUri));
        return false;
    }

    entry.m_Owner = Owner;

    entry.m_Flags.m_Map.m_Valid = true;
    entry.m_Flags.m_Map.m_Visible = node.child("Visible").text().as_bool(true);

    //m_EntityMapper.SetHandle(entry.m_Owner, ch);
    entityMapper.SetIndex(Owner, index);

    return true;
}

void MeshComponent::ReleaseElement(size_t Index) {
    auto lastidx = m_Array.Allocated() - 1;

    if (lastidx == Index) {
        auto &last = m_Array[lastidx];
        last.Reset();
    } else {
        auto &last = m_Array[lastidx];
        auto &item = m_Array[Index];

        std::swap(last, item);

        last.Reset();
    }
    m_Array.DeallocateLast();
}

bool MeshComponent::Create(Entity Owner, Handle &hout) {
    size_t index;
    if (!m_Array.Allocate(index)) {
        AddLogf(Error, "Failed to allocate index!");
        return false;
    }

    auto &entry = m_Array[index];
    entry.m_Flags.ClearAll();

    entry.m_Owner = Owner;

    entry.m_Flags.m_Map.m_Valid = true;
    entry.m_Flags.m_Map.m_Visible = true;

    return true;
}

} //namespace Component 
} //namespace Renderer
} //namespace MoonGlare 
