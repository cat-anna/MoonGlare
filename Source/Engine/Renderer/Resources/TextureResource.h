/*
  * Generated by cppsrc.sh
  * On 2015-10-25 21:28:37,58
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef TextureResource_H
#define TextureResource_H

namespace MoonGlare {
namespace Renderer {
namespace Resources {

using TextureHandle = BaseRendererResourceHandle<RendererStaticSettings::Limits::Bits::Texture>;

//struct TextureHandle : public BaseRendererResourceHandle<RendererStaticSettings::Limits::Bits::Texture> {
	//bool IsValid() const;
	//uint32_t RawHandle() const { 
		//if (!IsValid())
			//return 0;
		//return m_Value;
	//}
	//get entity ?? 
//};

class TextureResource : public ResourceBase {
public:
	TextureResource(Renderer *Renderer);
	~TextureResource();

	TextureHandle Allocate();//how lifetime of texture should me managed? consider using last used frame index or mark in bitmap 
	void Release(TextureHandle Texture);

	/** Must be called from renderer thread */
	void Step();

	/** Must be called from renderer thread */
	bool Initialize();
	/** Must be called from renderer thread */
	bool Finalize();

	//when call to glGenTextures should be made?
protected:
	union Flags {
		struct {
			char Used : 1;		///used by renderer
			char Allocated : 1; ///allocated in device
		};
		char m_IntValue;
	};

	RendererStaticSettings::GenerationType &GetGeneration(size_t index) { return m_Arrays.Get<0>(index); }
	Device::TextureHandle &GetRawTexture(size_t index) { return m_Arrays.Get<1>(index); }
	Flags &GetFlags (size_t index) { return m_Arrays.Get<2>(index); }
private: 
	using DataArrays = Utils::Memory::DynamicMultiArray<RendererStaticSettings::GenerationType, Device::TextureHandle, Flags>;
	using Allocator = Utils::Memory::StaticIndexQueue<uint16_t, RendererStaticSettings::Limits::Texture>;

	std::mutex m_Mutex;
	DataArrays m_Arrays;
	Allocator m_Allocator;
#ifdef DEBUG_MEMORY
	struct MemoryTracker;
	std::unique_ptr<MemoryTracker> m_MemoryTracker;
#endif
};

} //namespace Resources 
} //namespace Renderer 
} //namespace MoonGlare 

#endif
