/*
  * Generated by cppsrc.sh
  * On 2015-10-25 21:28:37,58
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include "../nRenderer.h"

namespace MoonGlare {
namespace Renderer {
namespace Resources {

#ifdef DEBUG_MEMORY
struct TextureResource::MemoryTracker {
	struct AlocatorTracker : public Config::Debug::MemoryInterface {
		TextureResource *m_Owner;
		AlocatorTracker(TextureResource *Owner): m_Owner(Owner){ }
		virtual Info* GetInfo() const {
			static Info i = { 
				0, 0, 
				sizeof(TextureResource::Allocator::Item) + sizeof(TextureResource::DataArrays::ElementSize),
				TextureResource::Allocator::Size, "TextureResource",
			};
			i.Capacity = m_Owner->m_Arrays.GetSize();
			i.Update(TextureResource::Allocator::Size - m_Owner->m_Allocator.count());
			return &i;
		}
	};
	
	AlocatorTracker m_AlocatorTracker;

	MemoryTracker(TextureResource *Owner):
			m_AlocatorTracker(Owner) { }
};
#endif

//---------------------------------------------------------------------------------------

TextureResource::TextureResource(Renderer *Owner) : ResourceBase(Owner), m_Arrays() {
#ifdef DEBUG_MEMORY
	m_MemoryTracker = std::make_unique<MemoryTracker>(this);
#endif
}

TextureResource::~TextureResource(){
}

//---------------------------------------------------------------------------------------

bool TextureResource::Initialize() {
	m_Arrays.SetSize(RendererStaticSettings::Limits::Texture);

	Allocator::Item ZeroKey;
	m_Allocator.get(ZeroKey); // 0 index is not valid;

	return true;
}

bool TextureResource::Finalize() {
	//TBD:!!!!
	return true;
}

//---------------------------------------------------------------------------------------

TextureHandle TextureResource::Allocate() {
	LOCK_MUTEX(m_Mutex);

	Allocator::Item Key;
	m_Allocator.get(Key);

	TextureHandle h;

	h.m_Generation = GetGeneration(Key);
	h.m_Value = Key;

	auto &flags = GetFlags(Key);
	flags.Used = 1;

	if (!flags.Allocated){
		auto cmd = GetRenderer()->NextFrame().GetPreCommands().PushCommand<Device::Commands::NewTextureCommand>();
		cmd->m_Count = 1;
		cmd->m_Memory = &GetRawTexture(Key);
		flags.Allocated = 1;
	}

	return h;
}

void TextureResource::Release(TextureHandle Texture) {
	LOCK_MUTEX(m_Mutex);

	++GetGeneration(Texture.m_Generation);

	auto &flags = GetFlags(Texture.m_Value);
	flags.Used = 0;

	m_Allocator.push(Texture.m_Value);

	auto &raw = GetRawTexture(Texture.m_Value);
	auto cmd = GetRenderer()->NextFrame().GetPreCommands().PushCommand<Device::Commands::DeleteSingleTextureCommand>();
	cmd->m_Texture = raw;
	raw = 0;

}

//---------------------------------------------------------------------------------------

void TextureResource::Step() {

}

//---------------------------------------------------------------------------------------

} //namespace Resources 
} //namespace Renderer 
} //namespace MoonGlare 
