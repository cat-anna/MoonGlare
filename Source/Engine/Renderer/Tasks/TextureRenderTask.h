/*
  * Generated by cppsrc.sh
  * On 2015-10-25 22:41:57,12
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef TextureRenderTask_H
#define TextureRenderTask_H

namespace MoonGlare {
namespace Renderer {
namespace Tasks {

struct TextureRendererData;

using TextureRenderTaskHandle = Utils::Handle::BaseTripleHandle32<uint32_t,
		RendererStaticSettings::Limits::Bits::LittleGenerations, 
		RendererStaticSettings::Limits::Bits::TextureTargetTasks>;

class TextureRenderTaskPointer final {
public:
	TextureRenderTaskPointer(TextureRendererData* Data, TextureRenderTaskHandle Handle);
	~TextureRenderTaskPointer();

	TextureRenderTaskHandle Handle() const { return m_Handle; }

	bool IsValid() const;

	/** Texture remains unchanged */
	void SetOutputTexture(Resources::TextureHandle Texture);
	/** Texture is renew with given arguments */
	void ResetTexture(math::uvec2 NewSize, Device::TextureType Type);

	//camera
	//shader

	//viewport?

	//get rendercallbuffer
	//submit - submit does autorelease after render
	bool Submit();
	//release
	//clear
private:
	TextureRendererData *m_Data;
	TextureRenderTaskHandle m_Handle;
	//Utils::FlagSet m_Flags;
};

/**

Virtuality is forbidden in this class.
*/
class TextureRenderer final {
public:
	TextureRenderer();
	~TextureRenderer();

	bool Initialize();
	bool Finalize();

	TextureRenderTaskPointer* NewTask();
	TextureRenderTaskPointer* FromHandle(TextureRenderTaskHandle Handle);
private:
	std::unique_ptr<TextureRendererData> m_TaskData;
};

} //namespace Tasks 
} //namespace Renderer 
} //namespace MoonGlare 

#endif
