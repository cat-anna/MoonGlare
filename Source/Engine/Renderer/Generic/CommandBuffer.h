/*
  * Generated by cppsrc.sh
  * On 2015-11-12 16:26:17,53
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef GenericCommandBuffer_H
#define GenericCommandBuffer_H

namespace MoonGlare {
namespace Renderer {
namespace Generic {

template<size_t BYTESPERCOMMAND, class COMMANDFUNCTION, class COMMANDINTERFACE, class LOCKPOLICY>
class CommandBuffer : public LOCKPOLICY {
public:
	CommandBuffer(size_t CommandsLimit): m_PendingCommands(0), m_CommandsLimit(0), m_UsedMemory(0) {
		Resize(CommandsLimit);
	}
	~CommandBuffer() {
	}

	enum {
		BytesPerCommand = BYTESPERCOMMAND,
	};

	void Swap(CommandBuffer &other);

	using CommandFunctor = COMMANDFUNCTION;
	using LockPolicy_t = LOCKPOLICY;
	using ArgumentsPointer = void*;
	using CommandInterface = COMMANDINTERFACE;

	template<class T>
	T* PushCommand() {
		lock();
		size_t index = m_PendingCommands;
		++m_PendingCommands;
		unlock();

		m_Functors[index] = CommandInterface::Functor<T>();
		m_Arguments[index] = m_ArgumentMemory + m_UsedMemory;
		m_UsedMemory += sizeof(T);
		return (T*)m_Arguments[index];
	}

	void Clear() {
		m_PendingCommands = m_UsedMemory = 0;
	}

	/** Performs clear after execution */
	void Execute() {
		for (size_t i = 0; i < m_PendingCommands; ++i)
			m_Functors[i](m_Arguments[i]);
		Clear();
	}


#ifdef DEBUG_MEMORY
	struct CommandBufferMemoryTracker {
		struct Tracker : public Config::Debug::MemoryInterface {
			CommandBuffer *m_Owner;
			std::string m_Name;
			Tracker(CommandBuffer *Owner, const char *Name): m_Owner(Owner), m_Name("CommandTracker") {
				if (Name) {
					m_Name += " - ";
					m_Name += Name;
				}
			}
			using Info = ::Config::Debug::MemoryInterface::Info;
			virtual Info* GetInfo() const {
				static Info i = {
					0, 0,
					sizeof(CommandFunctor) + sizeof(ArgumentsPointer) + BytesPerCommand,
					0, m_Name.c_str(),
				};
				i.Capacity = m_Owner->m_CommandsLimit;
				i.Update(m_Owner->m_PendingCommands);
				return &i;
			}
		};

		void Init(CommandBuffer *Owner, const char *Name = nullptr) {
			m_Tracker = std::make_unique<Tracker>(Owner, Name);
		}
	private:
		std::unique_ptr<Tracker> m_Tracker;
	};
	CommandBufferMemoryTracker m_MemoryTracker;
#endif
private:
	CommandFunctor *m_Functors;
	ArgumentsPointer *m_Arguments;
	char *m_ArgumentMemory;

	size_t m_PendingCommands;
	size_t m_CommandsLimit;
	size_t m_UsedMemory;

	std::unique_ptr<char[]> m_RawMemory;

	void Resize(size_t CommandsLimit) {
		if (!m_RawMemory) {
			size_t memsize = CommandsLimit * (sizeof(CommandFunctor) + sizeof(ArgumentsPointer) + BytesPerCommand);
			m_RawMemory.reset(new char[memsize]);
			m_CommandsLimit = CommandsLimit;
		}

		m_Functors = (CommandFunctor*)m_RawMemory.get();
		m_Arguments = (ArgumentsPointer*)(((char*)m_Functors) + sizeof(CommandFunctor) * m_CommandsLimit);
		m_ArgumentMemory = ((char*)m_Arguments) + sizeof(ArgumentsPointer) * m_CommandsLimit;
	}

};

} //namespace Generic 
} //namespace Renderer 
} //namespace MoonGlare 

#endif
