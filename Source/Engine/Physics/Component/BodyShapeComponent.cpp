/*
  * Generated by cppsrc.sh
  * On 2016-08-30 21:19:19,54
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <nfMoonGlare.h>
#include <Physics/nfPhysics.h>

#include <Core/Component/ComponentManager.h>
#include <Core/Component/ComponentRegister.h>
#include <Core/Component/AbstractComponent.h>
#include <Core/Component/TransformComponent.h>
#include "BodyShapeComponent.h"
#include "BodyComponent.h"

#include <Math.x2c.h>
#include <ComponentCommon.x2c.h>
#include <BodyShapeComponent.x2c.h>

namespace MoonGlare {
namespace Physics {
namespace Component {

::Space::RTTI::TypeInfoInitializer<BodyShapeComponent, BodyShapeComponentEntry> BodyShapeComponentTypeInfo;
Core::Component::RegisterComponentID<BodyShapeComponent> BodyShapeComponentIDReg("BodyShape", false);

BodyShapeComponent::BodyShapeComponent(Core::Component::ComponentManager *Owner)
		: AbstractComponent(Owner) {
}

BodyShapeComponent::~BodyShapeComponent() {
}

//---------------------------------------------------------------------------------------

bool BodyShapeComponent::Initialize() {
//	m_Array.fill(BodyShapeComponentEntry());

	m_BodyComponent = GetManager()->GetComponent<BodyComponent>();
	if (!m_BodyComponent) {
		AddLogf(Error, "Unable to get BodyComponent instance!");
		return false;
	}

	m_TransformComponent = GetManager()->GetComponent<Core::Component::TransformComponent>();
	if (!m_TransformComponent) {
		AddLogf(Error, "Unable to get TransformComponent instance!");
		return false;
	}

	return true;
}

bool BodyShapeComponent::Finalize() {
	return true;
}

//---------------------------------------------------------------------------------------

void BodyShapeComponent::Step(const Core::MoveConfig & conf) {
	return;
}

bool BodyShapeComponent::Load(xml_node node, Entity Owner, Handle & hout) {
	auto ShapeNode = node.child("Shape");
	auto ShapeName = ShapeNode.attribute("Name").as_string(nullptr);
	if (!ShapeName) {
		AddLogf(Error, "Attempt to add BodyShape of unnamed type!");
		return false;
	}

	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}

	auto &entry = m_Array[index];
	entry.m_Flags.ClearAll();
	entry.m_Shape.reset();
	if (!GetHandleTable()->Allocate(this, Owner, hout, index)) {
		AddLog(Error, "Failed to allocate handle");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}

	entry.m_OwnerEntity = Owner;
	entry.m_SelfHandle = hout;

	if (!m_BodyComponent->GetInstanceHandle(Owner, entry.m_BodyHandle)) {
		AddLogf(Warning, "Entity does not have body! Cannot attach shape!");
		return false;
	}

	auto bodyentry = m_BodyComponent->GetEntry(entry.m_BodyHandle);
	if (!bodyentry) {
		AddLogf(Error, "Cannot get BodyComponent entry!");
		return false;
	}
	
	switch (Space::Utils::MakeHash32(ShapeName)){
	case "Box"_Hash32: {
		x2c::Component::BodyShapeComponent::BoxBodyShape_t bbs;
		bbs.ResetToDefault();
		if (!bbs.Read(ShapeNode))
			break;
		entry.m_Shape = std::make_unique<btBoxShape>(convert(bbs.m_Size) / 2.0f);
		break;
	}
	case "Sphere"_Hash32: {
		x2c::Component::BodyShapeComponent::SphereBodyShape_t sbs;
		sbs.ResetToDefault();
		if (!sbs.Read(ShapeNode))
			break;
		entry.m_Shape = std::make_unique<btSphereShape>(sbs.m_Radius);
		break;
	}
	case "Capsule"_Hash32:
	case "CapsuleY"_Hash32:
	{
		x2c::Component::BodyShapeComponent::CapsuleYBodyShape_t cbs;
		cbs.ResetToDefault();
		if (!cbs.Read(ShapeNode))
			break;
		entry.m_Shape = std::make_unique<btCapsuleShape>(cbs.m_Radius, cbs.m_Height);
		break;
	}
	case "Cylinder"_Hash32:
	case "CylinderY"_Hash32:
	{
		x2c::Component::BodyShapeComponent::CylinderYBodyShape_t cbs;
		cbs.ResetToDefault();
		if (!cbs.Read(ShapeNode))
			break;
		entry.m_Shape = std::make_unique<btCylinderShape>(convert(cbs.m_Size) / 2.0f);
		break;
	}
	
	default:
		AddLogf(Error, "Attempt to add BodyShape of unknown type!");
		return false;
	}

	if (!entry.m_Shape) {
		AddLogf(Error, "Failed to create BodyShape!");
		return false;
	}

	if (!m_BodyComponent->SetShape(entry.m_SelfHandle, entry.m_BodyHandle, entry.m_Shape.get())) {
		AddLogf(Error, "Failed to set body shape!");
		return false;
	}

	auto tcEntry = m_TransformComponent->GetEntry(Owner);
	if (!tcEntry) {
		AddLog(Warning, "Cannot get TransformComponent");
	} else {
		entry.m_Shape->setLocalScaling(tcEntry->m_GlobalScale);
	}

	m_EntityMapper.SetHandle(Owner, entry.m_SelfHandle);
	entry.m_Flags.m_Map.m_Valid = true;
	return true;
}

bool BodyShapeComponent::GetInstanceHandle(Entity Owner, Handle & hout) {
	auto h = m_EntityMapper.GetHandle(Owner);
	if (!GetHandleTable()->IsValid(this, h)) {
		return false;
	}
	hout = h;
	return true;
}

//---------------------------------------------------------------------------------------

} //namespace Component 
} //namespace Physics 
} //namespace MoonGlare 
