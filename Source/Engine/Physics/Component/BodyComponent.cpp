/*
  * Generated by cppsrc.sh
  * On 2016-08-15 12:19:18,12
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>

#include "DebugDrawer.h"
#include "Collision.h"

#include <Core/Component/ComponentManager.h>
#include <Core/Component/ComponentRegister.h>
#include <Core/Component/AbstractComponent.h>
#include <Core/Component/TransformComponent.h>
#include "BodyComponent.h"

#include <Math.x2c.h>
#include <ComponentCommon.x2c.h>
#include <BodyComponent.x2c.h>

namespace MoonGlare {
namespace Physics {

::Space::RTTI::TypeInfoInitializer<BodyComponent, BodyComponent::BodyEntry, BodyComponent::BulletMotionStateProxy, BodyComponent::BulletProxyCommon, BodyComponent::BulletRigidBody> BodyComponentTypeInfo;
Core::Component::RegisterComponentID<BodyComponent> BodyComponentIDReg("Body", false);

BodyComponent::BodyComponent(Core::Component::ComponentManager * Owner) 
		: AbstractComponent(Owner) {

	DebugMemorySetParent(GetManager());
	DebugMemorySetClassName("BodyComponent");
	DebugMemoryRegisterCounter("IndexUsage", [this](DebugMemoryCounter& counter) {
		counter.Allocated = m_Array.Allocated();
		counter.Capacity = m_Array.Capacity();
		counter.ElementSize = sizeof(BodyEntry);
	});
}

BodyComponent::~BodyComponent() {}

//---------------------------------------------------------------------------------------

bool BodyComponent::Initialize() {
//	m_Array.MemZeroAndClear();

	m_TransformComponent = GetManager()->GetComponent<Core::Component::TransformComponent>();
	if (!m_TransformComponent) {
		AddLogf(Error, "Unable to get TransformComponent instance!");
		return false;
	}

	m_CollisionConfiguration = std::make_unique<btDefaultCollisionConfiguration>();
	m_Dispatcher = std::make_unique<btCollisionDispatcher>(m_CollisionConfiguration.get());
	m_Broadphase = std::make_unique<btDbvtBroadphase>();
	m_Solver = std::make_unique<btSequentialImpulseConstraintSolver>();
	m_DynamicsWorld = std::make_unique<btDiscreteDynamicsWorld>(m_Dispatcher.get(), m_Broadphase.get(), m_Solver.get(), m_CollisionConfiguration.get());
	m_DynamicsWorld->setGravity(vec3(0, 0, 0));

	return true;
}

bool BodyComponent::Finalize() {

	m_DynamicsWorld.reset();
	m_Solver.reset();
	m_Broadphase.reset();
	m_Dispatcher.reset();
	m_CollisionConfiguration.reset();

	return true;
}

//---------------------------------------------------------------------------------------

void BodyComponent::Step(const Core::MoveConfig & conf) {
	if (m_Array.Empty())
		return;

//	if (Config::Current::EnableFlags::PhysicsDebugDraw) {
		conf.CustomDraw.push_back(this);
//	}
	
	//|| !Config::Current::EnableFlags::Physics)
//		return;


	auto *tc = GetManager()->GetTransformComponent();

	for (size_t i = 0; i < m_Array.Allocated(); ++i) {//ignore root entry
		auto &item = m_Array[i];

		if (!item.m_Flags.m_Map.m_Valid) {
			//mark and continue
			//LastInvalidEntry = i;
			//++InvalidEntryCount;
			continue;
		}

		auto *tcentry = tc->GetEntry(item.m_TransformHandle);
		auto &body = m_BulletRigidBody[i];

		if (item.m_Revision == 0) {
			body.setMotionState(&m_MotionStateProxy[i]);
			item.m_Revision = tc->GetCurrentRevision();
			auto *shape = ((btRigidBody&)body).getCollisionShape();
			if (shape)
				shape->setLocalScaling(tcentry->m_GlobalScale);
			body.activate(true);
		} else {
			if (!item.m_Flags.m_Map.m_Kinematic || tcentry->m_Revision == 0) {
				if (item.m_Revision != tcentry->m_Revision) {
					((btRigidBody&)body).setWorldTransform(tcentry->m_LocalTransform);
					auto *shape = ((btRigidBody&)body).getCollisionShape();
					if (shape)
						shape->setLocalScaling(tcentry->m_GlobalScale);
					body.activate(true);
					item.m_Revision = tcentry->m_Revision;
				}
			}
		}
	}

	m_DynamicsWorld->stepSimulation(conf.TimeDelta, 5, 1.0f / (60.0f * 5.0f));
}

bool BodyComponent::Load(xml_node node, Entity Owner, Handle &hout) {
//	auto *ht = GetManager()->GetWorld()->GetHandleTable();
//	Handle &h = hout;
//	HandleIndex index = m_Allocated++;

	auto *tc = GetManager()->GetTransformComponent();

	Handle TCHandle;
	if (!tc->GetInstanceHandle(Owner, TCHandle)) {
		AddLogf(Error, "Failed get transform handle!");
		return false;
	}

	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}
	
	auto &entry = m_Array[index];
	entry.m_Flags.ClearAll();
	if (!GetHandleTable()->Allocate(this, Owner, hout, index)) {
		AddLog(Error, "Failed to allocate handle");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}

	entry.m_OwnerEntity = Owner;
	entry.m_SelfHandle = hout;

	entry.m_Revision = 0;
	entry.m_TransformHandle = TCHandle;

	auto &body = m_BulletRigidBody[index];
	auto &motionstste = m_MotionStateProxy[index];

	body.Reset(this, hout);
	body.SetTrnsform(tc, TCHandle);
	motionstste.Reset(this, hout);
	motionstste.SetTrnsform(tc, TCHandle);

//	auto cs = new btBoxShape(vec3(0.5f, 0.5f, 0.5f) * 2.0f);
	//body.setCollisionShape(cs);
	//vec3 internia;

	x2c::Component::BodyComponent::BodyEntry_t bodyentry;
	bodyentry.ResetToDefault();
	if (!bodyentry.Read(node)) {	
		AddLog(Error, "Failed to read BodyEntry!");
		return false;
	}

	entry.m_Mass = bodyentry.m_Mass;
	 
	//cs->calculateLocalInertia(bodyentry.m_Mass, internia);
//	body.setMassProps(bodyentry.m_Mass, internia);
	body.setAngularFactor(convert(bodyentry.m_AngularFactor));
	body.setLinearFactor(convert(bodyentry.m_LinearFactor));
	body.setLinearVelocity(convert(bodyentry.m_LinearVelocity));
	body.setAngularVelocity(convert(bodyentry.m_AngularVelocity));

	//body.setDamping(phprop.Damping.Linear, phprop.Damping.Angular);
	//body.setRestitution(phprop.Restitution);
	//body.setFriction(phprop.Friction);
	body.setSleepingThresholds(0.01f, 0.01f);
//	entry.m_CollisionMask = CollisionMask();		//TODO:
	entry.m_Flags.m_Map.m_Kinematic = bodyentry.m_Kinematic;

	m_DynamicsWorld->addRigidBody(&body);// , (short)entry.m_CollisionMask.Body, (short)entry.m_CollisionMask.Group);

//	entry.m_Flags.m_Map.m_Valid = true;
//	Physics::vec3 pos;
//	XML::Vector::Read(node, "Position", pos);
//	entry.m_LocalTransform.setOrigin(pos);
//	entry.m_LocalTransform.setRotation(Physics::Quaternion(0, 0, 0, 1));
//	XML::Vector::Read(node, "Scale", entry.m_Scale, Physics::vec3(1, 1, 1));
//	entry.m_SelfHandle = h;
//	entry.m_OwnerEntity = Owner;

	m_EntityMapper.SetHandle(Owner, entry.m_SelfHandle);
	entry.m_Flags.m_Map.m_Valid = true;
	return true;
}

bool BodyComponent::SetShape(Handle ShapeHandle, Handle BodyHandle, btCollisionShape * ptr) {
	auto *ht = GetHandleTable();
	HandleIndex index;
	if (!ht->GetHandleIndex(this, BodyHandle, index)) {
		AddLogf(Error, "Cannot set shape to invalid handle!");
		return false;
	}
	if (!ht->IsValid(ShapeHandle) && ptr) {
		AddLogf(Error, "Cannot set shape using invalid handle!");
		return false;
	}

	auto &entry = m_Array[index];
	auto &body = m_BulletRigidBody[index];

	entry.m_Flags.m_Map.m_HasShape = ptr != nullptr;
	vec3 internia;
	body.setCollisionShape(ptr);
	if (ptr) {
		ptr->calculateLocalInertia(entry.m_Mass, internia);
		body.setMassProps(entry.m_Mass, internia);
		m_DynamicsWorld->addRigidBody(&body);
	} else {
		body.setMassProps(0.0f, internia);
		m_DynamicsWorld->removeRigidBody(&body);
	}

	return true;
}

//---------------------------------------------------------------------------------------

bool BodyComponent::GetInstanceHandle(Entity Owner, Handle & hout) {
	auto h = m_EntityMapper.GetHandle(Owner);
	if (!GetHandleTable()->IsValid(this, h)) {
		return false;
	}
	hout = h;
	return true;
}

//-------------------------------------------------------------------------------------------------

bool BodyComponent::LoadComponentConfiguration(pugi::xml_node node) {
	//TODO:

	//void SetGravity(const btVector3& vector) { m_DynamicsWorld->setGravity(vector); }
	//m_DynamicsWorld->setGravity(vec3(0,0,0));
	return true;
}

//-------------------------------------------------------------------------------------------------

void BodyComponent::DefferedDraw(Graphic::cRenderDevice & dev) {
	glEnable(GL_BLEND);
	glDisable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);

	if (!m_DebugDrawer) {
		m_DebugDrawer = std::make_unique<BulletDebugDrawer>();
		m_DynamicsWorld->setDebugDrawer(m_DebugDrawer.get());
	}
	m_DebugDrawer->PrepareDebugDraw(dev);
	m_DynamicsWorld->debugDrawWorld();
	m_DebugDrawer->Submit(dev);

	glDisable(GL_BLEND);
	glDisable(GL_DEPTH_TEST);
//	glEnable(GL_CULL_FACE);
}

BodyComponent::BodyEntry * BodyComponent::GetEntry(Handle h) {
	auto *ht = GetHandleTable();
	HandleIndex hi;
	if (!ht->GetHandleIndex(this, h, hi)) {
		//AddLog(Debug, "Attempt to get TransformEntry for invalid Entity!");
		return nullptr;
	}
	return  &m_Array[hi];
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
#if 0
disabled code

void GameScene::DoMove(const MoveConfig &conf) {
	BaseClass::DoMove(conf);
	m_Objects.Process(conf);

	struct T {
		static bool t(btManifoldPoint& cp, void* body0,void* body1) {
			if (cp.m_userPersistentData)
				return false;

			cp.m_userPersistentData = body0;
			btCollisionObject *b0 = (btCollisionObject*)body0;
			btCollisionObject *b1 = (btCollisionObject*)body1;
			Object *o0 = (Object*)b0->getUserPointer();
			Object *o1 = (Object*)b1->getUserPointer();

			AddLog(Hint, "contact " << b0 << "@" << o0->GetName() << "   " << b1 << "@" << o1->GetName());
			return false;
		}
		static bool destroy(void* userPersistentData) {
			return true;
		}
	};
	gContactProcessedCallback = &T::t;
	gContactDestroyedCallback = &T::destroy;

	AddLog(Hint, "Step begin");
	auto t = std::chrono::steady_clock::now();
	m_Physics->Step(conf.TimeDelta);
	if (conf.m_SecondPeriod) {
		std::chrono::duration<double> sec = std::chrono::steady_clock::now() - t;
		AddLogf(Performance, "ph step: %f ms", (float)(sec.count() * 1000));
	}

	AddLog(Hint, "Step end");
}

#endif

} //namespace Physics 
} //namespace MoonGlare 
