/*
	Generated by cppsrc.sh
	On 2014-12-28 18:55:01,12
	by Paweu
*/
#include <pch.h>
#include <MoonGlare.h>

#ifdef DEBUG
#pragma comment (lib, "bullet3-master/bin/LinearMath_vs2010_debug.lib")
#pragma comment (lib, "bullet3-master/bin/BulletDynamics_vs2010_debug.lib")
#pragma comment (lib, "bullet3-master/bin/BulletCollision_vs2010_debug.lib")
#else
#pragma comment (lib, "bullet3-master/bin/LinearMath_vs2010.lib")
#pragma comment (lib, "bullet3-master/bin/BulletDynamics_vs2010.lib")
#pragma comment (lib, "bullet3-master/bin/BulletCollision_vs2010.lib")
#endif

namespace Physics {

//---------------------------------------------------------------------------------------

GABI_IMPLEMENT_CLASS(PhysicEngine);
RegisterApiDerivedClass(PhysicEngine, &PhysicEngine::RegisterScriptApi);
RegisterDebugApi(Physics, &PhysicEngine::RegisterDebugScriptApi, "Physics");

PhysicEngine::PhysicEngine():
		BaseClass(),
		m_CollisionConfiguration(),
		m_Dispatcher(),
		m_Broadphase(),
		m_Solver(),
		m_DynamicsWorld(),
		m_DebugDrawer(),
		m_Flags(0) {

	m_CollisionConfiguration = std::make_unique<btDefaultCollisionConfiguration>();
	//use the default collision dispatcher
	m_Dispatcher = std::make_unique<btCollisionDispatcher>(m_CollisionConfiguration.get());
	m_Broadphase = std::make_unique<btDbvtBroadphase>();
	//use the default constraint solver
	m_Solver = std::make_unique<btSequentialImpulseConstraintSolver>();
	m_DynamicsWorld = std::make_unique<btDiscreteDynamicsWorld>(m_Dispatcher.get(), m_Broadphase.get(), m_Solver.get(), m_CollisionConfiguration.get());
	
	m_DynamicsWorld->setGravity(btVector3(0, -math::Constants::Earth::g, 0));

	//m_DynamicsWorld->att/
	//m_DynamicsWorld->getPairCache()->setInternalGhostPairCallback)(;

	//m_DynamicsWorld->setInternalTickCallback(&BulletInternalTickCallBack, this);
}

PhysicEngine::~PhysicEngine() {
	Clean();
}

//---------------------------------------------------------------------------------------

#if DEBUG
void PhysicEngine::RegisterDebugScriptApi(ApiInitializer &api) {
	api
		.addFunction("Enable", &Utils::Template::DynamicSet<bool, &Config::Current::EnableFlags::Physics>)
		.addFunction("DebugDraw", &Utils::Template::DynamicSet<bool, &Config::Current::EnableFlags::PhysicsDebugDraw>)
	;
}
#endif

void PhysicEngine::RegisterScriptApi(ApiInitializer &api) {
}

void PhysicEngine::Clean() {
#if 0
	//cleanup in the reverse order of creation/initialization
	//remove the rigid bodies from the dynamics world and delete them
	for (int i = __pDynamicsWorld->getNumCollisionObjects() - 1; i >= 0; i--) {
		btCollisionObject* obj = __pDynamicsWorld->getCollisionObjectArray()[i];
		btRigidBody* body = btRigidBody::upcast(obj);
		if (body && body->getMotionState()) {
			delete body->getMotionState();
		}
		__pDynamicsWorld->removeCollisionObject(obj);
		delete obj;
	}
	//delete collision shapes
	for (int j = 0; j < __pCollisionShapes.size(); j++) {
		btCollisionShape* shape = __pCollisionShapes[j];
		delete shape;
	}
	__pCollisionShapes.clear();
#endif
}

//---------------------------------------------------------------------------------------

void PhysicEngine::ProcessTickCallBack(btScalar timeStep) {
	//AddLogf(Hint, "World tick %f sec", timeStep);
#if 0
	int numManifolds = m_Dispatcher->getNumManifolds();
	for (int i = 0; i < numManifolds; i++) {
		btPersistentManifold* contactManifold = m_Dispatcher->getManifoldByIndexInternal(i);
		const btCollisionObject* obA = static_cast<const btCollisionObject*>(contactManifold->getBody0());
		const btCollisionObject* obB = static_cast<const btCollisionObject*>(contactManifold->getBody1());
		Object *o0 = (Object*)obA->getUserPointer();
		Object *o1 = (Object*)obB->getUserPointer();

		//AddLog(Hint, "contact " << obA << "@" << o0->GetName() << "   " << obB << "@" << o1->GetName());
#if 0
		int numContacts = contactManifold->getNumContacts();
		for (int j = 0; j < numContacts; j++) {
			btManifoldPoint& pt = contactManifold->getContactPoint(j);
			if (pt.getDistance() < 0.f) {
				const btVector3& ptA = pt.getPositionWorldOnA();
				const btVector3& ptB = pt.getPositionWorldOnB();
				const btVector3& normalOnB = pt.m_normalWorldOnB;
			}
	}
#endif // 0
}
#endif // 0
}

void PhysicEngine::BulletInternalTickCallBack(btDynamicsWorld *world, btScalar timeStep) {
	PhysicEngine *w = static_cast<PhysicEngine *>(world->getWorldUserInfo());
	w->ProcessTickCallBack(timeStep);
}

//---------------------------------------------------------------------------------------

void PhysicEngine::RemoveBody(Body *b) {
	m_DynamicsWorld->removeRigidBody(b->GetRawBody());
}

void PhysicEngine::AddBody(Body *b) {
	CollisionMask cm = b->GetCollisionMask();
	m_DynamicsWorld->addRigidBody(b->GetRawBody(), (short)cm.Body, (short)cm.Group);
}

//---------------------------------------------------------------------------------------

void PhysicEngine::DoDebugDraw(Graphic::cRenderDevice &dev) {
	if (!Config::Current::EnableFlags::PhysicsDebugDraw) 
		return;
	if (!m_DebugDrawer) {
		m_DebugDrawer = std::make_unique<BulletDebugDrawer>();
		m_DynamicsWorld->setDebugDrawer(m_DebugDrawer.get());
	}
	m_DebugDrawer->PrepareDebugDraw(dev);
	m_DynamicsWorld->debugDrawWorld();
	m_DebugDrawer->Submit(dev);
}

} //namespace Physics 
