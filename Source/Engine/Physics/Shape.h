/*
	Generated by cppsrc.sh
	On 2014-12-29 18:46:32,92
	by Paweu
*/

#pragma once
#ifndef Shape_H
#define Shape_H

namespace Physics {

//! Dummy middle class to join different inheritance trees
class ShapeSubBase : public cRootClass {
	SPACERTTI_DECLARE_ABSTRACT_CLASS(ShapeSubBase, cRootClass)
public:
	ShapeSubBase() { }
	~ShapeSubBase() { }
	//static ShapeSubBase* UpCast(Shape* s) { return dynamic_cast<ShapeSubBase*>(s); }

	virtual btCollisionShape* GetRawShape() const = 0;
	virtual void CalculateLocalInertia(float mass, vec3 &Inertia) const = 0;
protected:
}; 

//----------------------------------------------------------------

//! Base class for shape constructors
class ShapeConstructor : public cRootClass {
	SPACERTTI_DECLARE_ABSTRACT_CLASS(ShapeConstructor, cRootClass)
public:
	ShapeConstructor();
	~ShapeConstructor();

	//! Shape generation method. Shapes may be shared.
	//! \param Scale Scale of new shape. Not all types of shape supports it.
	virtual SharedShape ConstructShape(float Scale) = 0;
	//! Loads metadata from XML,.
	//! \param node root node for shape metadata
	virtual bool LoadMeta(const xml_node node) = 0;
	//! Add verticles to shape. Has usage only for shapes that needs and supports them.
	virtual bool AddVerticles(const Graphic::VertexVector &verticles);
	//! Set mesh triangles shape. Has usage only for shapes that needs and supports them.
	virtual bool AddTriangles(const Graphic::VertexVector &verticles, const Graphic::IndexVector &index);

	//! Base function for loading shape constructor from xml.
	static ShapeConstructorPtr LoadConstructor(const xml_node node);
protected:
	//! internal class for sorting by floats.
	class FuzzyLess : public std::binary_function<float, float, bool> {
	public:
		FuzzyLess(float e = 1e-6) : epsilon(e) { }
		bool operator()(const float &left, const float &right) const {
			return (abs(left - right) > epsilon) && (left < right);
		}
		float epsilon;
	};
	void CommonInitShape(SharedShape shape);
private:
};

//----------------------------------------------------------------

//! Box collision shape constructor
class BoxShapeConstructor : public ShapeConstructor {
	SPACERTTI_DECLARE_CLASS(BoxShapeConstructor, ShapeConstructor);
public:
	BoxShapeConstructor();
	BoxShapeConstructor(const math::vec3 &Edge);
	~BoxShapeConstructor();

	virtual SharedShape ConstructShape(float Scale);
	virtual bool LoadMeta(const xml_node node);
private:
	std::map<float, SharedShape, FuzzyLess> m_ShapeDatabase;
	math::vec3 m_Edge;
};

//! Class represents box shaped collision shape
class BoxShape : public btBoxShape, public ShapeSubBase {
	SPACERTTI_DECLARE_CLASS_NOCREATOR(BoxShape, ShapeSubBase)
public:
	//! \param boxHalfExtents half sizes of the box edges
	BoxShape(const btVector3 &boxHalfExtents) : btBoxShape(boxHalfExtents) {  }
	//! \param boxHalfExtents half size of the box
	BoxShape(btScalar HalfEdge) : btBoxShape(btVector3(HalfEdge, HalfEdge, HalfEdge)) {  }
	virtual btCollisionShape* GetRawShape() const override { return dynamic_cast<btBoxShape*>(const_cast<ThisClass*>(this)); }
	virtual void CalculateLocalInertia(float mass, vec3 &Inertia) const override { calculateLocalInertia(mass, Inertia); }
protected:
};

//----------------------------------------------------------------

//! Capsule collision shape constructor
//! May be used to humanoid characters
class CapsuleShapeConstructor : public ShapeConstructor {
	SPACERTTI_DECLARE_CLASS(CapsuleShapeConstructor, ShapeConstructor);
public:
	CapsuleShapeConstructor(float Radius = 0, float Height = 0);
	~CapsuleShapeConstructor();

	virtual SharedShape ConstructShape(float Scale);
	virtual bool LoadMeta(const xml_node node);
private:
	std::map<float, SharedShape, FuzzyLess> m_ShapeDatabase;
	float m_Radius, m_Height;
};

//! Class represents Capsule shaped collision shape
//! The total height is height+2*radius
class CapsuleShapeShape : public btCapsuleShape, public ShapeSubBase {
	SPACERTTI_DECLARE_CLASS_NOCREATOR(CapsuleShapeShape, ShapeSubBase)
public:
	//! \param Radius Radius of the spheres
	//! \param Height Distance between center of spheres
	CapsuleShapeShape(float Radius = 0, float Height = 0) : btCapsuleShape(Radius, Height) {  }
	virtual btCollisionShape* GetRawShape() const override { return dynamic_cast<btCapsuleShape*>(const_cast<ThisClass*>(this)); }
	virtual void CalculateLocalInertia(float mass, vec3 &Inertia) const override { calculateLocalInertia(mass, Inertia); }
protected:
};

//----------------------------------------------------------------

//! Capsule collision shape constructor
//! May be used to humanoid characters
class CylinderShapeConstructor : public ShapeConstructor {
	SPACERTTI_DECLARE_CLASS(CylinderShapeConstructor, ShapeConstructor);
public:
	CylinderShapeConstructor(float Radius = 0, float Height = 0);
	~CylinderShapeConstructor();

	virtual SharedShape ConstructShape(float Scale);
	virtual bool LoadMeta(const xml_node node);
private:
	std::map<float, SharedShape, FuzzyLess> m_ShapeDatabase;
	float m_Radius, m_Height;
};

//! Class represents Capsule shaped collision shape
//! The total height is height+2*radius
class CylinderShapeShape : public btCylinderShape, public ShapeSubBase {
	SPACERTTI_DECLARE_CLASS_NOCREATOR(CylinderShapeShape, ShapeSubBase)
public:
	//! \param Radius Radius of the spheres
	//! \param Height Distance between center of spheres
	CylinderShapeShape(const btVector3 &boxHalfExtents) : btCylinderShape(boxHalfExtents) { }
	virtual btCollisionShape* GetRawShape() const override { return dynamic_cast<btCylinderShape*>(const_cast<ThisClass*>(this)); }
	virtual void CalculateLocalInertia(float mass, vec3 &Inertia) const override { calculateLocalInertia(mass, Inertia); }
protected:
};

//----------------------------------------------------------------

//! Sphere collision shape constructor
class SphereShapeConstructor : public ShapeConstructor {
	SPACERTTI_DECLARE_CLASS(SphereShapeConstructor, ShapeConstructor);
public:
	SphereShapeConstructor(float Radius = 0);
	~SphereShapeConstructor();

	virtual SharedShape ConstructShape(float Scale);
	virtual bool LoadMeta(const xml_node node);
private:
	std::map<float, SharedShape, FuzzyLess> m_ShapeDatabase;
	float m_Radius;
};

//! Class represents sphare shaped collision shape
class SphereShape : public btSphereShape, public ShapeSubBase {
	SPACERTTI_DECLARE_CLASS_NOCREATOR(SphereShape, ShapeSubBase)
public:
	//! \param Radius Radius of the sphere
	SphereShape(btScalar Radius) : btSphereShape(Radius) {  }
	virtual btCollisionShape* GetRawShape() const override { return dynamic_cast<btSphereShape*>(const_cast<ThisClass*>(this)); }
	virtual void CalculateLocalInertia(float mass, vec3 &Inertia) const override { calculateLocalInertia(mass, Inertia); }
protected:
};

//----------------------------------------------------------------

class ConvexMeshShapeConstructor : public ShapeConstructor {
	SPACERTTI_DECLARE_CLASS(ConvexMeshShapeConstructor, ShapeConstructor);
public:
	ConvexMeshShapeConstructor();
	~ConvexMeshShapeConstructor();

	virtual SharedShape ConstructShape(float Scale);
	virtual bool LoadMeta(const xml_node node);
	virtual bool AddVerticles(const Graphic::VertexVector &verticles);
	virtual bool AddTriangles(const Graphic::VertexVector &verticles, const Graphic::IndexVector &index);
private:
	SharedShape m_Shape;
};

//! Class represents collision shape built of convex hull of independent points
class ConvexMeshShape : public btConvexHullShape, public ShapeSubBase {
	SPACERTTI_DECLARE_CLASS_NOCREATOR(ConvexMeshShape, ShapeSubBase)
public:
	//! \param verticles vector of points
	ConvexMeshShape(const Graphic::VertexVector &verticles);
	virtual btCollisionShape* GetRawShape() const override { return dynamic_cast<btConvexHullShape*>(const_cast<ThisClass*>(this)); }
	virtual void CalculateLocalInertia(float mass, vec3 &Inertia) const override { calculateLocalInertia(mass, Inertia); }
protected:
};

//----------------------------------------------------------------

class TriangleMeshShapeConstructor : public ShapeConstructor {
	SPACERTTI_DECLARE_CLASS(TriangleMeshShapeConstructor, ShapeConstructor);
public:
	TriangleMeshShapeConstructor();
	~TriangleMeshShapeConstructor();

	virtual SharedShape ConstructShape(float Scale);
	virtual bool LoadMeta(const xml_node node);
	virtual bool AddVerticles(const Graphic::VertexVector &verticles);
	virtual bool AddTriangles(const Graphic::VertexVector &verticles, const Graphic::IndexVector &index);
private:
	std::unique_ptr<btTriangleMesh> m_mesh;
	SharedShape m_Shape;
};

//! Class represents collision mesh built of triangles
class TriangleMeshShape : public btBvhTriangleMeshShape, public ShapeSubBase {
	SPACERTTI_DECLARE_CLASS_NOCREATOR(TriangleMeshShape, ShapeSubBase)
public:
	//! \param mesh mesh construdted from triangles
	TriangleMeshShape(btStridingMeshInterface *mesh): BaseClass(), btBvhTriangleMeshShape(mesh, true) { }
	virtual btCollisionShape* GetRawShape() const override { return dynamic_cast<btBvhTriangleMeshShape*>(const_cast<ThisClass*>(this)); }
	virtual void CalculateLocalInertia(float mass, vec3 &Inertia) const override;
protected:
};	

} //namespace Physics 

#endif
