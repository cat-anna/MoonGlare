/*
	Generated by cppsrc.sh
	On 2015-01-17 23:03:11,97
	by Paweu
*/

#pragma once
#ifndef PointLightShader_H
#define PointLightShader_H

namespace Graphic {
namespace Dereferred {

struct PointLightShaderDescriptor {
	enum class InLayout {
		Position,
	};
	enum class OutLayout {
		FragColor,
	};
	enum class Uniform {
		CameraMatrix,
		ModelMatrix,
		CameraPos,

		//ShadowMapSize,
		//EnableShadows,

		Color,
		AmbientIntensity,
		DiffuseIntensity,
		Position,

		AttenuationLinear,
		AttenuationExp,
		AttenuationConstant,
		AttenuationMinThreshold,

		//		ScreenSize,

		MaxValue,
	};
	enum class Sampler {
		Unused,
		PositionMap,
		ColorMap,
		NormalMap,
		MaxValue,
	};

	constexpr static const char* GetName(Uniform u) {
		switch (u) {
		case Uniform::CameraMatrix: return "CameraMatrix";
		case Uniform::ModelMatrix: return "ModelMatrix";
		case Uniform::CameraPos: return "CameraPos";

		//case Uniform::ShadowMapSize: return "ShadowMapSize";
		//case Uniform::EnableShadows: return "EnableShadowTest";

		case Uniform::Color: return "PointLight.Base.Color";
		case Uniform::AmbientIntensity: return "PointLight.Base.AmbientIntensity";
		case Uniform::DiffuseIntensity: return "PointLight.Base.DiffuseIntensity";
		case Uniform::Position: return "PointLight.Position";

		case Uniform::AttenuationLinear: return "PointLight.Atten.Linear";
		case Uniform::AttenuationExp: return "PointLight.Atten.Exp";
		case Uniform::AttenuationConstant: return "PointLight.Atten.Constant";
		case Uniform::AttenuationMinThreshold: return "PointLight.Atten.MinThreshold";

//		case Uniform::ScreenSize: return "ScreenSize";
		default: return nullptr;
		}
	}
	constexpr static const char* GetSamplerName(Sampler s) {
		switch (s) {
		case Sampler::PositionMap: return "PositionMap";
		case Sampler::ColorMap: return "ColorMap";
		case Sampler::NormalMap: return "NormalMap";
		default: return nullptr;
		}
	}

};

class PointLightShader : public LightingPassShader {
	SPACERTTI_DECLARE_CLASS_NOCREATOR(PointLightShader, LightingPassShader);
public:
 	PointLightShader(GLuint ShaderProgram, const string &ProgramName);
 	virtual ~PointLightShader();

	void Bind(const ::MoonGlare::Renderer::Light::PointLight &light) const {
		BaseClass::BindLightBase(light.m_Base);
		glUniform3fv(m_PositionLocation, 1, &light.m_Position[0]); 
		glUniform1f(m_AttenuationLinearLocation, light.m_Attenuation.m_Linear);
		glUniform1f(m_AttenuationExpLocation, light.m_Attenuation.m_Exp);
		glUniform1f(m_AttenuationConstantLocation, light.m_Attenuation.m_Constant);
		glUniform1f(m_AttenuationMinThresholdLocation, light.m_Attenuation.m_Threshold);
	}
protected:
	GLuint m_PositionLocation;
	GLuint m_AttenuationLinearLocation;
	GLuint m_AttenuationExpLocation;
	GLuint m_AttenuationConstantLocation;
	GLuint m_AttenuationMinThresholdLocation;
};

} //namespace Dereferred 
} //namespace Graphic 

#endif
