/*
    Generated by cppsrc.sh
    On 2015-01-14 22:33:57,87
    by Paweu
*/

#pragma once

#include "DereferredFrameBuffer.h"

#include "GeometryShader.h"
#include "PointLightShader.h"
#include "DirectionalLightShader.h"
#include "SpotLightShader.h"
#include "StencilShader.h"
#include "../ShadowMapShader.h"

#include <Renderer/Resources/ResourceManager.h>
#include <Renderer/Light.h>
#include <Renderer/VirtualCamera.h>

namespace Graphic {
namespace Dereferred {

class DereferredPipeline {
    friend struct DefferedSink;
public:
    void Initialize(World *world);
    void Finalize();

    DefferedSink* GetDefferedSink() const { return m_DefferedSink.get(); }

    DereferredFrameBuffer m_Buffer;
private: 
    World *m_World = nullptr;
    MoonGlare::DataClasses::ModelPtr m_Sphere, m_Cone;
    VAO m_DirectionalQuad;
    mem::aligned_ptr<DefferedSink> m_DefferedSink;
    emath::fvec2 m_ScreenSize;

    bool InitializeDirectionalQuad();
};

//------------------------------------------------------------------------------------------

struct DefferedSink {
    friend class DereferredPipeline;

    void Reset(Renderer::Frame *frame);
    void Initialize(Renderer::RendererFacade *Renderer);

    struct RObj {
        DefferedSink *m_sink = nullptr;

        RObj& Mesh(Renderer::MaterialResourceHandle material, unsigned NumIndices, unsigned BaseIndex, 
            unsigned BaseVertex, unsigned ElementsType) {
            m_sink->Mesh(material, NumIndices, BaseIndex, BaseVertex, ElementsType);
            return *this;
        }
    };

    RObj Begin(const math::mat4 &ModelMatrix, const Graphic::VAO &vao);

    void SubmitDirectionalLight(const Renderer::Light::LightBase &linfo);
    void SubmitPointLight(const Renderer::Light::PointLight &linfo);
    void SubmitSpotLight(const Renderer::Light::SpotLight &linfo);

    Renderer::VirtualCamera m_Camera;
protected:
    Renderer::Commands::CommandQueue *m_GeometryQueue = nullptr;	
    Renderer::Commands::CommandQueue *m_LightGeometryQueue = nullptr;
    Renderer::Commands::CommandQueue *m_DirectionalLightQueue = nullptr;
    Renderer::Commands::CommandQueue *m_PointLightQueue = nullptr;
    Renderer::Commands::CommandQueue *m_SpotLightQueue = nullptr;
    Renderer::Commands::CommandQueue *m_SpotLightShadowQueue = nullptr;

    Renderer::Resources::ShaderBuilder<GeometryShaderDescriptor> m_GeometryShader;
    Renderer::Resources::ShaderBuilder<Shaders::ShadowMapShaderDescriptor> m_ShadowShader;
    Renderer::Resources::ShaderBuilder<DirectionalLightShaderDescriptor> m_DirectionalLightShader;
    Renderer::Resources::ShaderBuilder<PointLightShaderDescriptor> m_PointLightShader;
    Renderer::Resources::ShaderBuilder<StencilLightShaderDescriptor> m_StencilShader;
    Renderer::Resources::ShaderBuilder<SpotLightShaderDescriptor> m_SpotShader;

    Renderer::ShaderResourceHandle<Shaders::ShadowMapShaderDescriptor> m_ShaderShadowMapHandle{};
    Renderer::ShaderResourceHandle<SpotLightShaderDescriptor> m_ShaderLightSpotHandle{};
    Renderer::ShaderResourceHandle<PointLightShaderDescriptor> m_ShaderLightPointHandle{};
    Renderer::ShaderResourceHandle<DirectionalLightShaderDescriptor> m_ShaderLightDirectionalHandle{};
    Renderer::ShaderResourceHandle<StencilLightShaderDescriptor> m_ShaderStencilHandle{};
    Renderer::ShaderResourceHandle<GeometryShaderDescriptor> m_ShaderGeometryHandle{};

    Renderer::Frame *m_frame = nullptr;
    Renderer::RendererFacade *m_Renderer = nullptr;
    DereferredPipeline *m_DereferredPipeline;

    void Mesh(Renderer::MaterialResourceHandle material, unsigned NumIndices, unsigned BaseIndex, unsigned BaseVertex, unsigned ElementsType);
};

} //namespace Dereferred
} //namespace Graphic 
