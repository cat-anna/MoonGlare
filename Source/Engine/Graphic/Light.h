/*
	Generated by cppsrc.sh
	On 2015-01-16 20:14:39,46
	by Paweu
*/

#pragma once
#ifndef Light_H
#define Light_H

#include <Renderer/Light.h>

#include "PlaneShadowMap.h"

namespace Graphic {
namespace Light {

struct LightBase;

//----------------------------------------------------------------------------------

struct LightBase : public MoonGlare::Renderer::Light::LightBase {
	Physics::vec3 m_Position;
	math::Quaternion m_Quaternion;

//	bool IgnoreOwnerGeometry = false;
	float CutOff = 0.92f;

	PlaneShadowMap *ShadowMap = nullptr;

	LightBase() {
		m_Attenuation.m_Constant = 0.0f;	   //m_Constant = 0.0f;
		m_Attenuation.m_Exp = 0.01f;		   //m_Linear = 0.9f;
		m_Attenuation.m_Linear = 0.02f;		   //m_Exp = 0.2f;
		m_Attenuation.m_MinThreshold = 10.0f;  //m_MinThreshold = 0.5f;
		m_AmbientIntensity = 0.5f;
		m_DiffuseIntensity = 0.1f;
		m_Color = vec3(1);
	}

	void SetCutOff(float f) {
		f = 0.8f * glm::clamp(f, 0.0f, 1.0f);
		CutOff = 0.92f + f;
	}

	float CalcPointLightInfluenceRadius() const {
		float MaxChannel = fmax(fmax(m_Color.x, m_Color.y), m_Color.z);
		return m_Attenuation.Threshold(MaxChannel * m_DiffuseIntensity);
	}

	bool LoadMeta(const xml_node node);
};

//----------------------------------------------------------------------------------

struct LightConfigurationVector {
	std::vector < LightBase > PointLights;
	std::vector < LightBase > DirectionalLights;
	std::vector < LightBase > SpotLights;
};

} //namespace Light 
} //namespace Graphic 

#endif
