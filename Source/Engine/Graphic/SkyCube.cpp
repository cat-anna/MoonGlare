/*
	Generated by cppsrc.sh
	On 2015-01-21  6:15:50,14
	by Paweu
*/
#include <pch.h>
#include <MoonGlare.h>

namespace Graphic {

SkyCube::SkyCube() {
	for (unsigned i = 0; i < Faces::MaxValue; ++i)
		m_Textures[i].Free();
}

SkyCube::~SkyCube() {
	for (unsigned i = 0; i < Faces::MaxValue; ++i)
		m_Textures[i].Free();
}

//---------------------------------------------------------------------------------------

bool SkyCube::LoadMeta(const xml_node node, FileSystem::DirectoryReader &reader) {
	m_Size = node.attribute("Size").as_float();
	XML::Vector::Read(node, "Color", m_BackColor, m_BackColor, XML::Captions::RGBA);

	//have to be consistent with Faces order
	static const char *Names[] ={ "Left", "Right", "Front", "Back", "Top", "Bottom" };

	//for (unsigned i = 0; i < Faces::MaxValue; ++i) {
	//	const char *file = node.child(Names[i]).text().as_string();
	//	if (!file) {
	//		AddLogf(Warning, "There is no texture file for sky cube face '%s'", Names[i]);
	//		continue;
	//	}
	//	FileSystem::TextureFile tex;
	//	if (!reader.OpenTexture(tex, file)) {
	//		m_Textures[i].Free();
	//		AddLogf(Error, "An error has occur during loading texture '%s' for sky cube face '%s'", file, Names[i]);
	//		continue;
	//	}
	//	if (tex) {
	//		tex->swap(m_Textures[i]);
	//	}
	//}
	//return true;
	return false;
}

//---------------------------------------------------------------------------------------

void SkyCube::Render(cRenderDevice &dev) const {
//	dev.CurrentShader()->SetBackColor(m_BackColor);
//	m_VAO.Bind();
//	for (unsigned i = 0, j = m_Mesh.size(); i < j; ++i) {
//		m_Textures[i].Bind();
//		m_VAO.DrawElements(m_Mesh[i]);
//	}
//	m_VAO.UnBind();
}

//---------------------------------------------------------------------------------------

bool SkyCube::Initialize() {
	ResetVAO();
	return true;
}

bool SkyCube::Finalize() {

	return true;
}

void SkyCube::ResetVAO() {
	NormalVector Normals;
#if 0
	={
		math::vec3(0.0f, 0.0f, 1.0f),
		math::vec3(0.0f, 0.0f, 1.0f),
		math::vec3(0.0f, 0.0f, 1.0f),
		math::vec3(0.0f, 0.0f, 1.0f),
	};
#endif // 0

	float h = m_Size / 2.0f;

	VertexVector Vertex {
//Left
		math::vec3(-h,  -h,    h),
		math::vec3(-h,  -h,   -h),
		math::vec3(-h,   h,   -h),
		math::vec3(-h,   h,    h),
//Right
		math::vec3( h,   h,   -h),
		math::vec3( h,   h,    h),
		math::vec3( h,  -h,    h),
		math::vec3( h,  -h,   -h),
//Front
		math::vec3( -h,  -h,  -h),
		math::vec3(  h,  -h,  -h),
		math::vec3(  h,   h,  -h),
		math::vec3( -h,   h,  -h),
//Back 
		math::vec3(  h,   h,   h),
		math::vec3( -h,   h,   h),
		math::vec3( -h,  -h,   h),
		math::vec3(  h,  -h,   h),
//Top
		math::vec3( -h,   h,  -h),
		math::vec3(  h,   h,  -h),
		math::vec3(  h,   h,   h),
		math::vec3( -h,   h,   h),
//Bottom
		math::vec3( -h,  -h,  -h),
		math::vec3(  h,  -h,  -h),
		math::vec3(  h,  -h,   h),
		math::vec3( -h,  -h,   h),
	};

	IndexVector Index {
		 0,  1,  2,  3,
		 4,  5,  6,  7,
		 8,  9, 10, 11,
		12, 13, 14, 15,
		16, 17, 18, 19,
		20, 21, 22, 23,
	};

	TexCoordVector Texture = {
//Left
		math::vec2(0.0f, 0.0f),
		math::vec2(1.0f, 0.0f),
		math::vec2(1.0f, 1.0f),
		math::vec2(0.0f, 1.0f),
//Right
		math::vec2(0.0f, 1.0f),
		math::vec2(1.0f, 1.0f),
		math::vec2(1.0f, 0.0f),
		math::vec2(0.0f, 0.0f),
//Front
		math::vec2(0.0f, 0.0f),
		math::vec2(1.0f, 0.0f),
		math::vec2(1.0f, 1.0f),
		math::vec2(0.0f, 1.0f),
//Back
		math::vec2(0.0f, 1.0f),
		math::vec2(1.0f, 1.0f),
		math::vec2(1.0f, 0.0f),
		math::vec2(0.0f, 0.0f),
//Top
		math::vec2(0.0f, 0.0f),
		math::vec2(0.0f, 1.0f),
		math::vec2(1.0f, 1.0f),
		math::vec2(1.0f, 0.0f),
//Bottom
		math::vec2(1.0f, 1.0f),
		math::vec2(1.0f, 0.0f),
		math::vec2(0.0f, 0.0f),
		math::vec2(0.0f, 1.0f),
};

	//unsigned IndexCount = sizeof(Index) / sizeof(__int32);

	m_Mesh.clear();
	for (size_t i = 0; i < 6; i++) {
		m_Mesh.push_back_mesh(i * 4, 0, 4, Flags::fQuads);
	}

	m_VAO.DelayInit(Vertex, Texture, Normals, Index);
}

} //namespace Graphic 
