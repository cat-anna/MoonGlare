/*
	Generated by cppsrc.sh
	On 2014-12-13 13:22:00,37
	by Paweu
*/

#include <pch.h>
#include <MoonGlare.h>
#include <Engine/Core/Engine.h>
#include <Engine/iApplication.h>
#include "GraphicSettings.h"

#include <Core/InputProcessor.h>

namespace Graphic {

static string DumpGLFWMode(const GLFWvidmode* mode) {
	char buf[128];
	sprintf(buf, "%dx%d %dhz  bits: %dx%dx%d  ratio:%f", mode->width, mode->height, mode->refreshRate, mode->redBits, mode->blueBits, mode->greenBits, (float)mode->width/(float)mode->height);
	return buf;
}

static bool IsModeSuggested(const GLFWvidmode* mode) {
	if (mode->blueBits != 8 || mode->greenBits != 8 || mode->redBits != 8)
		return false;
	if (mode->refreshRate != 60)
		return false;
	if (mode->width < 1024)
		return false;
//	float ratio = (float)mode->width / (float)mode->height;
//	if (!((ratio >= 1.3f && ratio <= 1.4f) || (ratio >= 1.7f && ratio <= 1.8f)))
//		return false;
	return true;
}

//-------------------------------------------------------------------------------------------------

SPACERTTI_IMPLEMENT_CLASS_NOCREATOR(Window)
RegisterApiDerivedClass(Window, &Window::RegisterScriptApi);
RegisterDebugApi(DbgWindow, &Window::RegisterDebugScriptApi, "Graphic");

Window::Window(GLFWwindow *w, bool IsMainWindow):
		BaseClass(),
		m_Window(w), 
		m_Flags(0), 
		m_CursorPos(0), 
		m_CursorDelta(0), 
		m_Size(0),
		m_InputProcessor(nullptr) {
	CreateWindow();
	SetAllowMouseUnhook(DEBUG_TRUE);
	SetMainWindow(IsMainWindow);
}

//-------------------------------------------------------------------------------------------------

void Window::RegisterDebugScriptApi(::ApiInitializer &api) {
	struct funcs {
#ifdef DEBUG_SCRIPTAPI
		static void DumpGraphicModes() {
			int count;
			GLFWmonitor** monitors = glfwGetMonitors(&count);
			AddLog(Hint, "Detected Monitors: " << count);
			for (int i = 0; i < count; ++i) {
				int modecount;
				int widthMM, heightMM;
				GLFWmonitor* monitor = monitors[i];
				glfwGetMonitorPhysicalSize(monitor, &widthMM, &heightMM);
				AddLogf(Hint, "Monitor %d: %s %s", i, glfwGetMonitorName(monitor), (glfwGetPrimaryMonitor() == monitor?"PRIMARY":""));
				AddLogf(Hint, "Physical size: %dx%d mm ", widthMM, heightMM);
				AddLog(Hint, "Current mode: " << DumpGLFWMode(glfwGetVideoMode(monitor)));
				const GLFWvidmode* modes = glfwGetVideoModes(monitor, &modecount);
				AddLogf(Hint, "Available modes: ");
				for (int j = 0; j < modecount; ++j) {
					AddLog(Hint, j << ". -> " << DumpGLFWMode(modes + j));
				}
				AddLogf(Hint, "Suggested modes: ");
				for (int j = 0; j < modecount; ++j) {
					auto *mode = modes + j;
					if (!IsModeSuggested(mode))
						continue;
					
					AddLog(Hint, j << ". -> " << DumpGLFWMode(mode));
				}
			}
		}
#endif
	};

	api
#ifdef DEBUG_SCRIPTAPI
		.addFunction("DumpGraphicModes", &funcs::DumpGraphicModes)
#endif
		;
}

void Window::RegisterScriptApi(::ApiInitializer &api) {
	api
	.deriveClass<ThisClass, BaseClass>("cWindow")
		.addFunction("SetTitle", &ThisClass::SetTitle)

		.addCFunction("GetMonitors", &ThisClass::GetMonitors)
		.addCFunction("GetMonitorModes", &ThisClass::GetMonitorModes)
#ifdef DEBUG
		.addFunction("GrabMouse", &ThisClass::GrabMouse)
		.addFunction("ReleaseMouse", &ThisClass::ReleaseMouse)
		.addFunction("SetPosition", Utils::Template::DynamicArgumentConvert<ThisClass, math::uvec2, &ThisClass::SetPosition, int, int>::get())
#endif
	.endClass()
	.beginClass<GLFWvidmode>("cGLFWvidmode")
		.addData("Height", &GLFWvidmode::height, false)
		.addData("Width", &GLFWvidmode::width, false)
		.addData("RefreshRate", &GLFWvidmode::refreshRate, false)
	.endClass()
	; 
}

//-------------------------------------------------------------------------------------------------

int Window::GetMonitors(lua_State *lua) {
	int count;
	auto primarymonitor = glfwGetPrimaryMonitor();
	auto monitors = glfwGetMonitors(&count);

	lua_createtable(lua, 0, 0);

	for (int i = 0; i < count; ++i) {
		auto monitor = monitors[i];

		lua_pushinteger(lua, i + 1);
		lua_createtable(lua, 0, 0);

		lua_pushinteger(lua, i);
		lua_setfield(lua, -2, "Index");

		lua_pushstring(lua, glfwGetMonitorName(monitor));
		lua_setfield(lua, -2, "Name");

		if (monitor == primarymonitor) {
			lua_pushboolean(lua, 1);
			lua_setfield(lua, -2, "primary");
		}

		auto mode = glfwGetVideoMode(monitor);
		lua_pushinteger(lua, mode->height);
		lua_setfield(lua, -2, "Height");

		lua_pushinteger(lua, mode->width);
		lua_setfield(lua, -2, "Width");

		lua_settable(lua, -3);
	}

	return 1;
}

int Window::GetMonitorModes(lua_State *lua) {
	int monitorid = lua_tointeger(lua, -1);
	GLFWmonitor *mon;
	if (monitorid < -1)
		return 0;

	if (monitorid == -1) {
		mon = glfwGetPrimaryMonitor();
	} else {
		int c;
		auto mont = glfwGetMonitors(&c);
		if (c <= monitorid)
			return 0;
		mon = mont[monitorid];
	}

	int modecount;
	const GLFWvidmode* modes = glfwGetVideoModes(mon, &modecount);
	const GLFWvidmode* currmode = glfwGetVideoMode(mon);

	lua_createtable(lua, 0, 0);

	for (int i = 0, index = 0; i < modecount; ++i) {
		auto *mode = modes + i;
		if (!IsModeSuggested(mode))
			continue;

		++index;
		lua_pushinteger(lua, index);
		lua_createtable(lua, 0, 0);

		lua_pushinteger(lua, mode->height);
		lua_setfield(lua, -2, "Height");

		lua_pushinteger(lua, mode->width);
		lua_setfield(lua, -2, "Width");

		lua_pushinteger(lua, i);
		lua_setfield(lua, -2, "Index");

		//lua_pushinteger(lua, mode->refreshRate);
		//lua_setfield(lua, -2, "RefreshRate");

		if (memcmp(mode, currmode, sizeof(*currmode)) == 0) {
			lua_pushboolean(lua, 1);
			lua_setfield(lua, -2, "Current");
		}

		lua_settable(lua, -3);
	}

	return 1;
}

GLFWvidmode Window::GetCurrentMode() const {
	return GLFWvidmode{
		(int)m_Size[0],
		(int)m_Size[1],
		8, 8, 8,
		(int)GetRefreshRate()
	};
}

void Window::SetPosition(const math::uvec2 &pos) {
	glfwSetWindowPos(m_Window, pos[0], pos[1]);
}

//-------------------------------------------------------------------------------------------------

void Window::CreateWindow() {
	int iw, ih;
	glfwGetWindowSize(m_Window, &iw, &ih);
	m_Size = uvec2(iw, ih);
	GraphicSettings::Width::set(m_Size[0]);
	GraphicSettings::Height::set(m_Size[1]);

#if 0
	if (!fullscreen) {
		int mx, my;
		glfwGetMonitorPos(monitor, &mx, &my);
		glfwSetWindowPos(m_Window, mx, my);
	}
#endif // 0

	MakeCurrent();
	ExitCharMode();

	glfwSwapInterval(0);
	glfwSetWindowUserPointer(m_Window, this);
	glfwSetWindowCloseCallback(m_Window, glfw_close_callback);
	glfwSetMouseButtonCallback(m_Window, glfwMouseButtonCallback);
	glfwSetWindowFocusCallback(m_Window, glfw_focus_callback);
	glfwSetScrollCallback(m_Window, glfw_scroll_callback);
	//glfwSetCursorPosCallback(m_Window, glfw_mousepos_callback);

	AddLogf(Debug, "Created window %dx%d", iw, ih);
}

void Window::ProcessKey(int key, bool Pressed) {
	switch (key) {
	case GLFW_KEY_PRINT_SCREEN:
		if (!Pressed) return;
		Graphic::GetRenderDevice()->DelayedContextManip([this] {
			auto size = Size();
			auto img = MoonGlare::DataClasses::Texture::AllocateImage(size, MoonGlare::DataClasses::Texture::BPP::RGB);
			Graphic::GetRenderDevice()->ReadScreenPixels(img->image, size, img->value_type);

			char buf[128];

			std::time_t t = std::time(NULL);
			auto tm = *std::localtime(&t);
			sprintf(buf, "ScreenShot_%d-%d-%d_%d-%d-%d.png", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);

			MoonGlare::DataClasses::Texture::AsyncStoreImage(img, buf);
		});
		return;	
	case GLFW_KEY_ESCAPE:
			if (!Pressed) return;
			if (TestFlags(m_Flags, Flags::AllowMouseUnhook | Flags::MouseHooked)) {
				ReleaseMouse();
				return;
			}
		[[fallthrough]]
	default:
		if (m_InputProcessor)
			m_InputProcessor->SetKeyState(key, Pressed);
		return;
	}
}

//-------------------------------------------------------------------------------------------------
// handling GLFW

void Window::Process() {
	if (m_InputProcessor)
		m_InputProcessor->ClearStates();
	glfwPollEvents();
	if (IsMouseHooked()) {
		auto delta = CursorDelta();
		if (m_InputProcessor)
			m_InputProcessor->SetMouseDelta(delta);
	}
}

//-------------------------------------------------------------------------------------------------

void Window::glfw_mousepos_callback(GLFWwindow *window, double x, double y) {
	Window* w = ((Window*)glfwGetWindowUserPointer(window));
	vec2 pos = vec2(x, y);
	vec2 delta = pos - w->m_CursorPos;
	w->m_CursorPos = pos;
}

void Window::glfw_key_callback(GLFWwindow* window, int key, int scancode, int action, int mods){
	if (action == GLFW_REPEAT || key == GLFW_KEY_UNKNOWN) {
		return;
	}
	Window* w = ((Window*)glfwGetWindowUserPointer(window));
	w->ProcessKey(key, action == GLFW_PRESS);
}

void Window::GLFWCharModeCharCallback(GLFWwindow* window, unsigned int key) {
	Window* w = ((Window*)glfwGetWindowUserPointer(window));
	if (w->m_InputProcessor)
		w->m_InputProcessor->PushCharModeChar(key);
}

void Window::GLFWCharModeKeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {
	if (action == GLFW_REPEAT || key == GLFW_KEY_UNKNOWN) {
		return;
	}
	Window* w = ((Window*) glfwGetWindowUserPointer(window));
	if (w->m_InputProcessor)
		w->m_InputProcessor->PushCharModeKey(key, action == GLFW_PRESS);
}

void Window::glfw_close_callback(GLFWwindow* window){
	Window* w = ((Window*)glfwGetWindowUserPointer(window));
	if (w->IsMainWindow())
		GetApplication()->Exit();
}

void Window::glfwMouseButtonCallback(GLFWwindow *window, int button, int action, int rawmods){
	Window* w = ((Window*)glfwGetWindowUserPointer(window));
	if (!w->IsMouseHooked()) {
		if (action != GLFW_PRESS) return;
		w->GrabMouse();
		return;
	}

	//auto MouseBtn = static_cast<WindowInput::MouseButton>(button);
	//WindowInput::ModsStatus mods{ (unsigned)rawmods };

	if (w->m_InputProcessor)
		w->m_InputProcessor->SetMouseButtonState(button, action == GLFW_PRESS);
}

void Window::glfw_focus_callback(GLFWwindow* window, int focus) {
	Window* w = ((Window*)glfwGetWindowUserPointer(window));

	//if (!(app->m_Flags & AppFlag_AllowDeactivation))	return;
	bool inactive = !(focus == GL_FALSE);
	AddLog(Debug, "Window changed focus state to " << std::boolalpha << inactive);
	w->SetActive(inactive);
	if (!w->IsMainWindow()) return;
	if (!inactive) {
		//w->ReleaseMouse();
		GetApplication()->OnDeactivate();
	} else {
		GetApplication()->OnActivate();
		//w->GrabMouse();
	}
}

void Window::glfw_scroll_callback(GLFWwindow* window, double xoffset, double yoffset) {
	Window* w = ((Window*)glfwGetWindowUserPointer(window));
	if (!w->IsMouseHooked()) {
		return;
	}

	if (w->m_InputProcessor)
		w->m_InputProcessor->SetMouseScrollDelta(math::vec2(xoffset, yoffset));
}

//-------------------------------------------------------------------------------------------------

unsigned Window::GetRefreshRate() const {
	auto monitor = glfwGetWindowMonitor(m_Window);
	if (!monitor)
		monitor = glfwGetPrimaryMonitor();
	return glfwGetVideoMode(monitor)->refreshRate;
}

//-------------------------------------------------------------------------------------------------

void Window::EnterCharMode() {
	m_CharMode = true;
	glfwSetCharCallback(m_Window, GLFWCharModeCharCallback);
	glfwSetKeyCallback(m_Window, GLFWCharModeKeyCallback);
}

void Window::ExitCharMode() {
	m_CharMode = false;
	glfwSetCharCallback(m_Window, nullptr);
	glfwSetKeyCallback(m_Window, glfw_key_callback);
}

} //namespace Graphic 
