/*
  * Generated by cppsrc.sh
  * On 2016-09-18 19:00:53,20
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>
#include "../nfGUI.h"

#include <Core/Component/ComponentManager.h>
#include <Core/Component/ComponentRegister.h>
#include "RectTransformComponent.h"
#include "ImageComponent.h"

#include <Renderer/RenderInput.h>

#include <Math.x2c.h>
#include <ComponentCommon.x2c.h>
#include <ImageComponent.x2c.h>

namespace MoonGlare {
namespace GUI {
namespace Component {

::Space::RTTI::TypeInfoInitializer<ImageComponent, ImageComponentEntry> ImageComponentTypeInfo;
RegisterComponentID<ImageComponent> ImageComponentIDReg("Image", true, &ImageComponent::RegisterScriptApi);

//---------------------------------------------------------------------------------------

ImageComponent::ImageComponent(ComponentManager *Owner) 
		: TemplateStandardComponent(Owner)
{
	m_RectTransform = nullptr;
}

ImageComponent::~ImageComponent() {
}

//---------------------------------------------------------------------------------------

void ImageComponent::RegisterScriptApi(ApiInitializer & root) {
}

//---------------------------------------------------------------------------------------

bool ImageComponent::Initialize() {
	//memset(&m_Array, 0, m_Array.Capacity() * sizeof(m_Array[0]));
	m_Array.fill(ImageComponentEntry());
	m_Array.ClearAllocation();

	m_RectTransform = GetManager()->GetComponent<RectTransformComponent>();
	if (!m_RectTransform) {
		AddLog(Error, "Failed to get RectTransformComponent instance!");
		return false;
	}

	return true;
}

bool ImageComponent::Finalize() {
	return true;
}

//---------------------------------------------------------------------------------------

void ImageComponent::Step(const Core::MoveConfig & conf) {
	auto *EntityManager = GetManager()->GetWorld()->GetEntityManager();

//	conf.CustomDraw.push_back(this);

	size_t LastInvalidEntry = 0;
	size_t InvalidEntryCount = 0;

	for (size_t i = 0; i < m_Array.Allocated(); ++i) {//ignore root entry
		auto &item = m_Array[i];

		if (!item.m_Flags.m_Map.m_Valid) {
			//mark and continue
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}

		const auto *rtentry = m_RectTransform->GetEntry(item.m_OwnerEntity);
		if (!rtentry) {
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}

		item.Update(conf.TimeDelta);
		
		if (!item.m_Animation || !item.m_Flags.m_Map.m_Visible)
			continue;

		conf.m_RenderInput->m_D2AnimRenderList.emplace_back();
		auto &render = conf.m_RenderInput->m_D2AnimRenderList.back();

		render.m_Matrix = rtentry->m_GlobalMatrix;
		render.m_Animation = item.m_Animation;
		render.m_Frame = static_cast<unsigned>(item.m_Position);
	}

	if (InvalidEntryCount > 0) {
		AddLogf(Performance, "TransformComponent:%p InvalidEntryCount:%lu LastInvalidEntry:%lu", this, InvalidEntryCount, LastInvalidEntry);
		TrivialReleaseElement(LastInvalidEntry);
	}
}

//---------------------------------------------------------------------------------------

bool ImageComponent::Load(xml_node node, Entity Owner, Handle & hout) {
	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}
	auto &entry = m_Array[index];
	entry.m_Flags.ClearAll();
	if (!GetHandleTable()->Allocate(this, Owner, entry.m_SelfHandle, index)) {
		AddLog(Error, "Failed to allocate handle");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}
	hout = entry.m_SelfHandle;
	entry.m_OwnerEntity = Owner;


	x2c::Component::ImageComponent::ImageEntry_t ie;
	ie.ResetToDefault();
	if (!ie.Read(node)) {
		AddLog(Error, "Failed to read ImageEntry!");
		return false;
	}

	entry.m_Animation = std::make_shared<Animation>();
	entry.m_Speed = ie.m_Speed;
	entry.m_Position = 0.0f;
	entry.m_FrameCount = ie.m_FrameCount;
	entry.m_Flags.m_Map.m_Visible = ie.m_Visible;

	entry.m_Animation->Load(ie.m_TextureURI, ie.m_StartFrame, ie.m_FrameCount, ie.m_FrameStripCount, ie.m_Spacing, ie.m_FrameSize, m_RectTransform->IsUniformMode());

	entry.m_Flags.m_Map.m_Valid = true;
	m_EntityMapper.SetComponentMapping(entry);
	return true;
}

//---------------------------------------------------------------------------------------

} //namespace Component 
} //namespace GUI 
} //namespace MoonGlare 
