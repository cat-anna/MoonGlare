/*
  * Generated by cppsrc.sh
  * On 2016-09-18 19:00:53,20
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>
#include "../nfGUI.h"

#include <Core/Component/ComponentManager.h>
#include <Core/Component/ComponentRegister.h>
#include "RectTransformComponent.h"
#include "PanelComponent.h"

#include <Renderer/Commands/ControllCommands.h>
#include <Renderer/Commands/ShaderCommands.h>
#include <Renderer/Commands/TextureCommands.h>
#include <Renderer/Commands/ArrayCommands.h>
#include <Renderer/RenderInput.h>

#include <Math.x2c.h>
#include <ComponentCommon.x2c.h>
#include <RectTransformComponent.x2c.h>
#include <PanelComponent.x2c.h>

namespace MoonGlare {
namespace GUI {
namespace Component {

//---------------------------------------------------------------------------------------

struct PanelShader : public ::Graphic::Shader {
	PanelShader(GLuint ShaderProgram, const std::string &ProgramName) : ::Graphic::Shader(ShaderProgram, ProgramName) {
		m_BaseColorLocation		= Location("gBaseColor");
		m_PanelAspectLocation   = Location("gPanelAspect");
		m_PanelSizeLocation	    = Location("gPanelSize");
		m_PanelBorderLocation   = Location("gPanelBorder");
		m_TileModeLocation	    = Location("gTileMode");
	}

	GLint m_BaseColorLocation;
	GLint m_PanelAspectLocation;
	GLint m_PanelSizeLocation;
	GLint m_PanelBorderLocation;
	GLint m_TileModeLocation;

	void Bind(Renderer::CommandQueue &Queue) {
		Queue.PushCommand<Renderer::Commands::ShaderBind>()->m_Shader = Handle();
	}
	void SetModelMatrix(Renderer::CommandQueue &Queue, const glm::mat4 & mat) {
		auto loc = Location(ShaderParameters::ModelMatrix);
		if (!IsValidLocation(loc))
			return;

		auto arg = Queue.PushCommand<Renderer::Commands::ShaderSetUniformMatrix4>();
		arg->m_Location = loc;
		arg->m_Matrix = mat;
	}

	void SetWorldMatrix(Renderer::CommandQueue &Queue, const glm::mat4 & ModelMat, const glm::mat4 &CameraMat) {
		auto loc = Location(ShaderParameters::WorldMatrix);
		if (!IsValidLocation(loc))
			return;

		auto arg = Queue.PushCommand<Renderer::Commands::ShaderSetUniformMatrix4>();
		arg->m_Location = loc;
		arg->m_Matrix = CameraMat * ModelMat;
	}
	void SetColor(Renderer::CommandQueue &Queue, const math::vec4 &color) {
		auto loc = Location("gBaseColor");
		if (!IsValidLocation(loc))
			return;

		auto arg = Queue.PushCommand<Renderer::Commands::ShaderSetUniformVec4>();
		arg->m_Location = loc;
		arg->m_Vec = color;
	}

	void SetPanelSize(Renderer::CommandQueue &Queue, const Point &Size) {
		if (IsValidLocation(m_PanelAspectLocation)) {
			auto arg = Queue.PushCommand<Renderer::Commands::ShaderSetUniformFloat>();
			arg->m_Location = m_PanelAspectLocation;
			arg->m_Float = Size[0] / Size[1];
		}

		if (IsValidLocation(m_PanelSizeLocation)) {
			auto arg = Queue.PushCommand<Renderer::Commands::ShaderSetUniformVec2>();
			arg->m_Location = m_PanelSizeLocation;
			*((Point*)(&arg->m_Vec)) = Size;
		}
	}
	void SetBorder(Renderer::CommandQueue &Queue, float Border) {
		if (IsValidLocation(m_PanelBorderLocation)) {
			auto arg = Queue.PushCommand<Renderer::Commands::ShaderSetUniformFloat>();
			arg->m_Location = m_PanelBorderLocation;
			arg->m_Float = Border;
		}
	}
	void SetTileMode(Renderer::CommandQueue &Queue, const glm::ivec2 &mode) {
		if (IsValidLocation(m_TileModeLocation)) {
			auto arg = Queue.PushCommand<Renderer::Commands::ShaderSetUniformIVec2>();
			arg->m_Location = m_TileModeLocation;
			*((glm::ivec2*)(&arg->m_Vec)) = mode;
		}
	}

	void TextureBind(Renderer::CommandQueue &Queue, Renderer::TextureHandle handle) {
		Queue.PushCommand<Renderer::Commands::Texture2DBind>()->m_Texture = handle;
	}

	void VAOBind(Renderer::CommandQueue &Queue, Renderer::VAOHandle handle) {
		Queue.PushCommand<Renderer::Commands::VAOBind>()->m_VAO = handle;
	}
	void VAORelease(Renderer::CommandQueue &Queue) {
		Queue.PushCommand<Renderer::Commands::VAORelease>();
	}

	void Enable(Renderer::CommandQueue &Queue, GLenum what) {
		Queue.PushCommand<Renderer::Commands::Enable>()->m_What = what;
	}
	void Disable(Renderer::CommandQueue &Queue, GLenum what) {
		Queue.PushCommand<Renderer::Commands::Disable>()->m_What = what;
	}
};

//---------------------------------------------------------------------------------------

::Space::RTTI::TypeInfoInitializer<PanelComponent, PanelComponentEntry> PanelComponentTypeInfo;
RegisterComponentID<PanelComponent> PanelComponentIDReg("Panel", true, &PanelComponent::RegisterScriptApi);

//---------------------------------------------------------------------------------------

PanelComponent::PanelComponent(ComponentManager *Owner) 
		: TemplateStandardComponent(Owner)
{
	m_RectTransform = nullptr;
	m_Shader = nullptr;
}

PanelComponent::~PanelComponent() {
}

//---------------------------------------------------------------------------------------

void PanelComponent::RegisterScriptApi(ApiInitializer & root) {
}

//---------------------------------------------------------------------------------------

bool PanelComponent::Initialize() {
	//memset(&m_Array, 0, m_Array.Capacity() * sizeof(m_Array[0]));
//	m_Array.fill(PanelComponentEntry());
	m_Array.ClearAllocation();

	m_RectTransform = GetManager()->GetComponent<RectTransformComponent>();
	if (!m_RectTransform) {
		AddLog(Error, "Failed to get RectTransformComponent instance!");
		return false;
	}

	return true;
}

bool PanelComponent::Finalize() {
	return true;
}

//---------------------------------------------------------------------------------------

void PanelComponent::Step(const Core::MoveConfig & conf) {
	size_t LastInvalidEntry = 0;
	size_t InvalidEntryCount = 0;

	auto &Queue = conf.m_RenderInput->m_CommandQueues[(size_t)Renderer::CommandQueueID::GUI];
	auto QueueSavePoint = Queue.GetSavePoint();
	bool QueueDirty = false;
	bool CanRender = false;

	if (!m_Shader) {
		if (!Graphic::GetShaderMgr()->GetSpecialShaderType<PanelShader>("GUI.Panel", m_Shader)) {
			AddLogf(Error, "Failed to load GUI.Panel shader");
			return;
		}
	}

	if (m_Shader) {
		m_Shader->Bind(Queue);
		
		m_Shader->Enable(Queue, GL_BLEND);
		m_Shader->Disable(Queue, GL_CULL_FACE);

		CanRender = true;
	}

	for (size_t i = 0; i < m_Array.Allocated(); ++i) {
		auto &item = m_Array[i];

		if (!item.m_Flags.m_Map.m_Valid) {
			//mark and continue
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}

		auto *rtentry = m_RectTransform->GetEntry(item.m_OwnerEntity);
		if (!rtentry) {
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}

		if (item.m_TransformRevision == rtentry->m_Revision && !item.m_Flags.m_Map.m_Dirty) {
		} else {

			item.m_Flags.m_Map.m_Dirty = false;
			item.m_TransformRevision = rtentry->m_Revision;

			auto size = rtentry->m_ScreenRect.GetSize();

			Graphic::VertexVector Vertexes{
				Graphic::vec3(0, size[1], 0),
				Graphic::vec3(size[0], size[1], 0),
				Graphic::vec3(size[0], 0, 0),
				Graphic::vec3(0, 0, 0),
			};
			Graphic::NormalVector Normals;
			float w1 = 0.0f;
			float h1 = 0.0f;
			float w2 = w1 + 1.0f;
			float h2 = h1 + 1.0f;
			Graphic::TexCoordVector TexUV;

			Graphic::IndexVector Index{ 0, 1, 2, 0, 2, 3, };
			item.m_VAO.DelayInit(Vertexes, TexUV, Normals, Index);
		}

		if (!CanRender)
			continue;

		//Graphic::GetRenderDevice()->Bind(m_Shader);
		m_Shader->SetWorldMatrix(Queue, rtentry->m_GlobalMatrix, m_RectTransform->GetCamera().GetProjectionMatrix());
		
		m_Shader->SetPanelSize(Queue, rtentry->m_ScreenRect.GetSize());
		m_Shader->SetBorder(Queue, item.m_Border);
		m_Shader->SetColor(Queue, item.m_Color);
		m_Shader->SetTileMode(Queue, item.m_TileMode);
		
		m_Shader->TextureBind(Queue, item.m_Texture->Handle());
		m_Shader->VAOBind(Queue, item.m_VAO.Handle());

		auto arg = Queue.PushCommand<Renderer::Commands::VAODrawTriangles>();
		arg->m_NumIndices = 6;
		arg->m_IndexValueType = GL_UNSIGNED_INT;

		QueueDirty = true;
	}

	if (!QueueDirty)
		Queue.Rollback(QueueSavePoint);
	else {
	//	m_Shader->VAORelease(Queue);
	}

	if (InvalidEntryCount > 0) {
		AddLogf(Performance, "TransformComponent:%p InvalidEntryCount:%lu LastInvalidEntry:%lu", this, InvalidEntryCount, LastInvalidEntry);
		TrivialReleaseElement(LastInvalidEntry);
	}
}

//---------------------------------------------------------------------------------------

bool PanelComponent::Load(xml_node node, Entity Owner, Handle & hout) {
	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}
	auto &entry = m_Array[index];
	entry.Reset();
	if (!GetHandleTable()->Allocate(this, Owner, entry.m_SelfHandle, index)) {
		AddLog(Error, "Failed to allocate handle");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}
	hout = entry.m_SelfHandle;
	entry.m_OwnerEntity = Owner;

	x2c::Component::PanelComponent::PanelEntry_t pe;
	pe.ResetToDefault();
	if (!pe.Read(node)) {
		AddLog(Error, "Failed to read ImageEntry!");
		return false;
	}

	auto *rtentry = m_RectTransform->GetEntry(entry.m_OwnerEntity);
	if (rtentry) {
	} else {
		//TODO:??
	}

	if (!GetFileSystem()->OpenTexture(entry.m_Texture, pe.m_TextureURI)) {
		AddLog(Error, "Unable to load texture file for panel!");
		return false;
	}
	
	entry.m_Border = pe.m_Border;
	entry.m_Color = pe.m_Color;
	entry.m_TileMode = pe.m_TileMode;

	entry.m_Flags.m_Map.m_Valid = true;
	entry.m_Flags.m_Map.m_Dirty = true;
	m_EntityMapper.SetComponentMapping(entry);
	return true;
}

//---------------------------------------------------------------------------------------

} //namespace Component 
} //namespace GUI 
} //namespace MoonGlare 
