/*
	Generated by cppsrc.sh
	On 2014-12-11 19:44:39,04
	by Paweu
*/

#pragma once
#ifndef Settings_H
#define Settings_H

enum class SettingsGroup {
	None,
//Master groups
	Window,
	Graphic,
	Sound,
	Engine,
	Localization,
	Input,
//Secondary groups
	Sound_Volume,
//Nongroups
	Debug,
	Modules,
};

class Settings_t {
public:
	static void GetStdModuleList(std::vector<string> &table);

	struct Modules_t {
		std::vector<string> List;

		template <class T> void Serialize(T & s) {
			s.ValueContainer(List, "List", ::Settings_t::GetStdModuleList);
		}
	} Modules;

	//dynamic configuration

	using ShadowQuality = Graphic::Settings::ShadowQuality;

	struct Graphic {
		ShadowQuality Shadows;
		template <class T> void Serialize(T & s) {
			s.Value(Shadows, "Shadows", ShadowQuality::Medium);
		}
	} Graphic;

	struct Localization {
		string Code;
		template <class T> void Serialize(T & s) {
			s.Value(Code, "Code", "en");
		}
	} Localization;

	struct Engine {
		bool EnableConsole;
		template <class T> void Serialize(T & s) {
			s.Value(EnableConsole, "EnableConsole", DEBUG_TRUE);
		}
	} Engine;

	template <class T> void Serialize(T & s) {
		s.Group(Modules, "Modules");
		s.Group(Graphic , "Graphic");
		s.Group(Localization , "Localization");
		s.Group(Engine , "Engine");
	}

	Settings_t* operator->() { return this; }

	//Static settings
	enum {
		JobQueueThreads			= 2,
	};

	struct FileSystem {
		enum {
			DataBuffer			= 10 * 1024 * 1024, //10MB

			PathReserve			= 128,
			DefaultLoadFlags	= 0,
		};
	};
	
	struct Scenes {
		static inline float GetSceneLoadTimeOut() { return 0.2f; }
	};

	struct DataManager {
		static const size_t MaxLoadableModules = 16;
	};

	struct ModulesManager {
		enum {
			ModuleReservedSpace		= 16,
		};
	};

	void Load();
	void Save();

	template<class T, class D>
	struct BaseSettingInfo {
		using Type = T;
		static void set(Type v) { _value = v; }
		static Type get() { return _value; }
	protected:
		static Type _value;
	};

	template<class D>
	struct BaseSettingInfo<std::string, D> {
		using Type = std::string;
		static void set(std::string v) { _value.swap(v); }
		static const std::string& get() { return _value; }
	protected:
		static std::string _value;
	};

	struct SettingManipulatorBase {
		virtual ~SettingManipulatorBase() { }
		virtual bool get(int *value) const { return false; }
		virtual bool get(bool *value) const { return false; }
		virtual bool get(float *value) const { return false; }
		virtual bool get(string *value) const { return false; }
		virtual int get(lua_State *lua) = 0;
		virtual int set(lua_State *lua, int stackpos) = 0;
		virtual bool save(xml_node node) const { return true; }
		virtual bool load(const xml_node node) { return true; }
		virtual void dump(std::ostream &out) const{ }
		virtual void reset() = 0;
		virtual void write() = 0;
		virtual void default() = 0;
	protected:
		template<class T, class U> static bool try_assign(T *t, U u) { return false; }
		static bool try_assign(int *t, int u) { *t = u;  return true; }
		static bool try_assign(bool *t, bool u) { *t = u;  return true; }
		static bool try_assign(float *t, float u) { *t = u;  return true; }
		static bool try_assign(string *t, const char *u) { *t = u;  return true; }
	};

	template < class CONFIG > 
	struct BufferedSettingManipulator : public SettingManipulatorBase {
		using Config = CONFIG;
		using Type = typename Config::Type;
		BufferedSettingManipulator() { m_Backup = m_Config.get(); }
		virtual bool get(int *value) const { return try_assign(value, m_Backup); }
		virtual bool get(bool *value) const { return try_assign(value, m_Backup); }
		virtual bool get(float *value) const { return try_assign(value, m_Backup); }
		virtual bool get(string *value) const { return try_assign(value, m_Backup); }
		virtual int get(lua_State *lua) override { Utils::Scripts::Lua_push(lua, m_Backup); return 1; }
		virtual int set(lua_State *lua, int stackpos) override { m_Backup = Utils::Scripts::Lua_to<Config::Type>(lua, stackpos); return 0; }
		virtual bool load(const xml_node node) override { m_Config.set(XML::Value::Read(node.text(), m_Config.get())); return true; }
		virtual bool save(xml_node node) const override { XML::Value::Write(node.text(), m_Config.get()); return true; }
		virtual void dump(std::ostream &out) const override { out << m_Config.get(); }
		virtual void reset() override { m_Config.set(m_Backup); }
		virtual void write() override { m_Config.set(m_Backup); }
		virtual void default() override { m_Backup = m_Config.default();  }
	private:
		Type m_Backup;
		Config m_Config;
	};

	template < class CONFIG > 
	struct DirectSettingManipulator : public SettingManipulatorBase {
		DirectSettingManipulator() { m_Original = m_Config.get(); }
		using Config = typename CONFIG;
		using Type = typename Config::Type;
		virtual bool get(int *value) const { return try_assign(value, m_Config.get()); }
		virtual bool get(bool *value) const { return try_assign(value, m_Config.get()); }
		virtual bool get(float *value) const { return try_assign(value, m_Config.get()); }
		virtual bool get(string *value) const { return try_assign(value, m_Config.get()); }
		virtual int get(lua_State *lua) override { Utils::Scripts::Lua_push(lua, m_Config.get()); return 1; }
		virtual int set(lua_State *lua, int stackpos) override { m_Config.set(Utils::Scripts::Lua_to<Config::Type>(lua, stackpos)); return 0; }
		virtual void dump(std::ostream &out) const override { out << m_Config.get(); }
 		virtual bool load(const xml_node node) override { m_Config.set(XML::Value::Read(node.text(), m_Config.get())); return true; }
		virtual bool save(xml_node node) const override { XML::Value::Write(node.text(), m_Config.get()); return true; }
		virtual void reset() override { m_Config.set(m_Original); }
		virtual void write() override { }
		virtual void default() override { m_Config.set(m_Config.default()); }
	private:
		Type m_Original;
		Config m_Config;
	};

	struct SettingsHandlerInfo {
		const char *Name;
		SettingsGroup NotifyGroup;
		using Constructor_t = std::unique_ptr<SettingManipulatorBase>(*)();
		Constructor_t Constructor;
	};

	void RegisterDynamicSetting(const SettingsHandlerInfo& handler, bool RequireRestart = false);
	template<class T>
	void RegisterDynamicSetting(const char *Name, bool RequireRestart = false, SettingsGroup Group = SettingsGroup::None) {
		struct V {
			static std::unique_ptr<SettingManipulatorBase> func() { return std::make_unique<T>(); }
		};
		SettingsHandlerInfo value{ Name, Group, &V::func };
		RegisterDynamicSetting(value, RequireRestart);
	}
	SettingManipulatorBase* FindSetting(const char *name);
	template <class T>
	bool GetSetting(const char *name, T &t) {
		auto *s = FindSetting(name);
		if (!s) return false;
		return s->get(&t);
	}

	~Settings_t();
	Settings_t();
protected:
};

template<class T, class D>
T Settings_t::BaseSettingInfo<T, D>::_value = D::default();

template<class D>
std::string Settings_t::BaseSettingInfo<std::string, D>::_value = D::default();

extern Settings_t Settings;
using StaticSettings = Settings_t;

#endif
