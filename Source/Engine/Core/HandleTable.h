/*
  * Generated by cppsrc.sh
  * On 2016-07-28 19:21:16,18
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef HandleTable_H
#define HandleTable_H

#include "EntityManager.h"

namespace MoonGlare {
namespace Core {

class HandleTable final 
	: public Config::Current::DebugMemoryInterface {
public:
 	HandleTable();
 	~HandleTable();

	bool Initialize(EntityManager *EntityManager);
	bool Finalize();

	using HandlePrivateData = uint64_t;

	bool IsValid(Handle h);
	bool Allocate(Handle &hout, uint16_t Type, HandleIndex index, HandlePrivateData value = 0);
	bool Allocate(Entity Owner, Handle &hout, uint16_t Type, HandleIndex index, HandlePrivateData value = 0);
	bool Release(Handle h);

	bool GetHandleParentEntity(Handle h, Entity &eout);

	//below function return false if handle or owner entity is not valid
	bool GetHandleIndex(Handle h, HandleIndex &index);
	bool SetHandleIndex(Handle h, HandleIndex index);

	bool GetHandleData(Handle h, HandlePrivateData &value);
	bool SetHandleData(Handle h, HandlePrivateData value);

	//template shortcut versions for components
	template<class COMPONENT>
	bool GetHandleIndex(COMPONENT *c, Handle h, HandleIndex &index) {
		if (h.GetType() != c->GetHandleType()) return false;
		return GetHandleIndex(h, index);
	}
	template<class COMPONENT>
	bool Allocate(COMPONENT *c, Entity Owner, Handle &hout, HandleIndex index, HandlePrivateData value = 0) {
		return Allocate(Owner, hout, c->GetHandleType(), index, value);
	}

	template<class COMPONENT>
	bool IsValid(COMPONENT *c, Handle h) {
		if (h.GetType() != c->GetHandleType()) return false;
	return IsValid(h);
}

	union HandleFlags {
		struct {
			bool m_HasEntityOwner;
		} m_Map;
		uint8_t m_UIntValue;
	};

	struct HandleEntry {
		Entity m_Owner;
		uint16_t m_Type;
		HandleFlags m_Flags;
		HandlePrivateData m_Data;
	};

	static_assert(sizeof(HandleEntry) == 16, "HandleEntry has invalid size!");
protected:
	template<class ... ARGS>
	using GenerationsAllocator_t = Space::Memory::StaticMultiAllocator<Configuration::Handle::IndexLimit, ARGS...>;
	using Generations_t = Space::Memory::GenerationRandomBuffer<GenerationsAllocator_t, Handle>;
	template<class T> using Array = std::array<T, Configuration::Handle::IndexLimit>;

	Array<HandleEntry> m_Array;
	Generations_t m_Allocator;
	EntityManager *m_EntityManager;
};

} //namespace Core 
} //namespace MoonGlare 

#endif
