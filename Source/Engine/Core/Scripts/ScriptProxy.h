/*
  * Generated by cppsrc.sh
  * On 2015-03-24 17:52:31,03
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef ScriptProxy_H
#define ScriptProxy_H

namespace Core {
namespace Scripts {

class ScriptProxy : public cRootClass {
	SPACERTTI_DECLARE_STATIC_CLASS(ScriptProxy, cRootClass);
public:
 	ScriptProxy();
 	~ScriptProxy();

	static bool RequestInstance() {
		LOCK_MUTEX(_Instance->m_Mutex);
		return EnsureScriptInstance();
	}

	template<class RET, class ... Types>
	static RET RunFunction(const char *FuncName, Types ... args) {
		LOCK_MUTEX(_Instance->m_Mutex);
		if (!EnsureScriptInstance())
			return 0;
		//AddLog(Hint, "Script function call is not yet implemented! (" << FuncName << ")");
		return _Instance->m_Script->RunFunction<RET>(FuncName, std::forward<Types>(args)...);
	}

	static int ExecuteCode(const string& code, const char *CodeName = nullptr) {
		LOCK_MUTEX(_Instance->m_Mutex);
		if (!EnsureScriptInstance())
			return 0;
		return _Instance->m_Script->LoadCode(code.c_str(), code.length(), CodeName);
	}

	static int ExecuteCode(const char *code, unsigned len, const char *CodeName = nullptr) {
		LOCK_MUTEX(_Instance->m_Mutex);
		if (!EnsureScriptInstance())
			return 0;
		return _Instance->m_Script->LoadCode(code, len, CodeName);
	}

	UniqueScript DropScriptOwnership() {
		LOCK_MUTEX(_Instance->m_Mutex);
		AddLogf(Debug, "Thread %s is dropping script ownership!", m_ThreadSignature);
		return std::move(m_Script);
	}
	const char* GetThreadSignature() const { return m_ThreadSignature; }

	static ScriptProxy* CurrentInstance() { return _Instance; }
	static bool IsMain() { return _Instance->m_IsMainContext; }
protected:
	static bool EnsureScriptInstance() {
		if (!_Instance) {
			AddLog(Error, "Thread does not have initialzed script proxy. Scripts cannot be executed");
			return false;
		}
		if (!_Instance->m_Script && !_Instance->RunTimeInitialze()) {
			AddLog(Warning, "An error has occur during script proxy runtime initialization");
			return false;
		}
		return true;
	}

	bool RunTimeInitialze();

	UniqueScript m_Script;
	char m_ThreadSignature[8];
	bool m_IsMainContext;
	std::recursive_mutex m_Mutex;
	__declspec(thread) static ScriptProxy *_Instance;
};

#if !defined(_USE_API_GENERATOR_) && !defined(_DISABLE_SCRIPT_ENGINE_) && defined(_BUILDING_ENGINE_)

#define EnableScriptsInThisThread()\
	auto __ScriptProxy = std::make_unique<::Core::Scripts::ScriptProxy>();

#else

#define EnableScriptsInThisThread(...) do { /*  NOP */ } while(false)

#endif

} //namespace Scripts 
} //namespace Core 

#endif
