/*
  * Generated by cppsrc.sh
  * On 2016-07-23 16:55:00,64
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>

#include <Core/Component/AbstractComponent.h>
#include "ScriptComponent.h"
#include <Core/Component/ComponentManager.h>
#include <Core/Component/ComponentRegister.h>
#include <Core/EntityBuilder.h>

#include <Core/Component/TransformComponent.h>

#include <ScriptComponent.x2c.h>

namespace MoonGlare::Core::Scripts::Component {

//static_assert(sizeof(void*) == sizeof(Handle), "Size of void* must match the size of Handle!");

namespace lua {
    enum {
        SelfPtrUpValue = 1,
        HandleUpValue,
    };

    static const char *Function_Step = "Step";
    static const char *Function_OnCreate = "OnCreate";
    static const char *Function_OnDestroy = "OnDestroy";
    static const char *Function_PerSecond = "PerSecond";

    static const char *EntityMemberName = "Entity";
    static const char *HandleMemberName = "Handle";
    static const char *ComponentIDMemberName = "ComponentId";
    static const char *DereferenceHandleName = "Get";
    static const char *ComponentSetStateName = "Set";
    static const char *ComponentName = "Component";
    static const char *ComponentInstanceName = "ComponentInstance";

    static const char *GameObjectName = "GameObject";

    static const char *GetComponentName = "GetComponent";
    static const char *CreateComponentName = "CreateComponent";
    static const char *SpawnChildName = "SpawnChild";
    static const char *SpawnName = "Spawn";
    static const char *DestroyObjectName = "DestroyObject";      
    static const char *DestroyName = "Destroy";
    static const char *GetName = "GetName";
    static const char *SetName = "SetName";
    static const char *FindChild = "FindChild";
    static const char *GetParent = "GetParent";
    static const char *GetFirstChild = "GetFirstChild";
    static const char *GetGameObject = "GetObject";
    
    static const char *SetPerSecond = "SetPerSecond";
    static const char *SetStep = "SetStep";
    static const char *SetActive = "SetActive";
}				    

::Space::RTTI::TypeInfoInitializer<ScriptComponent, ScriptComponent::ScriptEntry> ScriptComponentTypeInfo;
RegisterComponentID<ScriptComponent> ScriptComponent("Script", true);

ScriptComponent::ScriptComponent(ComponentManager *Owner)
    : AbstractComponent(Owner) {

    DebugMemorySetClassName("ScriptComponent");
    DebugMemoryRegisterCounter("IndexUsage", [this](DebugMemoryCounter& counter) {
        counter.Allocated = m_Array.Allocated();
        counter.Capacity = m_Array.Capacity();
        counter.ElementSize = sizeof(ScriptEntry);
    });
}

ScriptComponent::~ScriptComponent() {
}

bool ScriptComponent::Initialize() {
    m_ScriptEngine = GetManager()->GetWorld()->GetScriptEngine();
    THROW_ASSERT(m_ScriptEngine, "No script engine instance!");

    m_Array.MemZeroAndClear();

    auto lua = m_ScriptEngine->GetLua();
    LOCK_MUTEX_NAMED(m_ScriptEngine->GetLuaMutex(), lock);

    Utils::Scripts::LuaStackOverflowAssert check(lua);

    lua_pushlightuserdata(lua, GetInstancesTableIndex());									 //stack: InstTblIdx
    lua_createtable(lua, m_Array.Capacity(), 0);											 //stack: InstTblIdx InstTbl
    Scripts::PublishSelfLuaTable(lua, "ScriptComponent", this, -1);							 //stack: InstTblIdx InstTbl
    lua_settable(lua, LUA_REGISTRYINDEX);													 //stack: -

    lua_pushlightuserdata(lua, GetObjectRootTableIndex());									 //stack: Index  
    lua_createtable(lua, 0, 0);																 //stack: Index ORTable
    Scripts::PublishSelfLuaTable(lua, "ScriptComponent_OR", this, -1);						 //stack: Index ORTable
    lua_settable(lua, LUA_REGISTRYINDEX);													 //stack: -

    if (!InitGameObjectMetaTable(lua)) {
        AddLogf(Error, "Failed to initialize GameObject MT!");
        return false;
    }

    requireModule = m_ScriptEngine->QuerryModule<iRequireModule>();
    if (!requireModule) {
        AddLogf(Error, "QuerryModule<iRequireModule> failed!");
        return false;
    }

    return true;
}

bool ScriptComponent::Finalize() {
    auto lua = m_ScriptEngine->GetLua();
    LOCK_MUTEX_NAMED(m_ScriptEngine->GetLuaMutex(), lock);
    MoonGlare::Core::Scripts::HideSelfLuaTable(lua, "ScriptComponent", this);
    lua_pushlightuserdata(lua, (void *)this);
    lua_pushnil(lua);
    lua_settable(lua, LUA_REGISTRYINDEX);
    return true;
}

bool ScriptComponent::InitGameObjectMetaTable(lua_State *lua) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);

    lua_createtable(lua, 0, 0);																 //stack: GameObjectMT
    Scripts::PublishSelfLuaTable(lua, "ScriptComponent_GameObjectMT", this, -1);			 //stack: GameObjectMT
    lua_pushlightuserdata(lua, GetGameObjectMetaTableIndex());								 //stack: GameObjectMT Index 
    lua_pushvalue(lua, -2);																	 //stack: GameObjectMT Index GameObjectMT
    lua_settable(lua, LUA_REGISTRYINDEX);													 //stack: GameObjectMT

    lua_createtable(lua, 0, 0);																 //stack: GameObjectMT GameObjectMT_index
    lua_pushvalue(lua, -1);																	 //stack: GameObjectMT GameObjectMT_index GameObjectMT_index
    lua_setfield(lua, -3, "__index");														 //stack: GameObjectMT GameObjectMT_index

    lua_pushlightuserdata(lua, this);														 //stack: GameObjectMT GameObjectMT_index this
    lua_pushcclosure(lua, &lua_CreateComponent, 1);											 //stack: GameObjectMT GameObjectMT_index this lua_CreateComponent
    lua_setfield(lua, -2, lua::CreateComponentName);										 //stack: GameObjectMT GameObjectMT_index 

    lua_pushlightuserdata(lua, this);														 //stack: GameObjectMT GameObjectMT_index Manager
    lua_pushcclosure(lua, &lua_SpawnChild, 1);												 //stack: GameObjectMT GameObjectMT_index Manager lua_SpawnChild
    lua_setfield(lua, -2, lua::SpawnChildName);												 //stack: GameObjectMT GameObjectMT_index 

    lua_pushlightuserdata(lua, this);														 //stack: GameObjectMT GameObjectMT_index Manager
    lua_pushcclosure(lua, &lua_Spawn, 1);												     //stack: GameObjectMT GameObjectMT_index Manager lua_Spawn
    lua_setfield(lua, -2, lua::SpawnName);												     //stack: GameObjectMT GameObjectMT_index 

    lua_pushlightuserdata(lua, GetManager());												 //stack: GameObjectMT GameObjectMT_index Manager
    lua_pushcclosure(lua, &lua_DestroyObject, 1);											 //stack: GameObjectMT GameObjectMT_index Manager lua_DestroyObject
    lua_setfield(lua, -2, lua::DestroyObjectName);											 //stack: GameObjectMT GameObjectMT_index 

    lua_pushlightuserdata(lua, GetManager()->GetWorld());									 //stack: GameObjectMT GameObjectMT_index Manager
    lua_pushcclosure(lua, &lua_SetName, 1);													 //stack: GameObjectMT GameObjectMT_index Manager lua_SetName
    lua_setfield(lua, -2, lua::SetName);													 //stack: GameObjectMT GameObjectMT_index 

    lua_pushlightuserdata(lua, GetManager()->GetWorld());									 //stack: GameObjectMT GameObjectMT_index Manager
    lua_pushcclosure(lua, &lua_GetName, 1);													 //stack: GameObjectMT GameObjectMT_index Manager lua_GetName
    lua_setfield(lua, -2, lua::GetName);													 //stack: GameObjectMT GameObjectMT_index 

    lua_pushlightuserdata(lua, this);														 //stack: GameObjectMT GameObjectMT_index this
    lua_pushcclosure(lua, &lua_FindChild, 1);												 //stack: GameObjectMT GameObjectMT_index this lua_FindChild
    lua_setfield(lua, -2, lua::FindChild);													 //stack: GameObjectMT GameObjectMT_index

    lua_pushlightuserdata(lua, this);														 //stack: GameObjectMT GameObjectMT_index this
    lua_pushcclosure(lua, &lua_GetParent, 1);												 //stack: GameObjectMT GameObjectMT_index this lua_GetParent
    lua_setfield(lua, -2, lua::GetParent);													 //stack: GameObjectMT GameObjectMT_index

    lua_pushlightuserdata(lua, this);														 //stack: GameObjectMT GameObjectMT_index this
    lua_pushcclosure(lua, &lua_GetFirstChild, 1);											 //stack: GameObjectMT GameObjectMT_index this lua_GetFirstChild
    lua_setfield(lua, -2, lua::GetFirstChild);												 //stack: GameObjectMT GameObjectMT_index

    lua_pushlightuserdata(lua, this);														 //stack: GameObjectMT GameObjectMT_index this
    lua_pushcclosure(lua, &lua_GetGameObject, 1);											 //stack: GameObjectMT GameObjectMT_index this lua_GetFirstChild
    lua_setfield(lua, -2, lua::GetGameObject);												 //stack: GameObjectMT GameObjectMT_index

    Utils::Scripts::lua_PushCClosure(lua, &lua_Destroy, (void*)GetManager()->GetWorld());	 //stack: GameObjectMT GameObjectMT_index closure
    lua_setfield(lua, -2, lua::DestroyName);												 //stack: GameObjectMT GameObjectMT_index 

    Utils::Scripts::lua_PushCClosure(lua, &lua_GameObjectGetComponent, (void*)this);		 //stack: GameObjectMT GameObjectMT_index closure
    lua_setfield(lua, -2, lua::GetComponentName);											 //stack: GameObjectMT GameObjectMT_index 

    lua_pop(lua, 2);																		 //stack: -

    return true;
}

//-------------------------------------------------------------------------------------------------

void ScriptComponent::Step(const MoveConfig & conf) {
    if (m_Array.empty()) {
        return;
    }

    auto lua = m_ScriptEngine->GetLua();
    LOCK_MUTEX_NAMED(m_ScriptEngine->GetLuaMutex(), lock);
    Utils::Scripts::LuaStackOverflowAssert check(lua);
    //stack: -		

    lua_pushcclosure(lua, Core::Scripts::LuaErrorHandler, 0);
    int errf = lua_gettop(lua);

    GetInstancesTable(lua);									//stack: self
    luabridge::Stack<const MoveConfig*>::push(lua, &conf);  //stack: self movedata

    size_t LastInvalidEntry = 0;
    size_t InvalidEntryCount = 0;

    int luatop = lua_gettop(lua);

    for (size_t i = 0; i < m_Array.Allocated(); ++i) {
        auto &item = m_Array[i];
        if (!item.m_Flags.m_Map.m_Valid) {
            //mark and ignore
            LastInvalidEntry = i;
            ++InvalidEntryCount;
            continue;
        }

        if (!GetHandleTable()->IsValid(this, item.m_SelfHandle)) {
            item.m_Flags.m_Map.m_Valid = false;
            LastInvalidEntry = i;
            ++InvalidEntryCount;
            continue;
        }

        if (!item.m_Flags.m_Map.m_Active) 
            continue; // entry is not active. nothing todo.
        
        if (!((item.m_Flags.m_Map.m_OnPerSecond && conf.m_SecondPeriod) || item.m_Flags.m_Map.m_Step))
            continue; // there is no function which can be called. nothing todo.

        lua_rawgeti(lua, -2, i + 1);		//stack: self movedata Script/nil

        if (!lua_istable(lua, -1)) {
            lua_settop(lua, luatop);
            AddLogf(Error, "ScriptComponent: nil in lua script table at index: %d", i + 1);
            continue;
        }

        int luascrtop = lua_gettop(lua);
            
        if (item.m_Flags.m_Map.m_Step) {
            lua_pushvalue(lua, -1);								// stack: self movedata script script
            lua_getfield(lua, -1, lua::Function_Step);			//stack: self movedata script script Step/nil
            if (lua_isnil(lua, -1)) {
                item.m_Flags.m_Map.m_Step = false;
                AddLogf(Warning, "ScriptComponent: There is no Step function in component at index: %d, disabling", i);
            } else {
                //stack: self movedata script script Step
                lua_insert(lua, -2);							//stack: self movedata script Step script
                lua_pushvalue(lua, -4);							//stack: self movedata script Step script movedata

                if (!LuaSafeCall(lua, 2, 0, lua::Function_Step, errf)) {
                    AddLogf(Error, "Failure during OnStep call for component #%lu", i);
                }
            }
        }

        if (item.m_Flags.m_Map.m_OnPerSecond && conf.m_SecondPeriod) {
            lua_settop(lua, luascrtop);							//stack: self movedata script 
            lua_pushvalue(lua, -1);								//stack: self movedata script script
            lua_getfield(lua, -1, lua::Function_PerSecond);		//stack: self movedata script script persec/nil
            if (lua_isnil(lua, -1)) {
                item.m_Flags.m_Map.m_OnPerSecond = false;
                AddLogf(Warning, "ScriptComponent: There is no PerSecond function in component at index: %d, disabling", i);
            } else {
                //stack: self movedata script script persec
                lua_insert(lua, -2);						//stack: self movedata script persec script 
                if (!LuaSafeCall(lua, 1, 0, lua::Function_Step, errf)) {
                    AddLogf(Error, "Failure during PerSecond call for component #%lu", i);
                }
            }
        }

        lua_settop(lua, luatop);
    }

    lua_pop(lua, 3); //stack: -

    if (InvalidEntryCount > 0) {
        AddLogf(Performance, "ScriptComponent:%p InvalidEntryCount:%lu LastInvalidEntry:%lu", this, InvalidEntryCount, LastInvalidEntry);
        ReleaseComponent(lua, LastInvalidEntry);
    }
}

void ScriptComponent::ReleaseComponent(lua_State *lua, size_t Index) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);

    auto lastidx = m_Array.Allocated() - 1;
    auto LuaIndex = Index + 1;				//lua index
    auto LuaLast = m_Array.Allocated();		//lua index
        
    GetInstancesTable(lua);						//stack: ScriptComponentInstances

    lua_pushinteger(lua, LuaIndex);				//stack: ScriptComponentInstances LuaIndex
    lua_gettable(lua, -2);						//stack: ScriptComponentInstances current_table

    lua_rawgeti(lua, -1, 1);					//stack: ScriptComponentInstances current_table script@1/nil
    if (lua_isnil(lua, -1)) {
        AddLogf(Error, "ScriptComponent: nil in lua Object script table at index: 1");
    } else {
        lua_getfield(lua, -1, lua::Function_OnDestroy); //stack: self current_table script@1 OnDestroy/nil
        if (lua_isnil(lua, -1)) {
            lua_pop(lua, 1);
        } else {
            lua_pushvalue(lua, -2);				//stack: self current_table script@1 OnDestroy script@1
            if (!LuaSafeCall(lua, 1, 0, lua::Function_OnDestroy)) { //stack: self current_table script@1
                //	nothing there, nothing more to be logged
            }
        }
    }
    lua_pop(lua, 1);							//stack: ScriptComponentInstances current_table

    ScriptEntry *entry;
    if (lastidx == Index) {
        entry = &m_Array[lastidx];
    } else {
        auto &last = m_Array[lastidx];
        auto &item = m_Array[Index];
        entry = &last;

        std::swap(last, item);

        //set last in place of current and nil last
        lua_pushinteger(lua, LuaLast);			//stack: ScriptComponentInstances current_table LuaLast
        lua_gettable(lua, -3);					//stack: ScriptComponentInstances current_table last_table
        lua_pushinteger(lua, LuaIndex);			//stack: ScriptComponentInstances current_table last_table current_id
        lua_insert(lua, -2);					//stack: ScriptComponentInstances current_table LuaIndex last_table 
        lua_settable(lua, -4);					//stack: ScriptComponentInstances current_table 

        if (!GetHandleTable()->SetHandleIndex(this, item.m_SelfHandle, Index)) {
            AddLogf(Error, "Failed to move ScriptComponent handle index!");
        }
    }

    //set last in place of current and nil last
    lua_pushinteger(lua, LuaLast);			//stack: ScriptComponentInstances current_table LuaLast
    lua_pushnil(lua);						//stack: ScriptComponentInstances current_table LuaLast nil
    lua_settable(lua, -4);					//stack: ScriptComponentInstances current_table 

    lua_pop(lua, 2); //stack: -

    entry->Reset();
    GetHandleTable()->Release(this, entry->m_SelfHandle); // handle may be already released; no need to check for failure
    m_Array.DeallocateLast();
}

ScriptComponent::ScriptEntry *ScriptComponent::GetEntry(Handle h) {
    auto *ht = GetHandleTable();
    HandleIndex hi;
    if (!ht->GetHandleIndex(this, h, hi)) {
        return nullptr;
    }
    return &m_Array[hi];
}

//-------------------------------------------------------------------------------------------------

bool ScriptComponent::Load(xml_node node, Entity Owner, Handle &hout) {
    Handle &ch = hout;
    size_t index;
    if (!m_Array.Allocate(index)) {
        AddLogf(Error, "Failed to allocate index!");
        return false;
    }

    auto &entry = m_Array[index];
    entry.m_Flags.ClearAll();

    if (!GetHandleTable()->Allocate(this, Owner, ch, index)) {
        AddLogf(Error, "Failed to allocate handle!");
        //no need to deallocate entry. It will be handled by internal garbage collecting mechanism
        return false;
    }

    x2c::Component::ScriptComponent::ScriptEntry_t se;
    se.ResetToDefault();
    if (!se.Read(node)) {
        AddLog(Error, "Failed to read ScriptEntry!");
        return false;
    }

    auto lua = m_ScriptEngine->GetLua();
    LOCK_MUTEX_NAMED(m_ScriptEngine->GetLuaMutex(), lock);
    Utils::Scripts::LuaStackOverflowAssert check(lua);

    int top = lua_gettop(lua);
    //stack: -

    lua_pushcclosure(lua, Core::Scripts::LuaErrorHandler, 0);
    int errf = lua_gettop(lua);

    if (se.m_Script[0] == '/') {
        if (!requireModule->Querry(lua, se.m_Script)) {
            AddLogf(Error, "There is no such script: '%s'", se.m_Script.c_str());
            GetHandleTable()->Release(this, ch);
            //no need to deallocate entry. It will be handled by internal garbage collecting mechanism
            return false;
        }
    } else {
        AddLogf(Error, "There is no such script: '%s'", se.m_Script.c_str());
        GetHandleTable()->Release(this, ch);
        return false;
    }

    //stack: ScriptClass

    entry.m_OwnerEntity = Owner;
    entry.m_SelfHandle = ch;
    entry.m_Flags.m_Map.m_Valid = true;
    entry.m_Flags.m_Map.m_Step = true;
    entry.m_Flags.m_Map.m_Active = se.m_Active;
    entry.m_Flags.m_Map.m_OnPerSecond = se.m_PerSecond;
    entry.m_ExistingEventHandlers.set();
    m_EntityMapper.SetComponentMapping(entry);

    GetObjectRootInstance(lua, Owner);

    //stack: ScriptClass ObjectRoot GameObject 

    lua_createtable(lua, 0, 0);									//stack: ScriptClass ObjectRoot GameObject Script
    lua_insert(lua, -2);										//stack: ScriptClass ObjectRoot Script GameObject
    lua_setfield(lua, -2, lua::GameObjectName);					//stack: ScriptClass ObjectRoot Script
    lua_pushvalue(lua, -1);										//stack: ScriptClass ObjectRoot Script Script
    lua_rawseti(lua, -3, 1);									//stack: ScriptClass ObjectRoot Script

    GetInstancesTable(lua);										//stack: ScriptClass ObjectRoot Script InstTable
    lua_pushvalue(lua, -2);										//stack: ScriptClass ObjectRoot Script InstTable Script
    lua_rawseti(lua, -2, static_cast<int>(index) + 1);			//stack: ScriptClass ObjectRoot Script InstTable
    lua_pop(lua, 1);											//stack: ScriptClass ObjectRoot Script
        
    lua_insert(lua, -3);										//stack: Script ScriptClass ObjectRoot 
    lua_insert(lua, -3);										//stack: ObjectRoot Script ScriptClass  
    lua_setmetatable(lua, -2);									//stack: ObjectRoot Script 

    lua_pushlightuserdata(lua, Owner.GetVoidPtr());				//stack: ObjectRoot Script Entity
    lua_setfield(lua, -2, lua::EntityMemberName);				//stack: ObjectRoot Script
    lua_pushlightuserdata(lua, ch.GetVoidPtr());				//stack: ObjectRoot Script SelfHandle
    lua_setfield(lua, -2, lua::HandleMemberName);				//stack: ObjectRoot Script

    lua_pushlightuserdata(lua, this);							//stack: ObjectRoot Script this
    lua_pushlightuserdata(lua, ch.GetVoidPtr());				//stack: ObjectRoot Script this SelfHandle 
    lua_pushcclosure(lua, &lua_DestroyComponent, 2);			//stack: ObjectRoot Script lua_DestroyComponent
    lua_setfield(lua, -2, "DestroyComponent");					//stack: ObjectRoot Script
    //TODO: DestroyObject(void/other)

    lua_pushlightuserdata(lua, this);							//stack: ObjectRoot Script this
    lua_pushcclosure(lua, &lua_SetPerSecond, 1);				//stack: ObjectRoot Script lua_SetPerSecond
    lua_setfield(lua, -2, lua::SetPerSecond);					//stack: ObjectRoot Script

    lua_pushlightuserdata(lua, this);							//stack: ObjectRoot Script this
    lua_pushcclosure(lua, &lua_SetStep, 1);						//stack: ObjectRoot Script lua_SetStep
    lua_setfield(lua, -2, lua::SetStep);						//stack: ObjectRoot Script

    lua_pushlightuserdata(lua, this);							//stack: ObjectRoot Script this
    lua_pushcclosure(lua, &lua_SetActive, 1);					//stack: ObjectRoot Script lua_SetActive
    lua_setfield(lua, -2, lua::SetActive);						//stack: ObjectRoot Script

    lua_pushlightuserdata(lua, this);							//stack: ObjectRoot Script this
    lua_pushlightuserdata(lua, ch.GetVoidPtr());				//stack: ObjectRoot Script this SelfHandle 
    lua_pushcclosure(lua, &lua_GetComponent, 2);				//stack: ObjectRoot Script lua_GetComponent
    lua_setfield(lua, -2, "GetComponent");						//stack: ObjectRoot Script 

    lua_getfield(lua, -1, lua::Function_OnCreate);				//stack: ObjectRoot Script OnCreate/nil
    if (lua_isnil(lua, -1)) {
        lua_pop(lua, 1);										//stack: ObjectRoot Script
    } else {
        lua_pushvalue(lua, -2);									//stack: ObjectRoot Script OnCreate Script
        if (!LuaSafeCall(lua, 1, 0, lua::Function_OnCreate, errf)) {
            //no need for more logging
        }
    }

    //stack: ObjectRoot Script

    lua_settop(lua, top);
    //stack: -
    return true;
}

bool ScriptComponent::GetInstanceHandle(Entity Owner, Handle &hout) {
    LOG_NOT_IMPLEMENTED();
    return false;
    //TODO
}

//-------------------------------------------------------------------------------------------------

bool ExtractHandleFromArgument(lua_State *lua, int location, Handle &h, bool AllowSelfHandle = true) {
    int type = lua_type(lua, location);
    switch (type) {
    case LUA_TNIL:
        if (!AllowSelfHandle) {//TODO
            throw "!AllowSelfHandle";
        }
        h = Handle::FromVoidPtr(lua_touserdata(lua, lua_upvalueindex(lua::HandleUpValue)));
        break;
    case LUA_TLIGHTUSERDATA:
        h = Handle::FromVoidPtr(lua_touserdata(lua, location));
        break;
    case LUA_TTABLE:
        lua_getfield(lua, location, lua::HandleMemberName);
        if (!lua_islightuserdata(lua, -1)) {
            lua_pop(lua, 1);
            return false;
        }
        h = Handle::FromVoidPtr(lua_touserdata(lua, -1));
        lua_pop(lua, 1);
        break;
    default:
        return false;
    }
    return true;
}

//-------------------------------------------------------------------------------------------------

void ScriptComponent::GetObjectRootInstance(lua_State *lua, Entity Owner) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);

    GetObjectRootTable(lua);												//stack: ORTable
    lua_rawgeti(lua, -1, static_cast<int>(Owner.GetIndex()) + 1);			//stack: ORTable OR?
    
    if (lua_istable(lua, -1)) {												//stack: ORTable OR
        lua_insert(lua, -2);												//stack: OR ORTable
        lua_pop(lua, 1);													//stack: OR
        lua_getfield(lua, -1, lua::GameObjectName);							//stack: OR GO
        check.ReturnArgs(2);
        return;
    }
                                                                            //stack: ORTable nil
    lua_pop(lua, 1);														//stack: ORTable

    lua_createtable(lua, 0, 0);												//stack: ORTable OR		
    lua_pushvalue(lua, -1);													//stack: ORTable OR OR
    lua_rawseti(lua, -3, static_cast<int>(Owner.GetIndex()) + 1);			//stack: ORTable OR

    lua_insert(lua, -2);													//stack: OR ORTable
    lua_pop(lua, 1);														//stack: OR 

    lua_createtable(lua, 0, 0);												//stack: OR GO
    lua_pushvalue(lua, -1);													//stack: OR GO GO
    lua_setfield(lua, -3, lua::GameObjectName);								//stack: OR GO

    LuaSetField(lua, Owner.GetVoidPtr(), lua::EntityMemberName, -1);	
    LuaSetField(lua, Owner.GetVoidPtr(), lua::EntityMemberName, -2);	

    GetGameObjectMetaTable(lua);											//stack: OR GO GO_MT
    lua_setmetatable(lua, -2);												//stack: OR GO

    check.ReturnArgs(2);
}

bool ScriptComponent::InvalidateObjectRoot(lua_State *lua, Entity Owner) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);
    GetObjectRootTable(lua);												//stack: ORTable
        
    lua_pushnil(lua);														//stack: ORTable nil
    lua_rawseti(lua, -3, static_cast<int>(Owner.GetIndex()) + 1);			//stack: ORTable
    lua_pop(lua, 1);

    return true;
}

//-------------------------------------------------------------------------------------------------

int ScriptComponent::lua_GetScriptComponent(lua_State *lua, Entity Owner) {
    Handle h = m_EntityMapper.GetHandle(Owner);
    
    HandleIndex hi;
    if (!GetHandleTable()->GetHandleIndex(this, h, hi)) {
        return 0;
    }
    auto &e = m_Array[hi];
    if (!e.m_Flags.m_Map.m_Valid) {
        return 0;
    }

    int luatop = lua_gettop(lua);
    Utils::Scripts::LuaStackOverflowAssert check(lua);

    //stack: -
    GetInstancesTable(lua);				//stack: insttable
    lua_rawgeti(lua, -1, hi + 1);		//stack: insttable script/nil

    if (!lua_istable(lua, -1)) {
        lua_settop(lua, luatop);
        return 0;
    }
    
    lua_insert(lua, -2);
    lua_pop(lua, 1);

    return check.ReturnArgs(1);
}

int ScriptComponent::lua_GetComponentInfo(lua_State *lua, ComponentID cid, Entity Owner) {
    Handle ComponentHandle;

    auto cptr = GetManager()->GetComponent(cid);
    if (!cptr) {
        AddLogf(Error, "GetComponent: Error: There is no component %d", cid);
        return 0;
    }

    if (!cptr->GetInstanceHandle(Owner, ComponentHandle)) {
        AddLogf(Debug, "ScripComponent::GetComponent: no component instance for requested object");
        return 0;
    }

    return lua_MakeComponentInfo(lua, cid, ComponentHandle, cptr);
}

int ScriptComponent::lua_MakeComponentInfo(lua_State *lua, ComponentID cid, Handle h, AbstractComponent *cptr) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);

    lua_createtable(lua, 0, 5);

    lua_pushlightuserdata(lua, h.GetVoidPtr());
    lua_setfield(lua, -2, lua::HandleMemberName);

    lua_pushinteger(lua, static_cast<int>(cid));
    lua_setfield(lua, -2, lua::ComponentIDMemberName);

    lua_pushlightuserdata(lua, cptr);
    lua_setfield(lua, -2, lua::ComponentInstanceName);

    lua_pushlightuserdata(lua, cptr);
    lua_pushlightuserdata(lua, h.GetVoidPtr());
    lua_pushcclosure(lua, &lua_DereferenceHandle, 2);
    lua_setfield(lua, -2, lua::DereferenceHandleName);

    lua_pushlightuserdata(lua, cptr);
    lua_pushlightuserdata(lua, h.GetVoidPtr());
    lua_pushcclosure(lua, &lua_SetComponentState, 2);
    lua_setfield(lua, -2, lua::ComponentSetStateName);

    if (m_ScriptEngine->GetComponentEntryMT(cid)) {
        lua_setmetatable(lua, -2);
    }

    return check.ReturnArgs(1);
}

int ScriptComponent::lua_DereferenceHandle(lua_State *lua) {
    void *voidcptr = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    AbstractComponent *cptr = reinterpret_cast<AbstractComponent*>(voidcptr);

    Handle h = Handle::FromVoidPtr(lua_touserdata(lua, lua_upvalueindex(lua::HandleUpValue)));

    int rets = 0;
    if (!cptr->PushEntryToLua(h, lua, rets)) {
        AddLogf(Error, "ComponentInstanceInfo::Get: Error: Component '%s' does not support lua api", typeid(*cptr).name());
        return 0;
    }

    return rets;
}

int ScriptComponent::lua_SetComponentState(lua_State *lua) {
    int argc = lua_gettop(lua);
    if (argc != 2) {
        AddLogf(Error, "ComponentInstanceInfo::Set: Error: Invalid argument count!");
        return 0;
    }

    if (lua_type(lua, -1) != LUA_TTABLE) {
        AddLogf(Error, "ComponentInstanceInfo::Set: Error: Invalid argument type!");
        return 0;
    }

    //stack: self valtable
    Utils::Scripts::LuaStackOverflowAssert check(lua);

    void *voidcptr = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    AbstractComponent *cptr = reinterpret_cast<AbstractComponent*>(voidcptr);

    Handle h = Handle::FromVoidPtr(lua_touserdata(lua, lua_upvalueindex(lua::HandleUpValue)));
    int rets = 0;
    if (!cptr->PushEntryToLua(h, lua, rets)) {
        lua_pushvalue(lua, -2);
        //AddLogf(Error, "ComponentInstanceInfo::Set: Error: Component '%s' does not support lua api", typeid(*cptr).name());
        //return 0;
    } 
    //stack: self values component/self

    lua_pushnil(lua);								//stack: self values component nil

    while (lua_next(lua, 2) != 0) {					//stack: self values component key value
        lua_pushvalue(lua, -2);						//stack: self values component key value key
        lua_insert(lua, -2);						//stack: self values component key key value 
        lua_settable(lua, 3);						//stack: self values component key  
    }
    //stack: self values component/self
    lua_pop(lua, 1);

    return 0;
}

//-------------------------------------------------------------------------------------------------

int ScriptComponent::lua_DestroyComponent(lua_State *lua) {
    Handle h;
    if (!ExtractHandleFromArgument(lua, -1, h)) {
        AddLogf(Error, "ScriptComponent::DestroyComponent: Error: Invalid argument #1: not a valid handle!");
        lua_pushboolean(lua, 0);
        return 1;
    }

    void *voidthis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidthis);

    ComponentID cid;
    if (This->GetHandleTable()->GetOwnerCID(h, cid)) {
        switch (static_cast<ComponentID>(cid)) {
        case ComponentID::Transform:
        case ComponentID::RectTransform:
            AddLogf(Error, "ScriptComponent::DestroyComponent: Error: Cannot release component of cid: %d", cid);
            lua_pushboolean(lua, 0);
            return 1;
        default:
            break;
        }
    }

    if (!This->GetHandleTable()->Release(h)) {
        AddLogf(Error, "ScriptComponent::DestroyComponent: Error: Invalid argument #1: invalid handle");
        lua_pushboolean(lua, 0);
        return 1;
    }

    lua_pushboolean(lua, 1);
    return 1;
}

int ScriptComponent::lua_GetComponent(lua_State *lua) {
    return lua_GameObjectGetComponent(lua);
}

int ScriptComponent::lua_SetPerSecond(lua_State *lua) {
    void *voidthis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidthis);

    lua_getfield(lua, 1, lua::HandleMemberName);					//stack: self enable handle
    Handle h = Handle::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												//stack: self enable

    bool enable = lua_toboolean(lua, 2);

    auto *entry = This->TemplateGetEntry(This, This->m_Array, h);
    if (!entry) {
        AddLogf(Error, "ScriptComponent::SetPerSecond: Error: Invalid self.handle!");
    }

    entry->m_Flags.m_Map.m_OnPerSecond = enable;
    return 0;
}

int ScriptComponent::lua_SetStep(lua_State * lua) {
    void *voidthis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidthis);

    lua_getfield(lua, 1, lua::HandleMemberName);					//stack: self enable handle
    Handle h = Handle::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												//stack: self enable

    bool enable = lua_toboolean(lua, 2);

    auto *entry = This->TemplateGetEntry(This, This->m_Array, h);
    if (!entry) {
        AddLogf(Error, "ScriptComponent::SetStep: Error: Invalid self.handle!");
    }

    entry->m_Flags.m_Map.m_Step = enable;
    return 0;
}

int ScriptComponent::lua_SetActive(lua_State * lua) {
    void *voidthis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidthis);

    lua_getfield(lua, 1, lua::HandleMemberName);					//stack: self enable handle
    Handle h = Handle::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												//stack: self enable

    bool enable = lua_toboolean(lua, 2);

    auto *entry = This->TemplateGetEntry(This, This->m_Array, h);
    if (!entry) {
        AddLogf(Error, "ScriptComponent::SetActive: Error: Invalid self.handle!");
    }

    entry->m_Flags.m_Map.m_Active = enable;
    return 0;
}

//-------------------------------------------------------------------------------------------------

int ScriptComponent::lua_CreateComponent(lua_State *lua) {
    ComponentID cid;

    if (!lua_istable(lua, -2)) {
        AddLogf(Error, "GameObject::CreateComponent: Error: Invalid self argument");
        lua_pushnil(lua);
        return 1;
    }

    switch (lua_type(lua, -1)) {
    case LUA_TNUMBER:
        cid = static_cast<ComponentID>(lua_tointeger(lua, -1));
        break;
    case LUA_TSTRING:
        if(ComponentRegister::GetComponentID(lua_tostring(lua, -1), cid))
            break;
        AddLogf(Error, "GameObject::CreateComponent: Error: Invalid argument #1: Unknown component: %s", lua_tostring(lua, -1));
    default:
        lua_pushnil(lua);
        return 1;
    }

    void *voidThis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidThis);

    //stack: self cid

    lua_getfield(lua, -2, lua::EntityMemberName);					//stack: self cid Entity
    Entity Owner = Entity::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												//stack: self cid

    if (!This->GetManager()->GetWorld()->GetEntityManager()->IsValid(Owner)) {
        AddLogf(Error, "GameObject::CreateComponent: Error: Attempt to create component for invalid object! cid: %d", cid);
        lua_pushnil(lua);
        return 1;
    }
    
    auto *cptr = This->GetManager()->GetComponent(cid);
    if (!cptr) {
        AddLogf(Error, "GameObject::CreateComponent: Error: Invalid argument #1: There is no component cid: %d", cid);
        lua_pushnil(lua);
        return 1;
    }

    Handle hout;
    if (cptr->Create(Owner, hout)) {
        return This->lua_MakeComponentInfo(lua, cid, hout, cptr);
    } else {
        AddLogf(Error, "GameObject::CreateComponent: Error: Failure during component creation! cid: %d", cid);
        lua_pushnil(lua);
        return 1;
    }
}

//----------------------------------------------------

template<typename T>
std::optional<T> GetOptionalField(lua_State *lua, int idx, const char *field) {
    lua_getfield(lua, idx, field);
    if (lua_isnil(lua, -1)) {
        lua_pop(lua, 1);
        return std::nullopt;
    }
    else {
        auto t = luabridge::Stack<T>::get(lua, lua_gettop(lua));
        lua_pop(lua, 1);
        return std::move(t);
    }
}

int ScriptComponent::lua_DoSpawn(lua_State *lua, Entity Owner) {
    /*
    GameObject:SpawnChild {
    Pattern = "URI",
    [Name = "..."]
    [Position = Vec3(5, 5, 5),] --local pos
    [Rotation = Quaternion(5, 5, 5, 5),] --local rotation

    --TODO:
    [Data = { --[[ sth ]] },] -- data passed to script OnCreate function
    [Owner = someone, ] -- create as child of someone
    [Clone = someone, ] -- create clone of someone
    }

    returns:
    TODO
    */
    int argc = lua_gettop(lua);		//stack: self spawnarg
    Utils::Scripts::LuaStackOverflowAssert check(lua);

    if (argc != 2) {
        AddLogf(Error, "GameObject::SpawnChild: Error: Invalid argument count: %s", argc);
        return 0;
    }

    lua_getfield(lua, 2, "Pattern");									//stack: self spawnarg spawnarg.Pattern		
    const char *pattername = lua_tostring(lua, -1);
    if (!pattername) {
        AddLogf(Error, "GameObject::SpawnChild: Error: Invalid pattern name! (not a string!)", argc);
        lua_settop(lua, argc);
        return 0;
    }

    lua_getfield(lua, 2, "Name");										//stack: self spawnarg spawnarg.Name		
    const char *ChildName = lua_tostring(lua, -1);
    if (!pattername) {
        AddLogf(Error, "GameObject::SpawnChild: Error: Invalid Child! (not a string!)", argc);
        lua_settop(lua, argc);
        return 0;
    }

    //stack: self spawnarg spawnarg.Pattern

    void *voidThis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidThis);

    Entity Child;
    if (!EntityBuilder::Build(This->GetManager(), Owner, pattername, Child, (ChildName ? std::string(ChildName) : std::string()))) {
        AddLogf(Error, "GameObject::SpawnChild: Error: Failed to build child: %s", pattername);
        lua_settop(lua, argc);
        return 0;
    }

    lua_pop(lua, 1);													//stack: self spawnarg spawnarg.Pattern
    ChildName = nullptr;

    auto OptPosition = GetOptionalField<math::vec3>(lua, 2, "Position");
    auto OptRotation = GetOptionalField<math::vec4>(lua, 2, "Rotation");    

    auto cm = This->GetManager();
    if (OptPosition.has_value() || OptRotation.has_value()) {
        auto *tc = cm->GetComponent<TransformComponent>();
        auto entry = tc->GetEntry(Child);
        if (!entry) {
            AddLogf(Error, "GameObject::SpawnChild: Child does not have transform component!");
        }
        else {
            if (OptPosition.has_value())
                entry->SetPosition(*OptPosition);
            if (OptRotation.has_value())
                entry->SetRotation(*OptRotation);
        }
    }

    AddLogf(Hint, "GameObject::SpawnChild: Done");
    //TODO:
    lua_settop(lua, argc);
    This->GetObjectRootInstance(lua, Child);
    lua_insert(lua, -2);
    lua_pop(lua, 1);
    return check.ReturnArgs(1);
}

int ScriptComponent::lua_Spawn(lua_State *lua) {
    void *voidThis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidThis);
    auto cm = This->GetManager();
    auto Owner = cm->GetRootEntity();
    return lua_DoSpawn(lua, Owner);
}

int ScriptComponent::lua_SpawnChild(lua_State *lua) {
    lua_getfield(lua, 1, lua::EntityMemberName);					
    Entity Owner = Entity::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												
    return lua_DoSpawn(lua, Owner);
}

int ScriptComponent::lua_DestroyObject(lua_State *lua) {
    Handle h;
    if (!ExtractHandleFromArgument(lua, -1, h)) {
        AddLogf(Error, "ScriptComponent::DestroyObject: Error: Invalid argument #1: unknown type!");
        lua_pushboolean(lua, 0);
        return 1;
    }

    void *voidthis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidthis);

    HandleIndex index;
    if (!This->GetHandleTable()->GetHandleIndex(This, h, index)) {
        AddLogf(Error, "ScriptComponent::DestroyObject: Error: Invalid argument #1: invalid handle");
        lua_pushboolean(lua, 0);
        return 1;
    }

    //auto &item = This->m_Array[index];
    //auto *scene = static_cast<GameScene*>(This->GetManager()->GetScene());
    //auto reg = scene->GetObjectRegister();
         
    LOG_NOT_IMPLEMENTED();
    //TODO: lua api DestroyObject
    AddLog(Error, "DestroyObject is not yet supported");

    lua_pushboolean(lua, 0);
    return 1;
}

int ScriptComponent::lua_Destroy(lua_State * lua) {
//	int argc = lua_gettop(lua);		//stack: self

    void *voidWorld = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    World *world = reinterpret_cast<World*>(voidWorld);
    
    lua_getfield(lua, 1, lua::EntityMemberName);						//stack: self Entity
    Entity Owner = Entity::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);													//stack: self

    if (!world->GetEntityManager()->Release(Owner)) {
        AddLogf(Error, "GameObject::Destroy: Error: Failed to release Entity");
        lua_pushboolean(lua, 0);
        return 1;
    }

    lua_pushboolean(lua, 1);
    return 1;
}

int ScriptComponent::lua_SetName(lua_State * lua) {
    void *voidWorld = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    World *world = reinterpret_cast<World*>(voidWorld);

    const char *NewName = lua_tostring(lua, 2);
    if (!NewName) {
        AddLogf(Error, "GameObject::SetName: Error: Invalid name! (not a string!)");
        return 0;
    }

    lua_getfield(lua, 1, lua::EntityMemberName);					//stack: self Entity
    Entity Owner = Entity::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												//stack: self

    auto em = world->GetEntityManager();
    if (!em->SetEntityName(Owner, NewName)) {
        AddLogf(Error, "GameObject::SetName: Error: Set name failed!");
    }

    return 0;
}

int ScriptComponent::lua_GetName(lua_State * lua) {
    void *voidWorld = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    World *world = reinterpret_cast<World*>(voidWorld);

    lua_getfield(lua, 1, lua::EntityMemberName);					//stack: self Entity
    Entity Owner = Entity::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												//stack: self

    auto em = world->GetEntityManager();
    const std::string *name = nullptr;
    if (!em->GetEntityName(Owner, name)) {
        AddLogf(Error, "GameObject::GetName: Error: Object does not valid!");
        return 0;
    }

    if (name)
        lua_pushlstring(lua, name->c_str(), name->length());
    else
        lua_pushstring(lua, "");

    return 1;
}

int ScriptComponent::lua_FindChild(lua_State * lua) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);
    void *voidThis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidThis);

    const char *ChildName = lua_tostring(lua, 2);								//stack: self ChildName			
    if (!ChildName) {
        AddLogf(Error, "GameObject::FindChild: Error: Invalid name! (not a string!)");
        return 0;
    }

    lua_getfield(lua, 1, lua::EntityMemberName);					//stack: self ChildName Entity
    Entity Owner = Entity::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												//stack: self ChildName

    Entity Child;
    if (!This->GetManager()->GetWorld()->GetEntityManager()->GetFirstChildByName(Owner, ChildName, Child)) {
        AddLogf(Debug, "Child '%s' not found!", ChildName);
        return 0;
    }

    This->GetObjectRootInstance(lua, Child);
    //stack: self ChildName OR GO

    lua_insert(lua, -2);											//stack: self ChildName GO OR
    lua_pop(lua, 1);												//stack: self ChildName GO

    return check.ReturnArgs(1);
}

int ScriptComponent::lua_GameObjectGetComponent(lua_State * lua) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);
    int argc = lua_gettop(lua);

    ComponentID cid = ComponentID::Invalid;
    const char *cname = nullptr;
    Entity RequestedOwner = {};
    bool HaveOwner = false;

    switch (argc) {
    case 3:
        if (!lua_islightuserdata(lua, 3)) {
            AddLogf(Error, "GameObject::GetComponent: Error: Invalid argument #2: invalid type!");
            return 0;
        }
        RequestedOwner = Entity::FromVoidPtr(lua_touserdata(lua, 3));
        HaveOwner = true;
        //no break;
    case 2:
        switch (lua_type(lua, 2)) {
        case LUA_TNUMBER:
            cid = static_cast<ComponentID>(lua_tointeger(lua, 2));
            break;
        case LUA_TSTRING:
            cname = lua_tostring(lua, 2);
            break;
        default:
            AddLogf(Error, "GameObject::GetComponent: Error: Invalid argument #1: invalid type!");
            return 0;
        }
        
        if (HaveOwner) 
            break;

        lua_getfield(lua, 1, lua::EntityMemberName);
        if (lua_isnil(lua, -1)) {
            AddLogf(Error, "GameObject::GetComponent: Error: Invalid self entity");
        } else {
            RequestedOwner = Entity::FromVoidPtr(lua_touserdata(lua, -1));
            HaveOwner = true;
        }
        lua_pop(lua, 1);
        break;
    default:
        AddLogf(Error, "GameObject::GetComponent: Error: Invalid argument count");
        return 0;
    }

    if (!HaveOwner) {
        AddLogf(Error, "GameObject::GetComponent: Error: Unable extract Owner entity");
        return 0;
    }

    if (cname) {
        if (!ComponentRegister::GetComponentID(cname, cid)) {
            AddLogf(Error, "GameObject::GetComponent: Error: Unknown component name: %s", cname);
            return 0;
        }
    }

    void *voidthis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidthis);

    if (cid == ComponentID::Script) {
        return check.ReturnArgs(This->lua_GetScriptComponent(lua, RequestedOwner));
    }

    return check.ReturnArgs(This->lua_GetComponentInfo(lua, cid, RequestedOwner));
}

int ScriptComponent::lua_GetParent(lua_State * lua) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);
    void *voidThis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidThis);

    lua_getfield(lua, 1, lua::EntityMemberName);					//stack: self ChildName Entity
    Entity Owner = Entity::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												//stack: self ChildName

    Entity Parent;
    if (!This->GetManager()->GetWorld()->GetEntityManager()->GetParent(Owner, Parent)) {
        AddLogf(Debug, "Unable to get parent!");
        return 0;
    }

    //TODO: check Parent

    This->GetObjectRootInstance(lua, Parent);
    //stack: self OR GO

    lua_insert(lua, -2);											//stack: self GO OR
    lua_pop(lua, 1);												//stack: self GO

    return check.ReturnArgs(1);
}

int ScriptComponent::lua_GetFirstChild(lua_State * lua) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);
    void *voidThis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidThis);

    lua_getfield(lua, 1, lua::EntityMemberName);					//stack: self ChildName Entity
    Entity Owner = Entity::FromVoidPtr(lua_touserdata(lua, -1));
    lua_pop(lua, 1);												//stack: self ChildName

    Entity Child;
    if (!This->GetManager()->GetWorld()->GetEntityManager()->GetFistChild(Owner, Child)) {
        AddLogf(Debug, "Unable to get first child!");
        return 0;
    }

    //TODO: check Parent

    This->GetObjectRootInstance(lua, Child);
    //stack: self OR GO

    lua_insert(lua, -2);											//stack: self GO OR
    lua_pop(lua, 1);												//stack: self GO

    return check.ReturnArgs(1);
}
 
int ScriptComponent::lua_GetGameObject(lua_State * lua) {
    Utils::Scripts::LuaStackOverflowAssert check(lua);
    void *voidThis = lua_touserdata(lua, lua_upvalueindex(lua::SelfPtrUpValue));
    ScriptComponent *This = reinterpret_cast<ScriptComponent*>(voidThis);

    Entity E = Entity::FromVoidPtr(lua_touserdata(lua, 2));
    if (!E.GetVoidPtr()) {
        AddLogf(ScriptRuntime, "GameObject::lua_GetGameObject: Error: Invalid argument");
        return 0;
    }

    if (!This->GetManager()->GetWorld()->GetEntityManager()->IsValid(E)) {
        AddLogf(ScriptRuntime, "GameObject::lua_GetGameObject: Error: Invalid object");
        return 0;
    }

    //TODO: check Parent

    This->GetObjectRootInstance(lua, E);

    lua_insert(lua, -2);											//stack: self GO OR
    lua_pop(lua, 1);												//stack: self GO

    return check.ReturnArgs(1);
}
} //namespace MoonGlare::Core::Scripts::Component  
