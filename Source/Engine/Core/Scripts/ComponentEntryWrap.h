/*
* Generated by cppsrc.sh
* On 2016-07-23 16:55:00,64
* by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef ComponentEntryWrap_H
#define ComponentEntryWrap_H

#include <Utils/LuaUtils.h>

namespace MoonGlare::Core::Scripts::Component {

template<typename COMPONENT>
struct ComponentEntryWrap {
	using Component_t = COMPONENT;

private:
	template<typename MemFnPtr, MemFnPtr fn>
	struct FnWrap {
		typedef typename luabridge::FuncTraits <MemFnPtr>::Params Params;
		typedef typename luabridge::FuncTraits <MemFnPtr>::ReturnType ReturnType;

		static int f(lua_State *L) {
			void *voidThis = lua_touserdata(L, lua_upvalueindex(1));
			Component_t *This = reinterpret_cast<Component_t*>(voidThis);
			luabridge::ArgList <Params, 2> args(L);
			luabridge::Stack <ReturnType>::push(L, luabridge::FuncTraits <MemFnPtr>::call(This, fn, args));
			return 1;
		}
	};

protected:
	template<typename MEMFN, MEMFN fn>
	static void PushThisClosure(lua_State *lua, Component_t *This) {
		Utils::Scripts::lua_PushCClosure(lua, &FnWrap<MEMFN, fn>::f, (void*)This );
	}
	template<typename ENUMCONV, bool READ, typename StackFunc, typename ENUM>
	static int ProcessEnum(lua_State *lua, ENUM &e, int idx) {
		if (READ) {
			auto val = ENUMCONV::ToString(e);
			auto cstr = val.c_str();
			return StackFunc::func(lua, cstr, idx);
		} else {
			switch (lua_type(lua, idx)) {
			case LUA_TNUMBER: {
				int v, luarets = StackFunc::func(lua, v, idx);
				e = static_cast<ENUM>(v);
				return luarets;
			}
			case LUA_TSTRING: 	{
				const char *v = nullptr;
				int luarets = StackFunc::func(lua, v, idx);
				if (!ENUMCONV::Convert(v, e)) {
					//TODO: log
				}
				return luarets;
			}
			default:
				//TODO log
				return 0;
			}
		}
	}
private:
	static int Index(lua_State *lua) {
		Utils::Scripts::LuaStackOverflowAssert check(lua);
		const char *name = lua_tostring(lua, 2);

		lua_getfield(lua, 1, "ComponentInstance");
		void *voidThis = lua_touserdata(lua, -1);
		lua_pop(lua, 1);
		Component_t *This = reinterpret_cast<Component_t*>(voidThis);

		lua_getfield(lua, 1, "Handle");
		Handle Owner = Handle::FromVoidPtr(lua_touserdata(lua, -1));
		lua_pop(lua, 1);

		auto hash = Space::Utils::MakeHash32(name);

		auto e = This->GetEntry(Owner);
		if (!e)
			return 0;

		int lrets = 0;
		if (Component_t::template QuerryFunction<luabridge::StackPush>(lua, e, hash, lrets, 0, This)) {
			return check.ReturnArgs(lrets);
		}
		if (Component_t::template ProcessProperty<true, luabridge::StackPush>(lua, e, hash, lrets, 0)) {
			return check.ReturnArgs(lrets);
		}
		return 0;
	}

	static int NewIndex(lua_State *lua) {
		Utils::Scripts::LuaStackOverflowAssert check(lua);
		const char *name = lua_tostring(lua, 2);

		lua_getfield(lua, 1, "ComponentInstance");
		void *voidThis = lua_touserdata(lua, -1);
		lua_pop(lua, 1);
		Component_t *This = reinterpret_cast<Component_t*>(voidThis);

		lua_getfield(lua, 1, "Handle");
		Handle Owner = Handle::FromVoidPtr(lua_touserdata(lua, -1));
		lua_pop(lua, 1);

		int validx = 3;

		auto e = This->GetEntry(Owner);
		if (!e)
			return 0;

		auto hash = Space::Utils::MakeHash32(name);
		int lrets;
		if (!Component_t::template ProcessProperty<false, luabridge::StackGet>(lua, e, hash, lrets, validx)) {
			return 0;
		}
		return check.ReturnArgs(lrets);
	}
public:
	static constexpr LuaMetamethods EntryMetamethods = { &Index , &NewIndex, };
};

} //namespace MoonGlare::Core::Scripts::Component 

#endif
