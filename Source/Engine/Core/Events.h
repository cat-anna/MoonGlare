/*
	Generated by cppsrc.sh
	On 2015-01-20  9:04:58,62
	by Paweu
*/
#pragma once
#ifndef Events_H
#define Events_H

namespace Core {
namespace Events {

enum class InternalEvents {
	None,

	SceneLoadingFinished,
};

class EventBaseProxy : public cRootClass {
	SPACERTTI_DECLARE_STATIC_CLASS(EventBaseProxy, cRootClass)
public:
	EventBaseProxy();
	virtual ~EventBaseProxy();

	virtual int TimerEvent(int TimerID);

	virtual int InternalEvent(InternalEvents event, int Param);
};

using EventProxyPtr = std::weak_ptr<EventBaseProxy>;

template<class OWNER, 
		int (OWNER::*TimerFunc)(int) = nullptr,
		int (OWNER::*InternalEventFunc)(InternalEvents, int) = nullptr>
class EventProxy : public EventBaseProxy {
public:
	typedef OWNER Owner_t;
	EventProxy(Owner_t *Owner) : m_Owner(Owner) { };

	virtual int TimerEvent(int TimerID) { 
		if (TimerFunc == nullptr) return 0;
		return (m_Owner->*TimerFunc)(TimerID);
	};
	virtual int InternalEvent(InternalEvents event, int Param) { 
		if (InternalEventFunc == nullptr) return 0;
		return (m_Owner->*InternalEventFunc)(event, Param);
	};
private:
	Owner_t *m_Owner;
};

class EventProxyHolderBase {
public:
	EventProxyHolderBase() {};
	~EventProxyHolderBase() {};

	EventProxyPtr get() const { return EventProxyPtr(m_handler); }
protected:
	std::shared_ptr<EventBaseProxy> m_handler;
};

class EventProxyHolder : public EventProxyHolderBase {
public:
	EventProxyHolder() { }
	~EventProxyHolder() {};
	void set(EventBaseProxy *ptr) { m_handler.reset(ptr); }
protected:
};

#define DECLARE_PROTECTED_EVENT_HOLDER()		\
	protected: EventProxyHolder m_EventProxy;	\
	protected: EventProxyPtr GetEventProxy() const { return m_EventProxy.get();}

#define DECLARE_EVENT_HOLDER()					\
	protected: EventProxyHolder m_EventProxy;	\
	public: EventProxyPtr GetEventProxy() const { return m_EventProxy.get();}

} //namespace Events 

using Events::EventProxyPtr;
using Events::EventProxyHolder;
using Events::EventProxy;

} //namespace Core 

#endif
