/*
  * Generated by cppsrc.sh
  * On 2016-08-04 19:45:53,67
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>
#include "InputProcessor.h"
#include <Utils/LuaUtils.h>

#include <Input.x2c.h>

namespace MoonGlare {
namespace Core {

const KeyNamesTable g_KeyNamesTable;

Space::RTTI::TypeInfoInitializer<InputProcessor, InputStateValue, InputState, KeyAction, AxisAction, KeyNamesTable> InputStructures;
RegisterApiNonClass(InputProcessor, &InputProcessor::RegisterScriptApi);

//---------------------------------------------------------------------------------------

InputProcessor::InputProcessor() {
	m_CurrentRevision = 1;
	m_World = nullptr;
	ResetToInternalDefault();
}

InputProcessor::~InputProcessor() {

}

//---------------------------------------------------------------------------------------

void InputProcessor::RegisterScriptApi(ApiInitializer &root) {
	root
		.beginClass<InputProcessor>("cInputProcessor")
			.addFunction("RegisterKeySwitch", &InputProcessor::RegisterKeySwitch)
			.addFunction("RegisterKeyboardAxis", &InputProcessor::RegisterKeyboardAxis)
		.endClass()
		;
}

//---------------------------------------------------------------------------------------

bool InputProcessor::Initialize(World *world) {
	m_World = world;
	auto *ScriptEngine = m_World->GetScriptEngine();
	{
		auto lua = ScriptEngine->GetLua();
		LOCK_MUTEX_NAMED(ScriptEngine->GetLuaMutex(), lock);
		Utils::Scripts::LuaStackOverflowAssert check(lua);

		lua_createtable(lua, 0, 0);					// stack: selftable
		MoonGlare::Core::Scripts::PublishSelfLuaTable(lua, "InputProcessor", this, -1);
		lua_pushlightuserdata(lua, (void *)this);	// stack: selftable selfptr
		lua_pushvalue(lua, -2);		  				// stack: selftable selfptr selftable
		lua_settable(lua, LUA_REGISTRYINDEX);		// stack: selftable

		lua_pushlightuserdata(lua, (void *)this);	// stack: selftable selfptr
		lua_pushcclosure(lua, &InputProcessor::luaIndexInput, 1);// stack: selftable cclosure
		lua_setfield(lua, -2, "__index");			// stack: selftable

		lua_createtable(lua, 0, 0);					// stack: selftable InputTable
		lua_insert(lua, -2);						// stack: InputTable selftable 
		lua_setmetatable(lua, -2);					// stack: InputTable
		lua_setglobal(lua, "Input");				// stack:
	}

	ScriptEngine->RegisterLuaSettings(this, "Input");

	pugi::xml_document doc;
	if (doc.load_file(Configuration::Input::SettingsFileName)) {
		if (!Load(doc.document_element())) {
			AddLog(Error, "Failed to load input configuration");
			return false;
		}
		AddLogf(Info, "Loaded InputConfiguration from: %s", Configuration::Input::SettingsFileName);
	}

	return true;
}

bool InputProcessor::Finalize() {
	{
		auto *se = m_World->GetScriptEngine();
		auto lua = se->GetLua();
		LOCK_MUTEX_NAMED(se->GetLuaMutex(), lock);
		Utils::Scripts::LuaStackOverflowAssert check(lua);

		lua_pushlightuserdata(lua, (void *)this);
		lua_pushnil(lua);
		lua_settable(lua, LUA_REGISTRYINDEX);

		lua_pushnil(lua);
		lua_setglobal(lua, "Input");	

		MoonGlare::Core::Scripts::HideSelfLuaTable(lua, "InputProcessor", this);
	}
	return true;
}

//---------------------------------------------------------------------------------------

bool InputProcessor::Step(const Core::MoveConfig & config) {
	++m_CurrentRevision;
	return true;
}

//---------------------------------------------------------------------------------------

void InputProcessor::ProcessKeyState(unsigned Id, bool Pressed) {
	THROW_ASSERT(Id < Configuration::Input::MaxKeyCode, "Key code id overflow!");
	//AddLogf(Debug, "Processing key: %u:%d", Id, Pressed ? 1 : 0);

	auto &keyinfo = m_Keys[Id];
	if (!keyinfo.m_Flags.m_Valid) 
		return;
	
	auto &state = m_InputStates[keyinfo.m_Id];

	//AddLogf(Debug, "State:%u currkey:%u value:%f", Id, state.m_ActiveKeyId, state.m_Value.m_Float);

	if (Pressed || state.m_ActiveKeyId == Id || state.m_ActiveKeyId == Configuration::Input::MaxKeyCode) { 
		//while handling key release do not update state if it is changed by other key
		switch (state.m_Type) {
		case InputState::Type::Switch:
			state.m_Value.m_Boolean = Pressed;
			break;
		case InputState::Type::FloatAxis:
			state.m_Value.m_Float = Pressed ? keyinfo.m_Value.m_Float : 0.0f;
			break;
		default:
			LogInvalidEnum(state.m_Type);
			return;
		}
	}
	state.m_Revision = m_CurrentRevision + 1;
	state.m_ActiveKeyId = Pressed ? Id : Configuration::Input::MaxKeyCode;
}

void InputProcessor::ProcessMouseAxis(MouseAxisId Id, float Delta) {
	THROW_ASSERT(Id <MouseAxisId::Unknown, "Mouse axis id overflow!");
	//AddLogf(Debug, "Processing mouse axis: %d:%f", Id, Delta);

	auto &axis = m_MouseAxes[static_cast<size_t>(Id)];
	if (!axis.m_Flags.m_Valid)
		return;
	auto &state = m_InputStates[axis.m_Id];
	if (!state.m_Flags.m_Valid || state.m_Type != InputState::Type::FloatAxis) {
		AddLog(Error, "Invalid Input state or invalid state type!");
		return;
	}
	
	state.m_Value.m_Float = Delta * axis.m_Sensitivity;
}

void InputProcessor::ClearStates() {
	for (auto &it : m_MouseAxes) {
		if (!it.m_Flags.m_Valid)
			continue;
		m_InputStates[it.m_Id].m_Value.m_Float = 0.0f;
	}
}

//---------------------------------------------------------------------------------------

bool InputProcessor::Save(pugi::xml_node node) const {
	x2c::Core::Input::InputConfiguration_t conf;
	for (auto &it : m_MouseAxes) {
		if (!it.m_Flags.m_Valid)
			continue;

		x2c::Core::Input::MouseAxis_t ma;
		ma.m_AxisId = static_cast<MouseAxisId>(&it - &m_MouseAxes[0]);
		ma.m_Sensitivity = it.m_Sensitivity;
		switch (ma.m_AxisId) {
		case MouseAxisId::X:
		case MouseAxisId::Y:
			ma.m_Sensitivity /= Configuration::Input::StaticMouseSensivity;
			break;
		case MouseAxisId::ScrollX:
		case MouseAxisId::ScrollY:
			ma.m_Sensitivity /= Configuration::Input::StaticMouseScrollSensivity;
			break;
		default:
			LogInvalidEnum(ma.m_AxisId);
			break;
		}
		GetInputStateName(it.m_Id, ma.m_Name);
		conf.m_MouseAxes.push_back(std::move(ma));
	}

	std::unordered_map<InputStateId, std::list<const KeyAction*>> KeyActionsMap;

	for (auto &it : m_Keys) {
		if (!it.m_Flags.m_Valid)
			continue;
		KeyActionsMap[it.m_Id].push_back(&it);
	}

	for (auto &it : KeyActionsMap) {
		auto &list = it.second;
		auto &state = m_InputStates[it.first];

		if (!state.m_Flags.m_Valid) {
			//just to be sure
			continue;
		}

		switch (state.m_Type) {
		case InputState::Type::Switch: {
			x2c::Core::Input::KeyboardSwitch_t sw;
			GetInputStateName(it.first, sw.m_Name);
			for (auto key : list) {
				auto index = static_cast<KeyId>(key - &m_Keys[0]);
				sw.m_Keys.push_back(index);
			}
			conf.m_KeyboardSwitches.push_back(std::move(sw));
			break;
		}
		case InputState::Type::FloatAxis:{
			x2c::Core::Input::KeyboardAxis_t ka;
			GetInputStateName(it.first, ka.m_Name);
			for (auto key : list) {
				auto index = static_cast<KeyId>(key - &m_Keys[0]);
				if (key->m_Flags.m_Positive)
					ka.m_NegativeKeys.push_back(index);
				else
					ka.m_PositiveKeys.push_back(index);
			}
			conf.m_KeyboardAxes.push_back(std::move(ka));
			break;
		}
		default:
			LogInvalidEnum(state.m_Type);
			continue;
		}
	}

	return conf.Write(node);
}

bool InputProcessor::Load(const pugi::xml_node node) {
	Clear();
	x2c::Core::Input::InputConfiguration_t conf;
	if (!conf.Read(node)) {
		AddLog(Error, "Failed to read input configuration!");
		return false;
	}

	for (auto &it : conf.m_KeyboardSwitches) {
		InputStateId InputIndex;
		if (!AllocInputState(InputState::Type::Switch, it.m_Name, InputIndex)) {
			//no need for more logging
			return false;
		}
		for (auto key : it.m_Keys) {
			AllocKeyAction(key, InputIndex, true);
		}
	}

	for (auto &it : conf.m_KeyboardAxes) {
		InputStateId InputIndex;
		if (!AllocInputState(InputState::Type::FloatAxis, it.m_Name, InputIndex)) {
			//no need for more logging
			return false;
		}
		for (auto key : it.m_PositiveKeys) {
			AllocKeyAction(key, InputIndex, true);
		}
		for (auto key : it.m_NegativeKeys) {
			AllocKeyAction(key, InputIndex, false);
		}
	}

	for (auto &it : conf.m_MouseAxes) {
		AddMouseAxis(it.m_Name.c_str(), it.m_AxisId, it.m_Sensitivity);
	}

	AddLog(Info, "Loaded input configuration");
	return true;
}

void InputProcessor::Clear() {
	m_InputStates.MemZeroAndClear();
	Space::MemZero(m_MouseAxes);
	Space::MemZero(m_Keys);
	m_InputNames.clear();
}

void InputProcessor::ResetToInternalDefault() {
	Clear();

	//AddKeyboardAxis("Forward", GLFW_KEY_UP, GLFW_KEY_DOWN);
	//AddKeyboardAxis("SideStep", GLFW_KEY_LEFT, GLFW_KEY_RIGHT);

	AddKeyboardAxis("Forward", GLFW_KEY_W, GLFW_KEY_S);
	AddKeyboardAxis("SideStep", GLFW_KEY_A, GLFW_KEY_D);

	AddKeyboardSwitch("Run", GLFW_KEY_LEFT_SHIFT);

	AddMouseAxis("Turn", MouseAxisId::X, 0.5f);
	AddMouseAxis("LookAngle", MouseAxisId::Y, 0.5f);
}

bool InputProcessor::GetInputStateName(InputStateId isid, std::string &out) const {
	for(auto &it: m_InputNames)
		if (it.second == isid) {
			out = it.first;
			return true;
		}
	out = "?";
	return false;
}

//---------------------------------------------------------------------------------------

InputState* InputProcessor::AllocInputState(InputState::Type type, const std::string &Name, InputStateId &outindex) {
	InputState *stateptr = nullptr;

	auto it = m_InputNames.find(Name);
	if (it != m_InputNames.end()) {
		stateptr = &m_InputStates[it->second];
		outindex = static_cast<InputStateId>(it->second);
		if (!stateptr->m_Flags.m_Valid) {
			AddLogf(Error, "There was a invalid input state: %s", Name.c_str());
		} else {
			if (stateptr->m_Type != type) {
				AddLogf(Error, "Attempt to redefine type of input state: %s", Name.c_str());
				return false;
			}
		}
	} else {
		size_t idx;
		if (!m_InputStates.Allocate(idx)) {
			AddLog(Error, "No more space to add keyboard axis");
			return nullptr;
		}
		outindex = static_cast<InputStateId>(idx);
		m_InputNames[Name] = static_cast<InputStateId>(outindex);
		stateptr = &m_InputStates[outindex];
	}

	auto &state = *stateptr;
	state.m_Flags.m_Valid = true;
	state.m_Type = type;

	switch (state.m_Type) {
	case InputState::Type::Switch:
		state.m_Value.m_Boolean = false;
		break;
	case InputState::Type::FloatAxis:
		state.m_Value.m_Float = 0.0f;
		break;
	default:
		LogInvalidEnum(state.m_Type);
		break;
	}

	return &state;
}

KeyAction* InputProcessor::AllocKeyAction(KeyId kid, InputStateId isid, bool Positive) {
	THROW_ASSERT(kid < Configuration::Input::MaxKeyCode, "KeyId overflow!");
	auto &key = m_Keys[kid];
	key.m_Flags.m_Valid = true;
	key.m_Flags.m_Positive = Positive;
	key.m_Id = isid;

	auto &state = m_InputStates[isid];

	switch (state.m_Type) {
	case InputState::Type::Switch:
		key.m_Value.m_Boolean = Positive;
		break;
	case InputState::Type::FloatAxis:
		key.m_Value.m_Float = Positive ? 1.0f : -1.0f;
		break;
	default:
		LogInvalidEnum(state.m_Type);
		break;
	}
	return &key;
}

AxisAction* InputProcessor::AllocMouseAxis(MouseAxisId maid, InputStateId isid, float Sensitivity) {
	auto &axis = m_MouseAxes[static_cast<size_t>(maid)];
	axis.m_Flags.m_Valid = true;
	axis.m_Sensitivity = Sensitivity;
	axis.m_Id = isid;

	switch (maid) {
	case MouseAxisId::X:
	case MouseAxisId::Y:
		axis.m_Sensitivity *= Configuration::Input::StaticMouseSensivity;
		break;
	case MouseAxisId::ScrollX:
	case MouseAxisId::ScrollY:
		axis.m_Sensitivity *= Configuration::Input::StaticMouseScrollSensivity;
		break;
	default:
		LogInvalidEnum(maid);
		break;
	}
	return &axis;
}

bool InputProcessor::AddKeyboardAxis(const char *Name, KeyId PositiveKey, KeyId NegativeKey) {
	THROW_ASSERT(PositiveKey < Configuration::Input::MaxKeyCode, "PositiveKey id overflow!");
	THROW_ASSERT(NegativeKey < Configuration::Input::MaxKeyCode, "NegativeKey id overflow!");

	InputStateId InputIndex;
	if (!AllocInputState(InputState::Type::FloatAxis, Name, InputIndex)) {
		//no need for more logging
		return false;
	}

	AllocKeyAction(PositiveKey, InputIndex, true);
	AllocKeyAction(NegativeKey, InputIndex, false);

	return true;
}

bool InputProcessor::AddKeyboardSwitch(const char *Name, KeyId Key) {
	THROW_ASSERT(Key < Configuration::Input::MaxKeyCode, "Key id overflow!");

	InputStateId InputIndex;
	if (!AllocInputState(InputState::Type::Switch, Name, InputIndex)) {
		//no need for more logging
		return false;
	}
	AllocKeyAction(Key, InputIndex, true);

	return true;
}

bool InputProcessor::AddMouseAxis(const char *Name, MouseAxisId axisid, float Sensitivity) {
	THROW_ASSERT(axisid < MouseAxisId::Unknown, "MouseAxisId overflow!");

	InputStateId InputIndex;
	if (!AllocInputState(InputState::Type::FloatAxis, Name, InputIndex)) {
		//no need for more logging
		return false;
	}
	AllocMouseAxis(axisid, InputIndex, Sensitivity);

	return true;
}

bool InputProcessor::RegisterKeySwitch(const char *Name, const char *KeyName) {
	KeyId kid;
	if (!g_KeyNamesTable.Find(KeyName, kid)) {
		AddLogf(Warning, "Unknown key: %s", KeyName);
		return false;
	}

	return AddKeyboardSwitch(Name, kid);
}

bool InputProcessor::RegisterKeyboardAxis(const char * Name, const char *PositiveKeyName, const char *NegativeKeyName) {
	KeyId Positivekid;
	if (!g_KeyNamesTable.Find(PositiveKeyName, Positivekid)) {
		AddLogf(Warning, "Unknown key: %s", PositiveKeyName);
		return false;
	}
	KeyId Negativekid;
	if (!g_KeyNamesTable.Find(NegativeKeyName, Negativekid)) {
		AddLogf(Warning, "Unknown key: %s", NegativeKeyName);
		return false;
	}

	return AddKeyboardAxis(Name, Positivekid, Negativekid);
}

//---------------------------------------------------------------------------------------

int InputProcessor::luaIndexInput(lua_State *lua) {
	void *ThisPtr = lua_touserdata(lua, lua_upvalueindex(1));
	InputProcessor *This = reinterpret_cast<InputProcessor*>(ThisPtr);

	const char *name = lua_tostring(lua, -1);

	auto it = This->m_InputNames.find(name);
	if (it == This->m_InputNames.end()) {
		return 0;
	}

	auto &state = This->m_InputStates[it->second];
	if (!state.m_Flags.m_Valid) {
		AddLogf(Error, "Found invalid input state: %s", name);
		return 0;
	}

	switch (state.m_Type) {
	case InputState::Type::Switch:
		if (!state.m_Value.m_Boolean) {
			if (state.m_Revision == This->m_CurrentRevision) {
				lua_pushinteger(lua, (int)InputSwitchState::Released);
			} else {
				lua_pushinteger(lua, (int)InputSwitchState::Off);
			}
		} else {
			if (state.m_Revision == This->m_CurrentRevision) {
				lua_pushinteger(lua, (int)InputSwitchState::Pressed);
			} else {
				lua_pushinteger(lua, (int)InputSwitchState::On);
			}
		}
		return 1;
	case InputState::Type::FloatAxis:
		lua_pushnumber(lua, state.m_Value.m_Float);
		return 1;
	default:
		LogInvalidEnum(state.m_Type);
		return 0;
	}
}

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

KeyNamesTable::KeyNamesTable() {
#define set(V, N)	m_Array[V] = N
	set(GLFW_KEY_0				, "0"  );
	set(GLFW_KEY_1				, "1"  );
	set(GLFW_KEY_2				, "2"  );
	set(GLFW_KEY_3				, "3"  );
	set(GLFW_KEY_4				, "4"  );
	set(GLFW_KEY_5				, "5"  );
	set(GLFW_KEY_6				, "6"  );
	set(GLFW_KEY_7				, "7"  );
	set(GLFW_KEY_8				, "8"  );
	set(GLFW_KEY_9				, "9"  );
	set(GLFW_KEY_A				, "A"  );
	set(GLFW_KEY_B				, "B"  );
	set(GLFW_KEY_C				, "C"  );
	set(GLFW_KEY_D				, "D"  );
	set(GLFW_KEY_E				, "E"  );
	set(GLFW_KEY_F				, "F"  );
	set(GLFW_KEY_G				, "G"  );
	set(GLFW_KEY_H				, "H"  );
	set(GLFW_KEY_I				, "I"  );
	set(GLFW_KEY_J				, "J"  );
	set(GLFW_KEY_K				, "K"  );
	set(GLFW_KEY_L				, "L"  );
	set(GLFW_KEY_M				, "M"  );
	set(GLFW_KEY_N				, "N"  );
	set(GLFW_KEY_O				, "O"  );
	set(GLFW_KEY_P				, "P"  );
	set(GLFW_KEY_Q				, "Q"  );
	set(GLFW_KEY_R				, "R"  );
	set(GLFW_KEY_S				, "S"  );
	set(GLFW_KEY_T				, "T"  );
	set(GLFW_KEY_U				, "U"  );
	set(GLFW_KEY_V				, "V"  );
	set(GLFW_KEY_W				, "W"  );
	set(GLFW_KEY_X				, "X"  );
	set(GLFW_KEY_Y				, "Y"  );
	set(GLFW_KEY_Z				, "Z"  );
	set(GLFW_KEY_F1				, "F1" );
	set(GLFW_KEY_F2				, "F2" );
	set(GLFW_KEY_F3				, "F3" );
	set(GLFW_KEY_F4				, "F4" );
	set(GLFW_KEY_F5				, "F5" );
	set(GLFW_KEY_F6				, "F6" );
	set(GLFW_KEY_F7				, "F7" );
	set(GLFW_KEY_F8				, "F8" );
	set(GLFW_KEY_F9				, "F9" );
	set(GLFW_KEY_F10			, "F10");
	set(GLFW_KEY_F11			, "F11");
	set(GLFW_KEY_F12			, "F12");

	set(GLFW_KEY_SPACE			, " ");
	set(GLFW_KEY_APOSTROPHE		, "'");
	set(GLFW_KEY_COMMA			, ",");
	set(GLFW_KEY_MINUS			, "-");
	set(GLFW_KEY_PERIOD			, ".");
	set(GLFW_KEY_SLASH			, "/");
	set(GLFW_KEY_SEMICOLON		, ";");
	set(GLFW_KEY_EQUAL			, "=");
	set(GLFW_KEY_LEFT_BRACKET	, "[");
	set(GLFW_KEY_BACKSLASH		, "\\");
	set(GLFW_KEY_RIGHT_BRACKET	, "]");
	set(GLFW_KEY_GRAVE_ACCENT	, "`");
	set(GLFW_KEY_LEFT_SHIFT		, "Left shift");
	set(GLFW_KEY_LEFT_CONTROL	, "Left control");
	set(GLFW_KEY_LEFT_ALT		, "Left alt");
	set(GLFW_KEY_LEFT_SUPER		, "Left super");
	set(GLFW_KEY_RIGHT_SHIFT	, "Right shift");
	set(GLFW_KEY_RIGHT_CONTROL	, "Right control");
	set(GLFW_KEY_RIGHT_ALT		, "Right alt");
	set(GLFW_KEY_RIGHT_SUPER	, "Right super");
	set(GLFW_KEY_ESCAPE			, "Escape");
	set(GLFW_KEY_ENTER			, "Enter");
	set(GLFW_KEY_TAB			, "Tab");
	set(GLFW_KEY_BACKSPACE		, "Backspace");
	set(GLFW_KEY_INSERT			, "Insert");
	set(GLFW_KEY_DELETE			, "Delete");
	set(GLFW_KEY_RIGHT			, "Right");
	set(GLFW_KEY_LEFT			, "Left");
	set(GLFW_KEY_DOWN			, "Down");
	set(GLFW_KEY_UP				, "Up");
	set(GLFW_KEY_PAGE_UP		, "Page Up");
	set(GLFW_KEY_PAGE_DOWN		, "Page Down");
	set(GLFW_KEY_HOME			, "Home");
	set(GLFW_KEY_END			, "End");
	set(GLFW_KEY_CAPS_LOCK		, "Caps lock");
	set(GLFW_KEY_SCROLL_LOCK	, "Scroll lock");
	set(GLFW_KEY_NUM_LOCK		, "Num lock");
	set(GLFW_KEY_PRINT_SCREEN	, "Print screen");
	set(GLFW_KEY_PAUSE			, "Pause");
	set(GLFW_KEY_KP_0			, "Numpad 0");
	set(GLFW_KEY_KP_1			, "Numpad 1");
	set(GLFW_KEY_KP_2			, "Numpad 2");
	set(GLFW_KEY_KP_3			, "Numpad 3");
	set(GLFW_KEY_KP_4			, "Numpad 4");
	set(GLFW_KEY_KP_5			, "Numpad 5");
	set(GLFW_KEY_KP_6			, "Numpad 6");
	set(GLFW_KEY_KP_7			, "Numpad 7");
	set(GLFW_KEY_KP_8			, "Numpad 8");
	set(GLFW_KEY_KP_9			, "Numpad 9");
	set(GLFW_KEY_KP_DECIMAL		, "Numpad dot");
	set(GLFW_KEY_KP_DIVIDE		, "Numpad divide");
	set(GLFW_KEY_KP_MULTIPLY	, "Numpad multiply");
	set(GLFW_KEY_KP_SUBTRACT	, "Numpad subtrack");
	set(GLFW_KEY_KP_ADD			, "Numpad add");
	set(GLFW_KEY_KP_ENTER		, "Numpad enter");
	set(GLFW_KEY_KP_EQUAL		, "Numpad equal");
	set(GLFW_KEY_MENU			, "Menu");
	set(GLFW_KEY_WORLD_1		, "World 1");
	set(GLFW_KEY_WORLD_2		, "World 2");
#undef set
#define set_mouse(V, N)	m_Array[InputKeyOffsets::Mouse + V] = N
	set_mouse(GLFW_MOUSE_BUTTON_1, "Mouse button Left");
	set_mouse(GLFW_MOUSE_BUTTON_2, "Mouse button Right");
	set_mouse(GLFW_MOUSE_BUTTON_3, "Mouse button Middle");
	set_mouse(GLFW_MOUSE_BUTTON_4, "Mouse button 4");
	set_mouse(GLFW_MOUSE_BUTTON_5, "Mouse button 5");
	set_mouse(GLFW_MOUSE_BUTTON_6, "Mouse button 6");
	set_mouse(GLFW_MOUSE_BUTTON_7, "Mouse button 7");
	set_mouse(GLFW_MOUSE_BUTTON_8, "Mouse button 8");
#undef set_mouse

#if 0
#define          7
#define GLFW_MOUSE_BUTTON_LAST      GLFW_MOUSE_BUTTON_8
#define GLFW_MOUSE_BUTTON_LEFT      GLFW_MOUSE_BUTTON_1
#define GLFW_MOUSE_BUTTON_RIGHT     GLFW_MOUSE_BUTTON_2
#define GLFW_MOUSE_BUTTON_MIDDLE    GLFW_MOUSE_BUTTON_3

#endif
}

} //namespace Core 
} //namespace MoonGlare 
