/*
  * Generated by cppsrc.sh
  * On 2016-08-04 19:45:53,67
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>
#include "InputProcessor.h"
#include <Utils/LuaUtils.h>

#include <Input.x2c.h>

namespace MoonGlare {
namespace Core {

//RegisterApiNonClass(InputProcessor, &InputProcessor::RegisterScriptApi, "Input");

InputProcessor::InputProcessor() {
	m_World = nullptr;
	ResetToInternalDefault();
}

InputProcessor::~InputProcessor() {

}

//---------------------------------------------------------------------------------------

void InputProcessor::RegisterScriptApi(ApiInitializer &root) {

	//	root
	//		.addCFunction()

}

//---------------------------------------------------------------------------------------

bool InputProcessor::Initialize(World *world) {
	m_World = world;
	{
		auto *se = m_World->GetScriptEngine();
		auto lua = se->GetLua();
		LOCK_MUTEX_NAMED(se->GetLuaMutex(), lock);
		Utils::Scripts::LuaStackOverflowAssert check(lua);

		lua_createtable(lua, 0, 0);					// stack: selftable
		MoonGlare::Core::Scripts::PublishSelfLuaTable(lua, "InputProcessor", this, -1);
		lua_pushlightuserdata(lua, (void *)this);	// stack: selftable selfptr
		lua_pushvalue(lua, -2);		  				// stack: selftable selfptr selftable
		lua_settable(lua, LUA_REGISTRYINDEX);		// stack: selftable

		lua_pushlightuserdata(lua, (void *)this);	// stack: selftable selfptr
		lua_pushcclosure(lua, &InputProcessor::luaIndexInput, 1);// stack: selftable cclosure
		lua_setfield(lua, -2, "__index");			// stack: selftable

		lua_createtable(lua, 0, 0);					// stack: selftable InputTable
		lua_insert(lua, -2);						// stack: InputTable selftable 
		lua_setmetatable(lua, -2);					// stack: InputTable
		lua_setglobal(lua, "Input");				// stack:
	}

	pugi::xml_document doc;
	if (doc.load_file(Configuration::Input::SettingsFileName)) {
		if (!Load(doc.document_element())) {
			AddLog(Error, "Failed to load input configuration");
			return false;
		}
		AddLogf(Info, "Loaded InputConfiguration from: %s", Configuration::Input::SettingsFileName);
	}

	return true;
}

bool InputProcessor::Finalize() {
	{
		auto *se = m_World->GetScriptEngine();
		auto lua = se->GetLua();
		LOCK_MUTEX_NAMED(se->GetLuaMutex(), lock);
		Utils::Scripts::LuaStackOverflowAssert check(lua);

		lua_pushlightuserdata(lua, (void *)this);
		lua_pushnil(lua);
		lua_settable(lua, LUA_REGISTRYINDEX);

		lua_pushnil(lua);
		lua_setglobal(lua, "Input");	

		MoonGlare::Core::Scripts::HideSelfLuaTable(lua, "InputProcessor", this);
	}
	return true;
}

//---------------------------------------------------------------------------------------

void InputProcessor::ProcessKeyState(unsigned Id, bool Pressed) {
	THROW_ASSERT(Id < Configuration::Input::MaxKeyCode, "Key code id overflow!");
	//AddLogf(Debug, "Processing key: %u:%d", Id, Pressed ? 1 : 0);

	auto &keyinfo = m_Keys[Id];
	if (!keyinfo.m_Flags.m_Valid) 
		return;
	
	auto &state = m_InputStates[keyinfo.m_Id];

	//AddLogf(Debug, "State:%u currkey:%u value:%f", Id, state.m_ActiveKeyId, state.m_Value.m_Float);

	if (Pressed || state.m_ActiveKeyId == Id || state.m_ActiveKeyId == Configuration::Input::MaxKeyCode) { 
		//while handling key release do not update state if it is changed by other key
		switch (state.m_Type) {
		case InputState::Type::Switch:
			state.m_Value.m_Boolean = Pressed;
			break;
		case InputState::Type::FloatAxis:
			state.m_Value.m_Float = Pressed ? keyinfo.m_Value.m_Float : 0.0f;
			break;
		default:
			LogInvalidEnum(state.m_Type);
			return;
		}
	}
	state.m_ActiveKeyId = Pressed ? Id : Configuration::Input::MaxKeyCode;
}

void InputProcessor::ProcessMouseAxis(MouseAxisId Id, float Delta) {
	THROW_ASSERT(Id <MouseAxisId::Unknown, "Mouse axis id overflow!");
	//AddLogf(Debug, "Processing mouse axis: %d:%f", Id, Delta);

	auto &axis = m_MouseAxes[static_cast<size_t>(Id)];
	if (!axis.m_Flags.m_Valid)
		return;
	auto &state = m_InputStates[axis.m_Id];
	if (!state.m_Flags.m_Valid || state.m_Type != InputState::Type::FloatAxis) {
		AddLog(Error, "Invalid Input state or invalid state type!");
		return;
	}
	
	state.m_Value.m_Float = Delta * axis.m_Sensitivity;
}

void InputProcessor::ClearStates() {
	for (auto &it : m_MouseAxes) {
		if (!it.m_Flags.m_Valid)
			continue;
		m_InputStates[it.m_Id].m_Value.m_Float = 0.0f;
	}
}

//---------------------------------------------------------------------------------------

bool InputProcessor::Save(pugi::xml_node node) const {
	x2c::Core::Input::InputConfiguration_t conf;
	for (auto &it : m_MouseAxes) {
		if (!it.m_Flags.m_Valid)
			continue;

		x2c::Core::Input::MouseAxis_t ma;
		ma.m_AxisId = static_cast<MouseAxisId>(&it - &m_MouseAxes[0]);
		ma.m_Sensitivity = it.m_Sensitivity;
		switch (ma.m_AxisId) {
		case MouseAxisId::X:
		case MouseAxisId::Y:
			ma.m_Sensitivity /= Configuration::Input::StaticMouseSensivity;
			break;
		case MouseAxisId::ScrollX:
		case MouseAxisId::ScrollY:
			ma.m_Sensitivity /= Configuration::Input::StaticMouseScrollSensivity;
			break;
		default:
			LogInvalidEnum(ma.m_AxisId);
			break;
		}
		GetInputStateName(it.m_Id, ma.m_Name);
		conf.m_MouseAxes.push_back(std::move(ma));
	}

	std::unordered_map<InputStateId, std::list<const KeyAction*>> KeyActionsMap;

	for (auto &it : m_Keys) {
		if (!it.m_Flags.m_Valid)
			continue;
		KeyActionsMap[it.m_Id].push_back(&it);
	}

	for (auto &it : KeyActionsMap) {
		auto &list = it.second;
		auto &state = m_InputStates[it.first];

		if (!state.m_Flags.m_Valid) {
			//just to be sure
			continue;
		}

		switch (state.m_Type) {
		case InputState::Type::Switch: {
			x2c::Core::Input::KeyboardSwitch_t sw;
			GetInputStateName(it.first, sw.m_Name);
			for (auto key : list) {
				auto index = static_cast<KeyId>(key - &m_Keys[0]);
				sw.m_Keys.push_back(index);
			}
			conf.m_KeyboardSwitches.push_back(std::move(sw));
			break;
		}
		case InputState::Type::FloatAxis:{
			x2c::Core::Input::KeyboardAxis_t ka;
			GetInputStateName(it.first, ka.m_Name);
			for (auto key : list) {
				auto index = static_cast<KeyId>(key - &m_Keys[0]);
				if (key->m_Flags.m_Positive)
					ka.m_NegativeKeys.push_back(index);
				else
					ka.m_PositiveKeys.push_back(index);
			}
			conf.m_KeyboardAxes.push_back(std::move(ka));
			break;
		}
		default:
			LogInvalidEnum(state.m_Type);
			continue;
		}
	}

	return conf.Write(node);
}

bool InputProcessor::Load(const pugi::xml_node node) {
	Clear();
	x2c::Core::Input::InputConfiguration_t conf;
	if (!conf.Read(node)) {
		AddLog(Error, "Failed to read input configuration!");
		return false;
	}

	for (auto &it : conf.m_KeyboardSwitches) {
		InputStateId InputIndex;
		if (!AllocInputState(InputState::Type::Switch, it.m_Name, InputIndex)) {
			//no need for more logging
			return false;
		}
		for (auto key : it.m_Keys) {
			AllocKeyAction(key, InputIndex, true);
		}
	}

	for (auto &it : conf.m_KeyboardAxes) {
		InputStateId InputIndex;
		if (!AllocInputState(InputState::Type::FloatAxis, it.m_Name, InputIndex)) {
			//no need for more logging
			return false;
		}
		for (auto key : it.m_PositiveKeys) {
			AllocKeyAction(key, InputIndex, true);
		}
		for (auto key : it.m_NegativeKeys) {
			AllocKeyAction(key, InputIndex, false);
		}
	}

	for (auto &it : conf.m_MouseAxes) {
		AddMouseAxis(it.m_Name.c_str(), it.m_AxisId, it.m_Sensitivity);
	}

	AddLog(Info, "Loaded input configuration");
	return true;
}

void InputProcessor::Clear() {
	m_InputStates.MemZeroAndClear();
	Space::MemZero(m_MouseAxes);
	Space::MemZero(m_Keys);
	m_InputNames.clear();
}

void InputProcessor::ResetToInternalDefault() {
	Clear();

	//AddKeyboardAxis("Forward", GLFW_KEY_UP, GLFW_KEY_DOWN);
	//AddKeyboardAxis("SideStep", GLFW_KEY_LEFT, GLFW_KEY_RIGHT);

	AddKeyboardAxis("Forward", GLFW_KEY_W, GLFW_KEY_S);
	AddKeyboardAxis("SideStep", GLFW_KEY_A, GLFW_KEY_D);

	AddKeyboardSwitch("Run", GLFW_KEY_LEFT_SHIFT);

	AddMouseAxis("Turn", MouseAxisId::X, 0.5f);
	AddMouseAxis("LookAngle", MouseAxisId::Y, 0.5f);
}

bool InputProcessor::GetInputStateName(InputStateId isid, std::string &out) const {
	for(auto &it: m_InputNames)
		if (it.second == isid) {
			out = it.first;
			return true;
		}
	out = "?";
	return false;
}

//---------------------------------------------------------------------------------------

InputState* InputProcessor::AllocInputState(InputState::Type type, const std::string &Name, InputStateId &outindex) {
	size_t idx;
	if (!m_InputStates.Allocate(idx)) {
		AddLog(Error, "No more space to add keyboard axis");
		return nullptr;
	}

	outindex = static_cast<InputStateId>(idx);

	auto &state = m_InputStates[outindex];
	state.m_Flags.m_Valid = true;
	state.m_Type = type;

	switch (state.m_Type) {
	case InputState::Type::Switch:
		state.m_Value.m_Boolean = false;
		break;
	case InputState::Type::FloatAxis:
		state.m_Value.m_Float = 0.0f;
		break;
	default:
		LogInvalidEnum(state.m_Type);
		break;
	}

	m_InputNames[Name] = static_cast<InputStateId>(outindex);
	return &state;
}

KeyAction* InputProcessor::AllocKeyAction(KeyId kid, InputStateId isid, bool Positive) {
	THROW_ASSERT(kid < Configuration::Input::MaxKeyCode, "KeyId overflow!");
	auto &key = m_Keys[kid];
	key.m_Flags.m_Valid = true;
	key.m_Flags.m_Positive = Positive;
	key.m_Id = isid;

	auto &state = m_InputStates[isid];

	switch (state.m_Type) {
	case InputState::Type::Switch:
		key.m_Value.m_Boolean = Positive;
		break;
	case InputState::Type::FloatAxis:
		key.m_Value.m_Float = Positive ? 1.0f : -1.0f;
		break;
	default:
		LogInvalidEnum(state.m_Type);
		break;
	}
	return &key;
}

AxisAction* InputProcessor::AllocMouseAxis(MouseAxisId maid, InputStateId isid, float Sensitivity) {
	auto &axis = m_MouseAxes[static_cast<size_t>(maid)];
	axis.m_Flags.m_Valid = true;
	axis.m_Sensitivity = Sensitivity;
	axis.m_Id = isid;

	switch (maid) {
	case MouseAxisId::X:
	case MouseAxisId::Y:
		axis.m_Sensitivity *= Configuration::Input::StaticMouseSensivity;
		break;
	case MouseAxisId::ScrollX:
	case MouseAxisId::ScrollY:
		axis.m_Sensitivity *= Configuration::Input::StaticMouseScrollSensivity;
		break;
	default:
		LogInvalidEnum(maid);
		break;
	}
	return &axis;
}

bool InputProcessor::AddKeyboardAxis(const char *Name, KeyId PositiveKey, KeyId NegativeKey) {
	THROW_ASSERT(PositiveKey < Configuration::Input::MaxKeyCode, "PositiveKey id overflow!");
	THROW_ASSERT(NegativeKey < Configuration::Input::MaxKeyCode, "NegativeKey id overflow!");

	InputStateId InputIndex;
	if (!AllocInputState(InputState::Type::FloatAxis, Name, InputIndex)) {
		//no need for more logging
		return false;
	}

	AllocKeyAction(PositiveKey, InputIndex, true);
	AllocKeyAction(NegativeKey, InputIndex, false);

	return true;
}

bool InputProcessor::AddKeyboardSwitch(const char *Name, KeyId Key) {
	THROW_ASSERT(Key < Configuration::Input::MaxKeyCode, "Key id overflow!");

	InputStateId InputIndex;
	if (!AllocInputState(InputState::Type::Switch, Name, InputIndex)) {
		//no need for more logging
		return false;
	}
	AllocKeyAction(Key, InputIndex, true);

	return true;
}

bool InputProcessor::AddMouseAxis(const char *Name, MouseAxisId axisid, float Sensitivity) {
	THROW_ASSERT(axisid < MouseAxisId::Unknown, "MouseAxisId overflow!");

	InputStateId InputIndex;
	if (!AllocInputState(InputState::Type::FloatAxis, Name, InputIndex)) {
		//no need for more logging
		return false;
	}
	AllocMouseAxis(axisid, InputIndex, Sensitivity);

	return true;
}

//---------------------------------------------------------------------------------------

int InputProcessor::luaIndexInput(lua_State *lua) {
	void *ThisPtr = lua_touserdata(lua, lua_upvalueindex(1));
	InputProcessor *This = reinterpret_cast<InputProcessor*>(ThisPtr);

	const char *name = lua_tostring(lua, -1);

	auto it = This->m_InputNames.find(name);
	if (it == This->m_InputNames.end()) {
		return 0;
	}

	auto &state = This->m_InputStates[it->second];
	if (!state.m_Flags.m_Valid) {
		AddLogf(Error, "Found invalid input state: %s", name);
		return 0;
	}

	switch (state.m_Type) {
	case InputState::Type::Switch:
		lua_pushboolean(lua, state.m_Value.m_Boolean);
		return 1;
	case InputState::Type::FloatAxis:
		lua_pushnumber(lua, state.m_Value.m_Float);
		return 1;
	default:
		LogInvalidEnum(state.m_Type);
		return 0;
	}
}

} //namespace Core 
} //namespace MoonGlare 
