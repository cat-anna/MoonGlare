/*
  * Generated by cppsrc.sh
  * On 2016-07-28 19:21:16,18
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>
#include "ResourceTable.h"

namespace MoonGlare {
namespace Core {

ResourceTable::ResourceTable()
		: m_Allocator(Space::NoConstruct) {
	DebugMemorySetClassName("ResourceTable");
	DebugMemoryRegisterCounter("HandleUsage", [this](DebugMemoryCounter& counter) {
		counter.Allocated = m_Allocator.Allocated();
		counter.Capacity = m_Allocator.Capacity();
		counter.ElementSize = sizeof(ResourceEntry);
	});
}

ResourceTable::~ResourceTable() {
}

bool ResourceTable::Initialize() {
	m_Array.fill(ResourceEntry());
//	Space::MemZero(m_Array);
	m_Allocator.Rebuild();
	return true;
}

bool ResourceTable::Finalize() {
	return true;
}

bool ResourceTable::Allocate(DataClasses::ModelPtr model, Handle &hout) {
	Handle h;
	if (!m_Allocator.Allocate(h)) {
		AddLogf(Error, "Failed to allocate handle!");
		return false;
	}

	h.SetType(Configuration::HandleType::Resource);
	auto &item = m_Array[h.GetIndex()];
	item.m_Model = std::move(model);
	item.m_Flags.m_Map.m_Valid = true;
	hout = h;
	return true;
}

bool ResourceTable::IsValid(Handle h) {
	if (h.GetType() != Configuration::HandleType::Resource) {
		return false;
	}
	if (!m_Allocator.IsHandleValid(h)) {
		return false;
	}

	//auto index = h.GetIndex();
	//auto &item = m_Array[index];
	
	//if (!item.m_Flags.m_Map.m_vHasEntityOwner) {
	//	return true;
	//}
	//
	//if (!m_EntityManager->IsValid(item.m_Owner)) {
	//	m_Allocator.Free(h);
	//	return false;
	//}

	return true;
}

DataClasses::ModelPtr ResourceTable::GetModel(Handle h) {
	if (!IsValid(h)) {
		AddLogf(Warning, "Attempt to get resource by invalid handle!");
		return nullptr;
	}
	auto index = h.GetIndex();
	auto &item = m_Array[index];
	return item.m_Model;
}

#if 0
bool ResourceTable::IsValid(ComponentID cid, Handle h) {
	if (h.GetType() != Configuration::HandleType::Component) {
		return false;
	}
	if (!m_Allocator.IsHandleValid(h)) {
		return false;
	}

	auto index = h.GetIndex();
	auto &item = m_Array[index];
	if (item.m_OwnerCID != cid) {
		return false;
	}
	if (!item.m_Flags.m_Map.m_HasEntityOwner) {
		return true;
	}

	if (!m_EntityManager->IsValid(item.m_Owner)) {
		m_Allocator.Free(h);
		return false;
	}

	return true;
}

bool ResourceTable::Allocate(ComponentID cid, Handle &hout, HandleIndex index, HandlePrivateData value) {
	Handle h;
	if (!m_Allocator.Allocate(h)) {
		AddLogf(Error, "Failed to allocate handle!");
		return false;
	}

	hout.SetType(Configuration::HandleType::Component);
	m_Allocator.SetMapping(hout, index);
	auto &item = m_Array[hout.GetIndex()];
	item.m_Data = value;
	item.m_OwnerCID = cid;
	item.m_Flags.m_UIntValue = 0;
	item.m_Flags.m_Map.m_HasEntityOwner = false;
	return true;
}

bool ResourceTable::Allocate(ComponentID cid, Entity Owner, Handle &hout, HandleIndex index, HandlePrivateData value) {
	if (!m_EntityManager->IsValid(Owner)) {
		AddLog(Warning, "Attempt to allocate handle for invalid entity");
		return false;
	}

	if (!m_Allocator.Allocate(hout)) {
		AddLogf(Error, "Failed to allocate handle!");
		return false;
	}
	
	hout.SetType(Configuration::HandleType::Component);
	m_Allocator.SetMapping(hout, index);
	auto &item = m_Array[hout.GetIndex()];
	item.m_Data = value;
	item.m_Owner = Owner;
	item.m_OwnerCID = cid;
	item.m_Flags.m_UIntValue = 0;
	item.m_Flags.m_Map.m_HasEntityOwner = true;

	return true;
}

bool ResourceTable::Release(ComponentID cid, Handle h) {
	if (h.GetType() != Configuration::HandleType::Component) {
		return false;
	}
	if (!m_Allocator.IsHandleValid(h)) {
		//silently ignore;
		return true;
	}
	
	m_Allocator.Free(h);

	return false;
}

bool ResourceTable::GetHandleIndex(ComponentID cid, Handle h, HandleIndex & index) {
	if (!IsValid(cid, h)) {
		return false;
	}
	return m_Allocator.GetMapping(h, index);
}

bool ResourceTable::SetHandleIndex(ComponentID cid, Handle h, HandleIndex index) {
	if (!IsValid(cid, h)) {
		return false;
	}
	return m_Allocator.SetMapping(h, index);
}

bool ResourceTable::GetHandleParentEntity(ComponentID cid, Handle h, Entity &eout) {
	if (!IsValid(cid, h)) {
		return false;
	}
	auto &item = m_Array[h.GetIndex()];
	eout = item.m_Owner;
	return true;
}

bool ResourceTable::SwapHandleIndexes(ComponentID cid, Handle ha, Handle hb) {
	if (!IsValid(cid, ha) || !IsValid(cid, hb)) {
		return false;
	}
	HandleIndex hia, hib;
	if (!m_Allocator.GetMapping(ha.GetIndex(), hia) || !m_Allocator.GetMapping(hb.GetIndex(), hib)) {
		return false;
	}
	m_Allocator.SetMapping(ha.GetIndex(), hib);
	m_Allocator.SetMapping(hb.GetIndex(), hia);
	return true;
}
#endif

} //namespace Core 
} //namespace MoonGlare 
