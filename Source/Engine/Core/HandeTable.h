/*
  * Generated by cppsrc.sh
  * On 2016-07-28 19:21:16,18
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef HandeTable_H
#define HandeTable_H

#include "EntityManager.h"

namespace MoonGlare {
namespace Core {

class HandeTable final 
	: public Config::Current::DebugMemoryInterface {
public:
 	HandeTable();
 	~HandeTable();

	bool Initialize(EntityManager *EntityManager);
	bool Finalize();

	using HandlePrivateData = uint64_t;

	bool IsValid(Handle h);
	bool Allocate(Handle &hout, uint16_t Type, HandleIndex index, HandlePrivateData value = 0);
	bool Allocate(Entity Owner, Handle &hout, uint16_t Type, HandleIndex index, HandlePrivateData value = 0);
	bool Release(Handle h);

	//below function return false if handle or owner entity is not valid
	bool GetHandleIndex(Handle h, HandleIndex &index);
	bool SetHandleIndex(Handle h, HandleIndex index);

	bool GetHandleData(Handle h, HandlePrivateData &value);
	bool SetHandleData(Handle h, HandlePrivateData value);

	union HandleFlags {
		struct {
			bool m_HasEntityOwner;
		} m_Map;
		uint8_t m_UIntValue;
	};

	struct HandleEntry {
		Entity m_Owner;
		uint16_t m_Type;
		HandleFlags m_Flags;
		HandlePrivateData m_Data;
	};

	static_assert(sizeof(HandleEntry) == 16, "HandleEntry has invalid size!");
protected:
	template<class ... ARGS>
	using GenerationsAllocator_t = Space::Memory::StaticMultiAllocator<Configuration::Handle::IndexLimit, ARGS...>;
	using Generations_t = Space::Memory::GenerationRandomBuffer<GenerationsAllocator_t, Handle>;
	template<class T> using Array = std::array<T, Configuration::Handle::IndexLimit>;

	Array<HandleEntry> m_Array;
	Generations_t m_Allocator;
	EntityManager *m_EntityManager;
};

} //namespace Core 
} //namespace MoonGlare 

#endif
