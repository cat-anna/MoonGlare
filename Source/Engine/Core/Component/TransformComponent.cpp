/*
  * Generated by cppsrc.sh
  * On 2015-10-25 21:57:04,09
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <nfMoonGlare.h>
#include "ComponentManager.h"
#include "ComponentRegister.h"
#include "AbstractComponent.h"
#include "TransformComponent.h"

namespace MoonGlare {
namespace Core {
namespace Component {

::Space::RTTI::TypeInfoInitializer<TransformComponent, TransformComponent::TransformEntry> TransformComponentTypeInfo;
RegisterComponentID<TransformComponent> TransformComponentIDReg("Transform", true, &TransformComponent::RegisterScriptApi);

TransformComponent::TransformComponent(ComponentManager * Owner) 
		: AbstractComponent(Owner) {

	DebugMemorySetParent(GetManager());
	DebugMemorySetClassName("TransformComponent");
	DebugMemoryRegisterCounter("IndexUsage", [this](DebugMemoryCounter& counter) {
		counter.Allocated = m_Array.Allocated();
		counter.Capacity = m_Array.Capacity();
		counter.ElementSize = sizeof(TransformEntry);
	});
}

TransformComponent::~TransformComponent() {}

//---------------------------------------------------------------------------------------

void TransformComponent::RegisterScriptApi(ApiInitializer &root) {
	root
	.beginClass<TransformEntry>("cTransformComponentEntry")
		.addProperty("Position", &TransformEntry::GetPosition, &TransformEntry::SetPosition)
		.addProperty("Rotation", &TransformEntry::GetRotation, &TransformEntry::SetRotation)
		.addProperty("Scale", &TransformEntry::GetScale, &TransformEntry::SetScale)
	.endClass()
	;
}

bool TransformComponent::PushEntryToLua(Handle h, lua_State *lua, int &luarets) {
	auto entry = GetEntry(h);
	if (!entry) {
		return true;
	}

	luarets = 1;
	luabridge::Stack<TransformEntry*>::push(lua, entry);

	return true;
}

//------------------------------------------------------------------------------------------

bool TransformComponent::Initialize() {
	memset(&m_Array, 0, m_Array.Capacity() * sizeof(m_Array[0]));
	m_CurrentRevision = 1;

	m_Array.ClearAllocation();

	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}
	auto &RootEntry = m_Array[index];
	RootEntry.m_Flags.ClearAll();
	RootEntry.m_Flags.m_Map.m_Valid = true;
	auto *EntityManager = GetManager()->GetWorld()->GetEntityManager();
	RootEntry.m_OwnerEntity = EntityManager->GetRootEntity();
	RootEntry.m_GlobalMatrix = math::mat4();
	RootEntry.m_LocalScale = Physics::vec3(1, 1, 1);
	RootEntry.m_GlobalScale = Physics::vec3(1, 1, 1);
	RootEntry.m_Revision = m_CurrentRevision;
	RootEntry.m_LocalTransform.setOrigin(Physics::vec3(0,0,0));
	RootEntry.m_LocalTransform.setRotation(Physics::Quaternion(0, 0, 0, 1));
	RootEntry.m_GlobalTransform = RootEntry.m_LocalTransform;

	auto *ht = GetManager()->GetWorld()->GetHandleTable();
	Handle h;
	if (!ht->Allocate(this, RootEntry.m_OwnerEntity, h, index)) {
		AddLog(Error, "Failed to allocate root handle");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}

	m_EntityMapper.SetHandle(RootEntry.m_OwnerEntity, h);

	return true;
}

bool TransformComponent::Finalize() {
	return true;
}

void TransformComponent::Step(const MoveConfig & conf) {
	auto *EntityManager = GetManager()->GetWorld()->GetEntityManager();
	auto *HandleTable = GetManager()->GetWorld()->GetHandleTable();

	size_t LastInvalidEntry = 0;
	size_t InvalidEntryCount = 0;

	for (size_t i = 1; i < m_Array.Allocated(); ++i) {//ignore root entry
		auto &item = m_Array[i];

		if (!item.m_Flags.m_Map.m_Valid) {
			//mark and continue
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}

		if (!HandleTable->IsValid(this, item.m_SelfHandle)) {
			item.m_Flags.m_Map.m_Valid = false;
			LastInvalidEntry = i;
			++InvalidEntryCount;
			//mark and continue but set valid to false to avoid further checks
			continue;
		}

		Entity ParentEntity;
		if (EntityManager->GetParent(item.m_OwnerEntity, ParentEntity)) {
			auto *ParentEntry = GetEntry(ParentEntity);

			if (ParentEntry->m_Revision <= item.m_Revision && m_CurrentRevision > 1) {
				//nothing to do, nothing changed;
			} else {
				item.Recalculate(ParentEntry);
				item.m_Revision = m_CurrentRevision;
			}
		//	item.m_GlobalScale = ParentEntry->m_GlobalScale * item.m_LocalScale;
		} else {
			item.m_Flags.m_Map.m_Valid = false;
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
			//mark and continue but set valid to false to avoid further processing
		}
	}

	if (InvalidEntryCount > 0) {
		AddLogf(Performance, "TransformComponent:%p InvalidEntryCount:%lu LastInvalidEntry:%lu", this, InvalidEntryCount, LastInvalidEntry);
		ReleaseElement(LastInvalidEntry);
	}

	++m_CurrentRevision;
	if (m_CurrentRevision < 1) {
		m_CurrentRevision = 1;
	}
}

bool TransformComponent::Load(xml_node node, Entity Owner, Handle &hout) {
	Handle &h = hout;
	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}
	auto &entry = m_Array[index];
	entry.m_Flags.ClearAll();
	if (!GetHandleTable()->Allocate(this, Owner, h, index)) {
		AddLog(Error, "Failed to allocate handle");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}

	Entity Parent;
	if (!GetManager()->GetWorld()->GetEntityManager()->GetParent(Owner, Parent)) {
		AddLog(Error, "Failed to get Parent!");
		return false;
	}
	//AddLog(Hint, "New transform: selfE:" << Owner << "  selfH:" << h << "  Parent:" << Parent);
	auto ParentEntry = GetEntry(Parent);
	if (!ParentEntry) {
		AddLog(Error, "Failed to get ParentEntry!");
		return false;
	}

	entry.m_Flags.m_Map.m_Dirty = true;

	Physics::vec3 pos;
	XML::Vector::Read(node, "Position", pos);
	entry.m_LocalTransform.setOrigin(pos);
	entry.m_LocalTransform.setRotation(Physics::Quaternion(0, 0, 0, 1));
	entry.m_GlobalTransform = entry.m_LocalTransform;
	XML::Vector::Read(node, "Scale", entry.m_LocalScale, Physics::vec3(1, 1, 1));

	entry.m_GlobalScale = entry.m_LocalScale;
	entry.m_SelfHandle = h;
	entry.m_OwnerEntity = Owner;

	entry.Recalculate(ParentEntry);
	entry.m_Revision = m_CurrentRevision;

	m_EntityMapper.SetHandle(Owner, h);
	entry.m_Flags.m_Map.m_Valid = true;
	return true;
}

TransformComponent::TransformEntry* TransformComponent::GetEntry(Handle h) {
	auto *ht = GetManager()->GetWorld()->GetHandleTable();
	HandleIndex hi;
	if (!ht->GetHandleIndex(this, h, hi)) {
		//AddLog(Debug, "Attempt to get TransformEntry for invalid Entity!");
		return nullptr;
	}
	return &m_Array[hi];
}

TransformComponent::TransformEntry* TransformComponent::GetEntry(Entity e) {
	return GetEntry(m_EntityMapper.GetHandle(e));
}

bool TransformComponent::GetInstanceHandle(Entity Owner, Handle &hout) {
	auto h = m_EntityMapper.GetHandle(Owner);
	if (!GetHandleTable()->IsValid(this, h)) {
		return false;
	}
	hout = h;
	return true;
}

void TransformComponent::ReleaseElement(size_t Index) {
	auto lastidx = m_Array.Allocated() - 1;

	if (lastidx == Index) {
		auto &last = m_Array[lastidx];
		GetHandleTable()->Release(this, last.m_SelfHandle); // handle may be already released; no need to check for failure
		last.Reset();
	} else {
		auto &last = m_Array[lastidx];
		auto &item = m_Array[Index];

		std::swap(last, item);

		if (!GetHandleTable()->SetHandleIndex(this, item.m_SelfHandle, Index)) {
			AddLogf(Error, "Failed to move TransformComponent handle index!");
		}
		GetHandleTable()->Release(this, last.m_SelfHandle); // handle may be already released; no need to check for failure
		last.Reset();
	}
	m_Array.DeallocateLast();
}

//-------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------

void TransformComponent::TransformEntry::Recalculate(const TransformComponent::TransformEntry *Parent) {
	auto &gm = m_GlobalMatrix;
	auto &lm = m_LocalMatrix;
	m_LocalTransform.getOpenGLMatrix((float*)&lm);

	lm[0] *= m_LocalScale[0];
	lm[1] *= m_LocalScale[1];
	lm[2] *= m_LocalScale[2];

	gm = Parent->m_GlobalMatrix * lm;
	m_GlobalTransform = Parent->m_GlobalTransform * m_LocalTransform;
	m_GlobalScale = m_LocalScale * Parent->m_GlobalScale;
	//.setFromOpenGLMatrix(&gm[0][0]);

	m_Flags.m_Map.m_Dirty = false;
}

} //namespace Component 
} //namespace Core 
} //namespace MoonGlare 
