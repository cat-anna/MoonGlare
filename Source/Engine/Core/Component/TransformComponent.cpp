/*
  * Generated by cppsrc.sh
  * On 2015-10-25 21:57:04,09
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <nfMoonGlare.h>
#include "ComponentManager.h"
#include "ComponentRegister.h"
#include "AbstractComponent.h"
#include "TransformComponent.h"

namespace MoonGlare {
namespace Core {
namespace Component {

RegisterApiNonClass(TransformComponent, &TransformComponent::RegisterScriptApi);
RegisterComponentID<TransformComponent> TransformComponentIDReg("Transform");

TransformComponent::TransformComponent(ComponentManager * Owner) 
		: AbstractComponent(Owner) {

	DebugMemorySetClassName("TransformComponent");
	DebugMemoryRegisterCounter("IndexUsage", [this](DebugMemoryCounter& counter) {
		counter.Allocated = m_Array.Allocated();
		counter.Capacity = m_Array.Capacity();
		counter.ElementSize = sizeof(TransformEntry);
	});
}

TransformComponent::~TransformComponent() {}

//---------------------------------------------------------------------------------------

void TransformComponent::RegisterScriptApi(ApiInitializer &root) {
	root
	.beginClass<TransformEntry>("cTransformComponentEntry")
		.addProperty("Position", &TransformEntry::GetPosition, &TransformEntry::SetPosition)
		.addProperty("Rotation", &TransformEntry::GetRotation, &TransformEntry::SetRotation)
		.addProperty("Scale", &TransformEntry::GetScale, &TransformEntry::SetScale)
	.endClass()
	;
}

bool TransformComponent::PushEntryToLua(Handle h, lua_State *lua, int &luarets) {
	auto entry = GetEntry(h);
	if (!entry) {
		return true;
	}

	luarets = 1;
	luabridge::Stack<TransformEntry*>::push(lua, entry);

	return true;
}

//------------------------------------------------------------------------------------------

bool TransformComponent::Initialize() {
	memset(&m_Array, 0, m_Array.Capacity() * sizeof(m_Array[0]));
	m_CurrentRevision = 1;

	m_Array.ClearAllocation();

	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}
	auto &RootEntry = m_Array[index];
	RootEntry.m_Flags.ClearAll();
	RootEntry.m_Flags.m_Map.m_Valid = true;
	auto *EntityManager = GetManager()->GetWorld()->GetEntityManager();
	RootEntry.m_OwnerEntity = EntityManager->GetRootEntity();
	RootEntry.m_GlobalMatrix = math::mat4();
	RootEntry.m_Scale = Physics::vec3(1, 1, 1);
	RootEntry.m_Revision = m_CurrentRevision;
	RootEntry.m_LocalTransform.setOrigin(Physics::vec3(0,0,0));
	RootEntry.m_LocalTransform.setRotation(Physics::Quaternion(0, 0, 0, 1));
	RootEntry.m_GlobalTransform = RootEntry.m_LocalTransform;

	auto *ht = GetManager()->GetWorld()->GetHandleTable();
	Handle h;
	if (!ht->Allocate(this, RootEntry.m_OwnerEntity, h, index)) {
		AddLog(Error, "Failed to allocate root handle");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}

	m_EntityMapper.SetHandle(RootEntry.m_OwnerEntity, h);

	return true;
}

bool TransformComponent::Finalize() {
	return true;
}

void TransformComponent::Step(const MoveConfig & conf) {
	auto *EntityManager = GetManager()->GetWorld()->GetEntityManager();
	auto *HandleTable = GetManager()->GetWorld()->GetHandleTable();

	size_t LastInvalidEntry = 0;
	size_t InvalidEntryCount = 0;

	for (size_t i = 1; i < m_Array.Allocated(); ++i) {//ignore root entry
		auto &item = m_Array[i];

		if (!item.m_Flags.m_Map.m_Valid) {
			//mark and continue
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}

		if (!HandleTable->IsValid(this, item.m_SelfHandle)) {
			item.m_Flags.m_Map.m_Valid = false;
			LastInvalidEntry = i;
			++InvalidEntryCount;
			//mark and continue but set valid to false to avoid further checks
			continue;
		}

		Entity ParentEntity;
		if (EntityManager->GetParent(item.m_OwnerEntity, ParentEntity)) {
			auto *ParentEntry = GetEntry(ParentEntity);

			//if (ParentEntry->m_Revision <= item.m_Revision && m_CurrentRevision > 1) {
			//	//nothing to do, nothing changed;
			//} else 
			{
				auto &gm = item.m_GlobalMatrix;
				auto &lm = item.m_LocalMatrix;
				item.m_LocalTransform.getOpenGLMatrix((float*)&lm);
				
				lm[0] *= item.m_Scale[0];
				lm[1] *= item.m_Scale[1];
				lm[2] *= item.m_Scale[2];

				gm = ParentEntry->m_GlobalMatrix * lm;
				item.m_GlobalTransform = ParentEntry->m_GlobalTransform * item.m_LocalTransform;
					//.setFromOpenGLMatrix(&gm[0][0]);
				item.m_Revision = m_CurrentRevision;
			}
		//	item.m_GlobalScale = ParentEntry->m_GlobalScale * item.m_LocalScale;
		} else {
			item.m_Flags.m_Map.m_Valid = false;
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
			//mark and continue but set valid to false to avoid further processing
		}
	}

	if (InvalidEntryCount > 0) {
		AddLogf(Performance, "TransformComponent:%p InvalidEntryCount:%lu LastInvalidEntry:%lu", this, InvalidEntryCount, LastInvalidEntry);
		ReleaseElement(LastInvalidEntry);
	}

	++m_CurrentRevision;
	if (m_CurrentRevision < 1) {
		m_CurrentRevision = 1;
	}
}

bool TransformComponent::Load(xml_node node, Entity Owner, Handle &hout) {
	Handle &h = hout;
	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}
	auto &entry = m_Array[index];
	entry.m_Flags.ClearAll();
	if (!GetHandleTable()->Allocate(this, Owner, h, index)) {
		AddLog(Error, "Failed to allocate handle");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}

	//Entity Parent;
	//if (!GetManager()->GetWorld()->GetEntityManager()->GetParent(Owner, Parent)) {
	//	AddLog(Error, "Failed to get Parent!");
	//}
	//AddLog(Hint, "New transform: selfE:" << Owner << "  selfH:" << h << "  Parent:" << Parent);

	m_EntityMapper.SetHandle(Owner, h);
	entry.m_Flags.m_Map.m_Valid = true;
	Physics::vec3 pos;
	XML::Vector::Read(node, "Position", pos);
	entry.m_LocalTransform.setOrigin(pos);
	entry.m_LocalTransform.setRotation(Physics::Quaternion(0, 0, 0, 1));
	entry.m_GlobalTransform = entry.m_LocalTransform;
	XML::Vector::Read(node, "Scale", entry.m_Scale, Physics::vec3(1, 1, 1));
	entry.m_SelfHandle = h;
	entry.m_OwnerEntity = Owner;
	entry.m_Revision = 0;

	return true;
}

TransformComponent::TransformEntry* TransformComponent::GetEntry(Handle h) {
	auto *ht = GetManager()->GetWorld()->GetHandleTable();
	HandleIndex hi;
	if (!ht->GetHandleIndex(this, h, hi)) {
		//AddLog(Debug, "Attempt to get TransformEntry for invalid Entity!");
		return nullptr;
	}
	return &m_Array[hi];
}

TransformComponent::TransformEntry* TransformComponent::GetEntry(Entity e) {
	return GetEntry(m_EntityMapper.GetHandle(e));
}

bool TransformComponent::GetInstanceHandle(Entity Owner, Handle &hout) {
	auto h = m_EntityMapper.GetHandle(Owner);
	if (!GetHandleTable()->IsValid(this, h)) {
		return false;
	}
	hout = h;
	return true;
}

void TransformComponent::ReleaseElement(size_t Index) {
	auto lastidx = m_Array.Allocated() - 1;

	if (lastidx == Index) {
		auto &last = m_Array[lastidx];
		GetHandleTable()->Release(this, last.m_SelfHandle); // handle may be already released; no need to check for failure
		last.Reset();
	} else {
		auto &last = m_Array[lastidx];
		auto &item = m_Array[Index];

		std::swap(last, item);

		if (!GetHandleTable()->SetHandleIndex(this, item.m_SelfHandle, Index)) {
			AddLogf(Error, "Failed to move TransformComponent handle index!");
		}
		GetHandleTable()->Release(this, last.m_SelfHandle); // handle may be already released; no need to check for failure
		last.Reset();
	}
	m_Array.DeallocateLast();
}

//-------------------------------------------------------------------------------------------------

} //namespace Component 
} //namespace Core 
} //namespace MoonGlare 
