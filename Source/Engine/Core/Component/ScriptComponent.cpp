/*
  * Generated by cppsrc.sh
  * On 2016-07-23 16:55:00,64
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>
#include "AbstractComponent.h"
#include "ScriptComponent.h"
#include "ComponentManager.h"

namespace MoonGlare {
namespace Core {
namespace Component {

ScriptComponent::ScriptComponent(ComponentManager *Owner)
	: AbstractComponent(Owner) {
}

ScriptComponent::~ScriptComponent() {
}

bool ScriptComponent::Initialize() {
	m_ScriptEngine = GetManager()->GetWorld()->GetScriptEngine();
	THROW_ASSERT(m_ScriptEngine, "No script engine instance!");

	Space::MemZero(m_Array);

	auto lua = m_ScriptEngine->GetLua();
	LOCK_MUTEX_NAMED(m_ScriptEngine->GetLuaMutex(), lock);

	Utils::Scripts::LuaStackOverflowAssert check(lua);
	lua_pushlightuserdata(lua, (void *)this);
	lua_createtable(lua, m_Array.size(), 0);
#if DEBUG
	lua_pushvalue(lua, -1);
	char name[64]; 
	sprintf_s(name, "ScriptComponent_%p", this);
	lua_setglobal(lua, name);
	AddLogf(Debug, "Adding global registry mapping: %s by %p(%s)", name, this, typeid(*this).name());
#endif
	lua_settable(lua, LUA_REGISTRYINDEX);
	return true;
}

bool ScriptComponent::Finalize() {
	auto lua = m_ScriptEngine->GetLua();
	LOCK_MUTEX_NAMED(m_ScriptEngine->GetLuaMutex(), lock);
#if DEBUG
	lua_pushnil(lua);
	char name[64];
	sprintf_s(name, "ScriptComponent_%p", this);
	AddLogf(Debug, "Deleting mapped global: %s by %p(%s)", name, this, typeid(*this).name());
	lua_setglobal(lua, name);
#endif
	lua_pushlightuserdata(lua, (void *)this);
	lua_pushnil(lua);
	lua_settable(lua, LUA_REGISTRYINDEX);
	return true;
}

void ScriptComponent::Step(const MoveConfig & conf) {
	auto count = m_Generations.Allocated();
	if (count == 0) {
		return;
	}

#ifdef PERF_PERIODIC_PRINT
	auto t = std::chrono::steady_clock::now();
#endif

	auto *EntityManager = GetManager()->GetWorld()->GetEntityManager();

	auto lua = m_ScriptEngine->GetLua();
	LOCK_MUTEX_NAMED(m_ScriptEngine->GetLuaMutex(), lock);
	Utils::Scripts::LuaStackOverflowAssert check(lua);

	lua_pushlightuserdata(lua, (void *)this);
	lua_gettable(lua, LUA_REGISTRYINDEX);

	luabridge::Stack<const MoveConfig*>::push(lua, &conf);

	for (size_t i = 0; i < count; ++i) {
		if (!EntityManager->IsValid(m_Array[i].m_Owner)) {
			AddLogf(Error, "ScriptComponent: invalud entity at index %d", i);
			continue;
		}

		if (!m_Array[i].m_Functions.m_Map.m_Step) {
			//silently ignore
			continue;
		}

		lua_pushinteger(lua, i + 1);
		lua_gettable(lua, -3);

		if (lua_isnil(lua, -1)) {
			lua_pop(lua, 1);
			AddLogf(Error, "ScriptComponent: nil in lua component table at index: %d", i);
			continue;
		}

		lua_getfield(lua, -1, "Step");
		if (lua_isnil(lua, -1)) {
			lua_pop(lua, 2);
			m_Array[i].m_Functions.m_Map.m_Step = false;
			AddLogf(Warning, "ScriptComponent: There is no Step function in component at index: %d, disabling mapping", i);
			continue;
		}

		//selftable
		//moveconf
		//component
		//stepf

		lua_insert(lua, -2); 

		//selftable
		//moveconf
		//stepf
		//component

		lua_pushvalue(lua, -3); //clone move conf

		//selftable
		//moveconf
		//stepf
		//component
		//moveconf

		if (lua_pcall(lua, 2, 0, 0) != 0) {
			AddLogf(Error, "Script exec error: %s", lua_tostring(lua, -1));
			lua_pop(lua, 1);
			m_Array[i].m_Functions.m_Map.m_Step = false;
		}
	}

	lua_pop(lua, 2);

#ifdef PERF_PERIODIC_PRINT
	if (conf.m_SecondPeriod) {
		AddLogf(Performance, "ScriptComponent step: %f ms", (float)((std::chrono::steady_clock::now() - t).count() * 1000.0f));
	}
#endif
}

Handle ScriptComponent::Load(xml_node node, Entity Owner) {
	auto name = node.child("Script").text().as_string(0);
	if (!name) {
		AddLog(Error, "Attempt to load nameless script!");
		return Handle();
	}

	auto ch = m_Generations.Allocate();
	if (!m_Generations.IsHandleValid(ch)) {
		AddLog(Error, "Failed to allocate handle!");
		return Handle();
	}
	size_t index;
	if (!m_Generations.GetTableIndex(ch, index)) {
		AddLog(Error, "Failed to get handle table index!");
		return Handle();
	}

	auto lua = m_ScriptEngine->GetLua();
	LOCK_MUTEX_NAMED(m_ScriptEngine->GetLuaMutex(), lock);
	Utils::Scripts::LuaStackOverflowAssert check(lua);

	if (!m_ScriptEngine->GetRegisteredScript(name)) {
		AddLogf(Error, "There is no such script: %s", name);
		return Handle();
	}

	lua_createtable(lua, 0, 0);
	lua_insert(lua, -2);
	lua_setmetatable(lua, -2);

	luabridge::Stack<Entity*>::push(lua, &Owner);
	lua_setfield(lua, -2, "__Entity");

	lua_pushlightuserdata(lua, (void *)this);
	lua_gettable(lua, LUA_REGISTRYINDEX);
	lua_insert(lua, -2);

	//lua index starts from 1
	lua_pushinteger(lua, static_cast<int>(index) + 1);
	lua_insert(lua, -2);

	lua_settable(lua, -3);
	lua_pop(lua, 1);

	m_Array[index].m_Owner = Owner;
	m_Array[index].m_Functions.SetAll();

	return ch;
}

} //namespace Component 
} //namespace Core 
} //namespace MoonGlare 
