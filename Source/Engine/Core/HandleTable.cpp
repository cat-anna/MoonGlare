/*
  * Generated by cppsrc.sh
  * On 2016-07-28 19:21:16,18
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <nfMoonGlare.h>
#include "HandleTable.h"

namespace MoonGlare {
namespace Core {

HandleTable::HandleTable()
		: m_Allocator(Space::NoConstruct) {
	DebugMemorySetClassName("HandleTable");
	DebugMemoryRegisterCounter("HandleUsage", [this](DebugMemoryCounter& counter) {
		counter.Allocated = m_Allocator.Allocated();
		counter.Capacity = m_Allocator.Capacity();
		counter.ElementSize = sizeof(HandleEntry);
	});
}

HandleTable::~HandleTable() {
}

bool HandleTable::Initialize(EntityManager *EntityManager) {
	m_EntityManager = EntityManager;
	THROW_ASSERT(m_EntityManager, "!m_EntityManager");
	Space::MemZero(m_Array);
	m_Allocator.Rebuild();
	return true;
}

bool HandleTable::Finalize() {
	return true;
}

bool HandleTable::IsValid(Handle h) {
	if (!m_Allocator.IsHandleValid(h)) {
		return false;
	}

	auto index = h.GetIndex();
	if (!m_Array[index].m_Flags.m_Map.m_HasEntityOwner) {
		return true;
	}

	if (!m_EntityManager->IsValid(m_Array[index].m_Owner)) {
		m_Allocator.Free(h);
		return false;
	}

	return true;
}

bool HandleTable::IsValid(HandleType Type, Handle h) {
	if (!m_Allocator.IsHandleValid(h)) {
		return false;
	}

	auto index = h.GetIndex();
	auto &item = m_Array[index];
	if (item.m_Type != Type) {
		return false;
	}
	if (!item.m_Flags.m_Map.m_HasEntityOwner) {
		return true;
	}

	if (!m_EntityManager->IsValid(item.m_Owner)) {
		m_Allocator.Free(h);
		return false;
	}

	return true;
}

bool HandleTable::Allocate(Handle &hout, uint16_t Type, HandleIndex index, HandlePrivateData value) {
	Handle h;
	if (!m_Allocator.Allocate(h)) {
		AddLogf(Error, "Failed to allocate handle!");
		return false;
	}

	hout.SetType(Type);
	m_Allocator.SetMapping(hout, index);
	auto &item = m_Array[hout.GetIndex()];
	item.m_Data = value;
	item.m_Type = Type;
	item.m_Flags.m_UIntValue = 0;
	item.m_Flags.m_Map.m_HasEntityOwner = false;
	return true;
}

bool HandleTable::Allocate(Entity Owner, Handle &hout, uint16_t Type, HandleIndex index, HandlePrivateData value) {
	if (!m_EntityManager->IsValid(Owner)) {
		AddLog(Warning, "Attempt to allocate handle for invalid entity");
		return false;
	}

	if (!m_Allocator.Allocate(hout)) {
		AddLogf(Error, "Failed to allocate handle!");
		return false;
	}
	
	hout.SetType(Type);
	m_Allocator.SetMapping(hout, index);
	auto &item = m_Array[hout.GetIndex()];
	item.m_Data = value;
	item.m_Owner = Owner;
	item.m_Type = Type;
	item.m_Flags.m_UIntValue = 0;
	item.m_Flags.m_Map.m_HasEntityOwner = true;

	return true;
}

bool HandleTable::Release(Handle h) {
	if (!m_Allocator.IsHandleValid(h)) {
		//silently ignore;
		return true;
	}
	
	m_Allocator.Free(h);

	return false;
}

bool HandleTable::GetHandleIndex(Handle h, HandleIndex & index) {
	if (!IsValid(h)) {
		return false;
	}
	return m_Allocator.GetMapping(h, index);
}

bool HandleTable::GetHandleIndex(HandleType Type, Handle h, HandleIndex & index) {
	if (!IsValid(Type, h)) {
		return false;
	}
	return m_Allocator.GetMapping(h, index);
}

bool HandleTable::SetHandleIndex(Handle h, HandleIndex index) {
	if (!IsValid(h)) {
		return false;
	}
	return m_Allocator.SetMapping(h, index);
}

bool HandleTable::GetHandleParentEntity(HandleType Type, Handle h, Entity &eout) {
	if (!IsValid(Type, h)) {
		return false;
	}
	auto &item = m_Array[h.GetIndex()];
	eout = item.m_Owner;
	return true;
}

bool HandleTable::SwapHandleIndexes(Handle ha, Handle hb) {
	if (!IsValid(ha) || !IsValid(hb)) {
		return false;
	}
	HandleIndex hia, hib;
	if (!m_Allocator.GetMapping(ha.GetIndex(), hia) || !m_Allocator.GetMapping(hb.GetIndex(), hib)) {
		return false;
	}
	m_Allocator.SetMapping(ha.GetIndex(), hib);
	m_Allocator.SetMapping(hb.GetIndex(), hia);
	return true;
}

} //namespace Core 
} //namespace MoonGlare 
