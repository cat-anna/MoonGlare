/*
  * Generated by cppsrc.sh
  * On 2016-07-28 19:21:16,18
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <nfMoonGlare.h>
#include "HandleTable.h"

namespace MoonGlare {
namespace Core {

HandleTable::HandleTable()
		: m_Allocator(Space::NoConstruct)
		, m_GCIndex(0) {

	DebugMemorySetClassName("HandleTable");
	DebugMemoryRegisterCounter("HandleUsage", [this](DebugMemoryCounter& counter) {
		counter.Allocated = m_Allocator.Allocated();
		counter.Capacity = m_Allocator.Capacity();
		counter.ElementSize = sizeof(HandleEntry);
	});
}

HandleTable::~HandleTable() {
}

bool HandleTable::Initialize(EntityManager *EntityManager) {
	m_EntityManager = EntityManager;
	m_GCIndex = 0;
	THROW_ASSERT(m_EntityManager, "!m_EntityManager");
	Space::MemZero(m_Array);
	m_Allocator.Rebuild();
	return true;
}

bool HandleTable::Finalize() {
	return true;
}

bool HandleTable::IsValid(Handle h) {
	if (h.GetType() != Configuration::HandleType::Component) {
		return false;
	}
	auto index = h.GetIndex();
	auto &item = m_Array[index];
	if (!item.m_Flags.m_Map.m_Valid || !m_Allocator.IsHandleValid(h)) {
		return false;
	}
	if (!item.m_Flags.m_Map.m_HasEntityOwner) {
		return true;
	}
	if (!m_EntityManager->IsValid(item.m_Owner)) {
		m_Allocator.Free(h);
		return false;
	}
	return true;
}

bool HandleTable::IsValid(ComponentID cid, Handle h) {
	if (h.GetType() != Configuration::HandleType::Component) {
		return false;
	}
	auto index = h.GetIndex();
	auto &item = m_Array[index];
	if (!item.m_Flags.m_Map.m_Valid || !m_Allocator.IsHandleValid(h)) {
		return false;
	}
	if (item.m_OwnerCID != cid) {
		return false;
	}
	if (!item.m_Flags.m_Map.m_HasEntityOwner) {
		return true;
	}
	if (!m_EntityManager->IsValid(item.m_Owner)) {
		m_Allocator.Free(h);
		return false;
	}
	return true;
}

bool HandleTable::Allocate(ComponentID cid, Handle &hout, HandleIndex index, HandlePrivateData value) {
	Handle h;
	if (!m_Allocator.Allocate(h)) {
		AddLogf(Error, "Failed to allocate handle!");
		return false;
	}

	hout.SetType(Configuration::HandleType::Component);
	m_Allocator.SetMapping(hout, index);
	auto &item = m_Array[hout.GetIndex()];
	item.m_Data = value;
	item.m_OwnerCID = cid;
	item.m_Flags.m_UIntValue = 0;
	item.m_Flags.m_Map.m_Valid = true;
	item.m_Flags.m_Map.m_HasEntityOwner = false;
	return true;
}

bool HandleTable::Allocate(ComponentID cid, Entity Owner, Handle &hout, HandleIndex index, HandlePrivateData value) {
	if (!m_EntityManager->IsValid(Owner)) {
		AddLog(Warning, "Attempt to allocate handle for invalid entity");
		return false;
	}

	if (!m_Allocator.Allocate(hout)) {
		AddLogf(Error, "Failed to allocate handle!");
		return false;
	}
	
	hout.SetType(Configuration::HandleType::Component);
	m_Allocator.SetMapping(hout, index);
	auto &item = m_Array[hout.GetIndex()];
	item.m_Data = value;
	item.m_Owner = Owner;
	item.m_OwnerCID = cid;
	item.m_Flags.m_UIntValue = 0;
	item.m_Flags.m_Map.m_Valid = true;
	item.m_Flags.m_Map.m_HasEntityOwner = true;
	return true;
}

bool HandleTable::Release(ComponentID cid, Handle h) {
	if (h.GetType() != Configuration::HandleType::Component) {
		return false;
	}
	if (!m_Allocator.IsHandleValid(h)) {
		//silently ignore;
		return true;
	}

	if (m_Array[h.GetIndex()].m_OwnerCID != cid) {
		return false;
	}
	
	m_Array[h.GetIndex()].m_Flags.m_Map.m_Valid = false;
	m_Allocator.Free(h);

	return true;
}

bool HandleTable::Release(Handle h) {
	if (h.GetType() != Configuration::HandleType::Component) {
		return false;
	}
	if (!m_Allocator.IsHandleValid(h)) {
		//silently ignore;
		return true;
	}
	m_Array[h.GetIndex()].m_Flags.m_Map.m_Valid = false;
	m_Allocator.Free(h);

	return true;
}

bool HandleTable::GetHandleIndex(ComponentID cid, Handle h, HandleIndex & index) {
	if (!IsValid(cid, h)) {
		return false;
	}
	return m_Allocator.GetMapping(h, index);
}

bool HandleTable::SetHandleIndex(ComponentID cid, Handle h, HandleIndex index) {
	if (!IsValid(cid, h)) {
		return false;
	}
	return m_Allocator.SetMapping(h, index);
}

bool HandleTable::GetHandleParentEntity(ComponentID cid, Handle h, Entity &eout) {
	if (!IsValid(cid, h)) {
		return false;
	}
	auto &item = m_Array[h.GetIndex()];
	eout = item.m_Owner;
	return true;
}

bool HandleTable::SwapHandleIndexes(ComponentID cid, Handle ha, Handle hb) {
	if (!IsValid(cid, ha) || !IsValid(cid, hb)) {
		return false;
	}
	HandleIndex hia, hib;
	if (!m_Allocator.GetMapping(ha.GetIndex(), hia) || !m_Allocator.GetMapping(hb.GetIndex(), hib)) {
		return false;
	}
	m_Allocator.SetMapping(ha.GetIndex(), hib);
	m_Allocator.SetMapping(hb.GetIndex(), hia);
	return true;
}

bool HandleTable::GetOwnerCID(Handle h, ComponentID & cidout) {
	if (!IsValid(h)) {
		return false;
	}

	auto index = h.GetIndex();
	auto &item = m_Array[index];
	cidout = item.m_OwnerCID;

	return true;
}

bool HandleTable::Step(const Core::MoveConfig & config) {
	auto limit = m_GCIndex + Configuration::Handle::EntryCheckPerStep

	for (auto it = m_GCIndex; it < limit; ++it) {
		if (!m_Array[it].m_Flags.m_Map.m_Valid)
			continue;
		auto &item = m_Array[it];
		if (m_EntityManager->IsValid(item.m_Owner))
			continue;

		item.m_Flags.m_Map.m_Valid = false;
		m_Allocator.ReleaseIndex(it);
	}

	m_GCIndex = limit >= m_Array.size() ? 0 : limit;
	return true;
}

} //namespace Core 
} //namespace MoonGlare 
