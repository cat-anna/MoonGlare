/*
  * Generated by cppsrc.sh
  * On 2015-08-04 16:59:00,99
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef EntityManager_H
#define EntityManager_H

namespace MoonGlare {
namespace Core {

class EntityManager final 
	: Space::RTTI::RTTIObject
	, public Config::Current::DebugMemoryInterface {
SPACERTTI_DECLARE_STATIC_CLASS(EntityManager, Space::RTTI::RTTIObject);
public:
	template<class T> using Array = std::array<T, Configuration::Entity::IndexLimit>;
	struct Memory {

		template<class ... ARGS>
		using GenerationsAllocator_t = Space::Memory::StaticMultiAllocator<Configuration::Entity::IndexLimit, ARGS...>;
		using Generations_t = Space::Memory::GenerationRandomAllocator<GenerationsAllocator_t, Entity>;

		Array<Entity> m_Parent;
		Generations_t m_Allocator;

		template<class T>
		Memory(T t): m_Allocator(t){ }
	};

	EntityManager();
	~EntityManager();

	bool Initialize();
	bool Finalize();

	Entity GetRootEntity() { return m_Root; }

	Entity Allocate();
	Entity Allocate(Entity parent);
	void Release(Entity entity);

	bool GetParent(Entity entity, Entity &ParentOut) const;
	bool IsValid(Entity entity) const;

	static void RegisterScriptApi(ApiInitializer &root);
private: 
	Entity m_Root;
	Memory m_Memory;
};

struct EntityMapper {
	template<class T> using Array = EntityManager::Array<T>;

	Handle GetHandle(Entity e) const {
		return m_Array[e.GetIndex()].m_Handle;
	}

	void SetHandle(Entity e, Handle h) {
		m_Array[e.GetIndex()].m_Handle = h;
	}

	struct Entry {
		Handle m_Handle;
	};
protected:
	Array<Entry> m_Array;
};

} //namespace Core 
} //namespace MoonGlare 

#endif
