/*
  * Generated by cppsrc.sh
  * On 2016-08-04 19:45:53,67
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef MessageSubsystem_H
#define MessageSubsystem_H

#include "Configuration.Core.h"
#include "Events.h"

namespace MoonGlare::Core {

struct EventHandlerInterface {
protected:
	virtual ~EventHandlerInterface() { }
};

struct BaseEventCallDispatcher {
	template<typename EVENT>
	void Dispatch(const EVENT &ev) {
		AddLog(Event, "Dispatching event: " << ev << " recipients:" << m_Handlers.size());

		for (auto &handler : m_Handlers)
			handler.Call(&ev);
	}

	template<typename RECIVER, typename EVENT, void(RECIVER::*HANDLER)(const EVENT&)>
	void AddHandler(RECIVER *reciver) {
		struct F {
			static void Call(void *reciver, const void *event) {
				ASSERT(reciver);
				ASSERT(event);
				auto *r = reinterpret_cast<RECIVER*>(reciver);
				const EVENT &ev = *reinterpret_cast<const EVENT*>(event);
				(r->*HANDLER)(ev);
			}
		};
		m_Handlers.emplace_back( HandlerCaller { reciver, &F::Call });
#ifdef DEBUG
		m_Handlers.back().m_Interface = dynamic_cast<EventHandlerInterface*>(reciver);
#endif
	}
protected:
	using HandlerFunction = void(*)(void *reciver, const void *event);
	struct HandlerCaller {
		void *m_Reciver;
		HandlerFunction m_Function;
#ifdef DEBUG
		EventHandlerInterface *m_Interface;
#endif

		void Call(const void * event) { m_Function(m_Reciver, event); }
	};
	std::vector < HandlerCaller > m_Handlers;
};

class EventDispatcher {
	using Conf = Configuration::Core::Events;
public:

	EventDispatcher();
	
	bool Initialize(World *world);
	bool Finalize();

	template<typename EVENT>
	void SendMessage(const EVENT& event) {
		auto classid = EventInfo<EVENT>::GetClassID();
		ASSERT(classid < Conf::MaxEventTypes);
		m_EventDispatchers[classid].Dispatch(event);
	}

	template<typename EVENT, typename RECIVER, void(RECIVER::*HANDLER)(const EVENT&)>
	void Register(RECIVER *reciver) {
		auto classid = EventInfo<EVENT>::GetClassID();
		ASSERT(classid < Conf::MaxEventTypes);
		m_EventDispatchers[classid].AddHandler<RECIVER, EVENT, HANDLER>(reciver);
	}
	template<typename EVENT, typename RECIVER>
	void Register(RECIVER *reciver) {
		return Register < EVENT, RECIVER, static_cast<void(RECIVER::*)(const EVENT&)>(&RECIVER::HandleEvent) > (reciver);
	}
	template<typename EVENT, typename RECIVER>
	void RegisterTemplate(RECIVER *reciver) {
		return Register < EVENT, RECIVER, &RECIVER::HandleEventTemplate<EVENT>>(reciver);
	}
private:
	template<typename T>
	using Array = std::array<T, Conf::MaxEventTypes>;

	Array<BaseEventCallDispatcher> m_EventDispatchers;
};

} //namespace MoonGlare::Core

#endif
