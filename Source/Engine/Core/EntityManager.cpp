/*
  * Generated by cppsrc.sh
  * On 2015-08-04 16:59:00,99
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include <pch.h>
#include <MoonGlare.h>

namespace MoonGlare {
namespace Core {

SPACERTTI_IMPLEMENT_STATIC_CLASS(EntityManager);
//RegisterApiInstance(EntityManager, &cScriptEngine::Instance, "EntityManager");
RegisterApiBaseClass(EntityManager, &EntityManager::RegisterScriptApi);

EntityManager::EntityManager():
		m_Memory(Space::NoConstruct) {

	DebugMemorySetClassName("EntityManager");
	DebugMemoryRegisterCounter("Entities", [this](DebugMemoryCounter& counter) {
		counter.Allocated = m_Memory.m_Allocator.Allocated();
		counter.Capacity = m_Memory.m_Allocator.Capacity();
		counter.ElementSize = 0;
	});
}

EntityManager::~EntityManager() {
}

//---------------------------------------------------------------------------------------

void EntityManager::RegisterScriptApi(ApiInitializer &root) {

	struct T {
		int GetIndex() {
			return ((Entity*)this)->GetIndex();
		}
	};

	root
	.beginClass<Entity>("cEntity")
	.endClass()

	.beginClass<EntityManager>("cEntityManager")
		.addFunction("IsValid", &EntityManager::IsValid)
	.endClass();
}

//------------------------------------------------------------------------------------------

bool EntityManager::Initialize() {
	m_Memory.m_Allocator.Clear();
	Space::MemZero(m_Memory.m_Parent);

	m_Root = m_Memory.m_Allocator.Allocate();
	m_Memory.m_Parent[m_Root.GetIndex()] = m_Root;

	return true;
}

bool EntityManager::Finalize() {
	m_Root = Entity();
	return true;
}

//------------------------------------------------------------------------------------------

Entity EntityManager::Allocate() {
	return Allocate(GetRootEntity());
}

bool EntityManager::Allocate(Entity parent, Entity &eout) {
	if (!m_Memory.m_Allocator.IsHandleValid(parent)) {
		AddLog(Error, "Parent entity is not valid!");
		return false;
	}

	auto h = m_Memory.m_Allocator.Allocate();
	if (!m_Memory.m_Allocator.IsHandleValid(h)) {
		AddLog(Error, "No more space!");
		return false;
	}
	auto index = h.GetIndex();

	m_Memory.m_Parent[index] = parent;
	eout = h;
	return true;
}

Entity EntityManager::Allocate(Entity parent) {
	Entity e;
	Allocate(parent, e);
	return e;
}

void EntityManager::Release(Entity entity) {
	if (!m_Memory.m_Allocator.IsHandleValid(entity)) {
		AddLog(Error, "entity is not valid!");
		return;
	}

	m_Memory.m_Allocator.Free(entity);
}

bool EntityManager::IsValid(Entity entity) const {
	return m_Memory.m_Allocator.IsHandleValid(entity);
}

bool EntityManager::GetParent(Entity entity, Entity &ParentOut) const {
	if (!m_Memory.m_Allocator.IsHandleValid(entity)) {
		AddLog(Error, "entity is not valid!");
		return false;
	}
	auto index = entity.GetIndex();
	ParentOut = m_Memory.m_Parent[index];
	return true;
}

} //namespace Core 
} //namespace MoonGlare 
