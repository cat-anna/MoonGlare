/*
  * Generated by cppsrc.sh
  * On 2015-08-04 16:59:00,99
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include <pch.h>
#include <MoonGlare.h>

#include <Core/Scripts/LuaApi.h>

#include <Foundation/Component/EventDispatcher.h>
#include <Foundation/Component/EntityEvents.h>

namespace MoonGlare {
namespace Core {

EntityManager::EntityManager() {
    DebugMemorySetClassName("EntityManager");
    DebugMemoryRegisterCounter("Entities", [this](DebugMemoryCounter& counter) {
        counter.Allocated = m_Allocator.Allocated();
        counter.Capacity = m_Allocator.Capacity();
        counter.ElementSize = 0;
    });
}

EntityManager::~EntityManager() { }

//------------------------------------------------------------------------------------------

bool EntityManager::Initialize() {
    m_Allocator.Clear();
    Space::MemZero(m_Flags);
    Space::MemZero(m_NameHash);
    Space::MemZero(m_Parent);

    m_Root = m_Allocator.Allocate();
    m_Parent[m_Root.GetIndex()] = m_Root;
    m_Flags[m_Root.GetIndex()].ClearAll();
    m_Flags[m_Root.GetIndex()].m_Map.m_Valid = true;

    return true;
}

bool EntityManager::Finalize() {
    m_Root = Entity();
    return true;
}

//------------------------------------------------------------------------------------------

bool EntityManager::Allocate(Entity parent, Entity &eout, std::string Name) {
    auto parentindex = parent.GetIndex();
    if (!m_Allocator.IsHandleValid(parent) || !m_Flags[parentindex].m_Map.m_Valid) {
        AddLog(Error, "Parent entity is not valid!");
        return false;
    }

    eout = m_Allocator.Allocate();
    if (!m_Allocator.IsHandleValid(eout)) {
        AddLog(Error, "No more space!");
        return false;
    }
    auto index = eout.GetIndex();

    m_Flags[index].ClearAll();
    m_Flags[index].m_Map.m_Valid = true;
    m_Parent[index] = parent;

    m_NameHash[index] = Space::Utils::MakeHash32(Name.c_str());
    m_Names[index].swap(Name);

    for (auto *ev : eventSinks)
        ev->Queue(MoonGlare::Component::EntityCreatedEvent{parent, eout});

    return true;
}

bool EntityManager::Release(Entity entity) {
    auto index = entity.GetIndex();
    if (!m_Flags[index].m_Map.m_Valid || !m_Allocator.IsHandleValid(entity)) {
        return false;
    }

    for (auto *ev : eventSinks)
        ev->Queue(MoonGlare::Component::EntityDestructedEvent{ m_Parent[index], entity });

    m_Flags[index].ClearAll();
    m_Allocator.Free(entity);

    return true;
}

//---------------------------------------------------------------------------------------

bool EntityManager::SetEntityName(Entity e, std::string Name) {
    if (!IsAllocated(e))
        return false;

    auto index = e.GetIndex();
    m_NameHash[index] = Space::Utils::MakeHash32(Name.c_str());
    m_Names[index].swap(Name);

    return true;
}

bool EntityManager::GetEntityName(Entity e, std::string &Name) {
    if (!IsAllocated(e))
        return false;

    auto index = e.GetIndex();
    Name = m_Names[index];

    return true;
}

bool EntityManager::GetEntityName(Entity e, EntityNameHash & out) {
    if (!IsAllocated(e))
        return false;

    auto index = e.GetIndex();
    out = m_NameHash[index];

    return false;
}

bool EntityManager::GetEntityName(Entity e, const std::string *& Name) {
    if (!IsAllocated(e))
        return false;

    auto index = e.GetIndex();
    Name = &m_Names[index];

    return true;
}

bool EntityManager::GetRawFlags(Entity Owner, EntityFlags & flagsout) {
    if (!IsAllocated(Owner))
        return false;

    auto index = Owner.GetIndex();
    flagsout = m_Flags[index];
    return true;
}

} //namespace Core 
} //namespace MoonGlare 
