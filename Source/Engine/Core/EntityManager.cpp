/*
  * Generated by cppsrc.sh
  * On 2015-08-04 16:59:00,99
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include <pch.h>
#include <MoonGlare.h>

namespace MoonGlare {
namespace Core {

SPACERTTI_IMPLEMENT_STATIC_CLASS(EntityManager);
//RegisterApiInstance(EntityManager, &ScriptEngine::Instance, "EntityManager");
RegisterApiBaseClass(EntityManager, &EntityManager::RegisterScriptApi);

EntityManager::EntityManager() {

	DebugMemorySetClassName("EntityManager");
	DebugMemoryRegisterCounter("Entities", [this](DebugMemoryCounter& counter) {
		counter.Allocated = m_Allocator.Allocated();
		counter.Capacity = m_Allocator.Capacity();
		counter.ElementSize = 0;
	});
}

EntityManager::~EntityManager() {
}

//---------------------------------------------------------------------------------------

void EntityManager::RegisterScriptApi(ApiInitializer &root) {
	//struct T {
	//	int GetIndex() {
	//		return ((Entity*)this)->GetIndex();
	//	}
	//};
	//
	//root
	//.beginClass<Entity>("cEntity")
	//.endClass()
	//
	//.beginClass<EntityManager>("cEntityManager")
	//	.addFunction("IsValid", &EntityManager::IsValid)
	//.endClass();
}

//------------------------------------------------------------------------------------------

bool EntityManager::Initialize() {
	m_Allocator.Clear();
	Space::MemZero(m_Parent);
	Space::MemZero(m_Flags);
	Space::MemZero(m_EntityValues);
	Space::MemZero(m_FirstChild);
	Space::MemZero(m_NextSibling);
	Space::MemZero(m_PrevSibling);
	Space::MemZero(m_NameHash);

	m_ReleaseQueue.reserve(512);//TODO: make it some configuration value?; 512 - because why less?

	m_Root = m_Allocator.Allocate();
	m_Parent[m_Root.GetIndex()] = m_Root;
	m_Flags[m_Root.GetIndex()].ClearAll();
	m_Flags[m_Root.GetIndex()].m_Map.m_Valid = true;

	return true;
}

bool EntityManager::Finalize() {
	m_Root = Entity();
	return true;
}

//------------------------------------------------------------------------------------------

bool EntityManager::Allocate(Entity & eout) {
	return Allocate(GetRootEntity(), eout);
}

bool EntityManager::Allocate(Entity parent, Entity &eout, std::string Name) {
	auto parentindex = parent.GetIndex();
	if (!m_Allocator.IsHandleValid(parent) || !m_Flags[parentindex].m_Map.m_Valid) {
		AddLog(Error, "Parent entity is not valid!");
		return false;
	}

	eout = m_Allocator.Allocate();
	if (!m_Allocator.IsHandleValid(eout)) {
		AddLog(Error, "No more space!");
		return false;
	}
	auto index = eout.GetIndex();

	m_Parent[index] = parent;
	m_Flags[index].ClearAll();
	m_Flags[index].m_Map.m_Valid = true;
	m_Flags[index].m_Map.m_HasParent = true;
	m_FirstChild[index] = Entity();
	m_NextSibling[index] = Entity();
	m_PrevSibling[index] = Entity();
	m_EntityValues[index] = eout;

	m_NameHash[index] = Space::Utils::MakeHash32(Name.c_str());
	m_Names[index].swap(Name);

	if (m_Flags[parentindex].m_Map.m_HasChildren) {
		auto PrevFistChild = m_FirstChild[parentindex];

		if (!IsAllocated(PrevFistChild)) {
			AddLogf(Error, "Entity chain is broken!");
		} else {
			auto siblingindex = parent.GetIndex();
			m_Flags[siblingindex].m_Map.m_HasPrevSibling = true;
			m_PrevSibling[siblingindex] = eout;
			m_NextSibling[index] = PrevFistChild;
			m_Flags[index].m_Map.m_HasNextSibling = true;
		}
	} else {
		m_Flags[parentindex].m_Map.m_HasChildren = true;
	}
	m_FirstChild[parentindex] = eout;

	return true;
}

bool EntityManager::Release(Entity entity) {
	auto index = entity.GetIndex();
	if (!m_Flags[index].m_Map.m_Valid || !m_Allocator.IsHandleValid(entity)) {
		return false;
	}
	if (m_Flags[index].m_Map.m_ReleasePending)
		return true;
	m_Flags[index].m_Map.m_ReleasePending = true;
	m_ReleaseQueue.push_back(entity);
	return true;
}

//---------------------------------------------------------------------------------------

bool EntityManager::Step(const Core::MoveConfig & config) {
	if (m_ReleaseQueue.empty())
		return true;

	size_t ReleaseCount = 0;
	while (!m_ReleaseQueue.empty()) {
		Entity e = m_ReleaseQueue.back();
		m_ReleaseQueue.pop_back();

		if (!IsAllocated(e))
			continue; //should not happen, but check is necessary

		++ReleaseCount;

		auto index = e.GetIndex();

		auto &indexflags = m_Flags[index].m_Map;
		if (indexflags.m_HasChildren) {
			Entity child = m_FirstChild[index];
			while (IsAllocated(child)) {
				m_ReleaseQueue.push_back(child);
				auto cidx = child.GetIndex();
				child = m_NextSibling[cidx];
				auto &flags = m_Flags[cidx].m_Map;
				flags.m_HasParent = false;
				flags.m_HasNextSibling = false;
				flags.m_HasPrevSibling = false;
				flags.m_ReleasePending = true;
			}
		}
		if (indexflags.m_HasNextSibling && indexflags.m_HasPrevSibling) {
			auto prev = m_PrevSibling[index];
			auto next = m_NextSibling[index];
			if (!IsAllocated(prev) || !IsAllocated(next)) {
				AddLogf(Error, "Entity chain is broken!");
			} else {
				m_NextSibling[prev.GetIndex()] = next;
				m_PrevSibling[next.GetIndex()] = prev;
			}
		} else
		if (indexflags.m_HasNextSibling) {
			auto next = m_NextSibling[index];
			auto parent = m_Parent[index];
			if (!IsAllocated(next) || !!IsAllocated(parent)) {
				AddLogf(Error, "Entity chain is broken!");
			} else {
				m_PrevSibling[next.GetIndex()] = Entity();
				m_Flags[next.GetIndex()].m_Map.m_HasPrevSibling = false;
				m_FirstChild[parent.GetIndex()] = next;
			}
		} else
		if (indexflags.m_HasPrevSibling) {
			auto prev = m_PrevSibling[index];
			if (!IsAllocated(prev)) {
				AddLogf(Error, "Entity chain is broken!");
			} else {
				m_NextSibling[prev.GetIndex()] = Entity();
				m_Flags[prev.GetIndex()].m_Map.m_HasNextSibling = false;
			}
		}

		m_Flags[index].ClearAll();
		m_Allocator.Free(e);
	}
	
	AddLogf(Performance, "EntityManager:%p Entities released:%lu", this, ReleaseCount);

//	auto limit = m_GCIndex + Configuration::Entity::EntryCheckPerStep;
//	for (auto it = m_GCIndex; it < limit; ++it) {
//		if (!m_Flags[it].m_Map.m_Valid)
//			continue;
//		auto parent = m_Parent[it];
//		if (m_Flags[parent.GetIndex()].m_Map.m_Valid && m_Allocator.IsHandleValid(parent)) {
//			continue;
//		}
//
//		m_Flags[it].m_Map.m_Valid = false;
//		m_Allocator.Free(m_EntityValues[it]);
//	}
//	m_GCIndex = limit >= m_Parent.size() ? 0 : limit;
	return true;
}

//---------------------------------------------------------------------------------------

bool EntityManager::GetParent(Entity entity, Entity &ParentOut) const {
	auto index = entity.GetIndex();
	if (!m_Flags[index].m_Map.m_Valid || !m_Allocator.IsHandleValid(entity) || !m_Flags[index].m_Map.m_HasParent) {
		return false;
	}
	ParentOut = m_Parent[index];
	return true;
}

bool EntityManager::GetFistChild(Entity entity, Entity & ChildOut) const {
	auto index = entity.GetIndex();
	if (!m_Flags[index].m_Map.m_Valid || !m_Allocator.IsHandleValid(entity) || !m_Flags[index].m_Map.m_HasChildren) {
		return false;
	}
	ChildOut = m_FirstChild[index];
	return true;
}

bool EntityManager::GetNextSibling(Entity entity, Entity & SiblingOut) const {
	auto index = entity.GetIndex();
	if (!m_Flags[index].m_Map.m_Valid || !m_Allocator.IsHandleValid(entity) || !m_Flags[index].m_Map.m_HasNextSibling) {
		return false;
	}
	SiblingOut = m_NextSibling[index];
	return true;
}

//---------------------------------------------------------------------------------------

bool EntityManager::SetEntityName(Entity e, std::string Name) {
	if (!IsAllocated(e))
		return false;

	auto index = e.GetIndex();
	m_NameHash[index] = Space::Utils::MakeHash32(Name.c_str());
	m_Names[index].swap(Name);

	return true;
}

bool EntityManager::GetEntityName(Entity e, std::string &Name) {
	if (!IsAllocated(e))
		return false;

	auto index = e.GetIndex();
	Name = m_Names[index];

	return true;
}

bool EntityManager::GetEntityName(Entity e, EntityNameHash & out) {
	if (!IsAllocated(e))
		return false;

	auto index = e.GetIndex();
	out = m_NameHash[index];

	return false;
}

bool EntityManager::GetEntityName(Entity e, const std::string *& Name) {
	if (!IsAllocated(e))
		return false;

	auto index = e.GetIndex();
	Name = &m_Names[index];

	return true;
}

bool EntityManager::GetFirstChildByName(Entity ParentE, EntityNameHash hashname, Entity & eout) {
	if (!IsAllocated(ParentE))
		return false;

	auto index = ParentE.GetIndex();
	if (!m_Flags[index].m_Map.m_HasChildren)
		return false;

	struct T {
		static bool func(EntityManager *This, Entity child, EntityNameHash hashname, Entity & eout) {
			while (This->IsAllocated(child)) {
				auto childindex = child.GetIndex();
				if (This->m_NameHash[childindex] == hashname) {
					eout = child;
					return true;
				}
				if (This->m_Flags[childindex].m_Map.m_HasChildren) {
					if (func(This, This->m_FirstChild[childindex], hashname, eout))
						return true;
				}
				if (!This->GetNextSibling(child, child))
					return false;
			}
			return false;
		}
	};

	return T::func(this, m_FirstChild[index], hashname, eout);
}

bool EntityManager::GetFirstChildByName(Entity ParentE, const char *Name, Entity & eout) {
	return GetFirstChildByName(ParentE, Space::Utils::MakeHash32(Name ? Name : ""), eout);
}

bool EntityManager::GetRawFlags(Entity Owner, EntityFlags & flagsout) {
	if (!IsAllocated(Owner))
		return false;

	auto index = Owner.GetIndex();
	flagsout = m_Flags[index];
	return true;
}

} //namespace Core 
} //namespace MoonGlare 
