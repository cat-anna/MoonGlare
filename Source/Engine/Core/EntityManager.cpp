/*
  * Generated by cppsrc.sh
  * On 2015-08-04 16:59:00,99
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include <pch.h>
#include <MoonGlare.h>

namespace MoonGlare {
namespace Core {

SPACERTTI_IMPLEMENT_STATIC_CLASS(EntityManager);
//RegisterApiInstance(EntityManager, &cScriptEngine::Instance, "EntityManager");
RegisterApiBaseClass(EntityManager, &EntityManager::RegisterScriptApi);

EntityManager::EntityManager():
		m_Memory(Space::NoConstruct) {

	DebugMemorySetClassName("EntityManager");

	DebugMemoryRegisterCounter("Entities", [this](DebugMemoryCounter& counter) {
		counter.Allocated = m_Memory.m_Allocator.Allocated();
		counter.Capacity = m_Memory.m_Allocator.Capacity();
		counter.ElementSize = 0;
	});
}

EntityManager::~EntityManager() {
}

//---------------------------------------------------------------------------------------

void EntityManager::RegisterScriptApi(ApiInitializer &root) {

	struct T {
		int GetIndex() {
			return ((Entity*)this)->GetIndex();
		}
	};

	root
	.beginClass<Entity>("cEntity")
		.addFunction("GetIndex", (int (Entity::*)())&T::GetIndex)
	.endClass()

	.beginClass<EntityManager>("cEntityManager")
		.addFunction("IsValid", &EntityManager::IsValid)
	.endClass();
}

//------------------------------------------------------------------------------------------

bool EntityManager::Initialize() {
	m_Memory.m_Allocator.Clear();
	Space::MemZero(m_Memory.m_Parent);

	m_Root = m_Memory.m_Allocator.Allocate();
	m_Memory.m_Parent[m_Root.GetIndex()] = m_Root;

	return true;
}

bool EntityManager::Finalize() {
	m_Root = Entity();
	return true;
}

//------------------------------------------------------------------------------------------

Entity EntityManager::Allocate() {
	return Allocate(GetRootEntity());
}

Entity EntityManager::Allocate(Entity parent) {

	if (!m_Memory.m_Allocator.IsHandleValid(parent)) {
		AddLog(Error, "Parent entity is not valid!");
		return Entity();
	}

	auto h = m_Memory.m_Allocator.Allocate();
	if (!m_Memory.m_Allocator.IsHandleValid(h)) {
		AddLog(Error, "No more space!");
		return Entity();
	}
	auto index = h.GetIndex();

	m_Memory.m_Parent[index] = parent;

	return h;
}

void EntityManager::Release(Entity entity) {
	if (!m_Memory.m_Allocator.IsHandleValid(entity)) {
		AddLog(Error, "entity is not valid!");
		return;
	}

	m_Memory.m_Allocator.Free(entity);
}

bool EntityManager::IsValid(Entity entity) const {
	return m_Memory.m_Allocator.IsHandleValid(entity);
}

Entity EntityManager::GetParent(Entity entity) const {
	if (!m_Memory.m_Allocator.IsHandleValid(entity)) {
		AddLog(Error, "entity is not valid!");
		return Entity();;
	}
	auto index = entity.GetIndex();
	return m_Memory.m_Parent[index];
}

#if 0

using EntityIndex = unsigned short;
using EntityGeneration = unsigned short;
using EntityIndexQueue = Utils::Memory::StaticIndexQueue<EntityIndex, StaticSettings::StaticStorage::EntityBuffer, Utils::Memory::NoLockPolicy>;
using EntityGenerationBuffer = Utils::Memory::GenerationBuffer<EntityGeneration, StaticSettings::StaticStorage::EntityBuffer>;

struct EntityManagerImpl {
	std::mutex m_Lock;
	EntityIndexQueue m_IndexQueue;
	EntityGenerationBuffer m_Generations;
};

static EntityManagerImpl EMImpl;

bool EntityManager::Initialize() {
	EntityIndex e;
	EMImpl.m_IndexQueue.get(e); //reserve index 0 for invalid entry;
	EMImpl.m_Generations.NewGeneration(e); //increment generation for invalid index;
	return true;
}

bool EntityManager::Finalize() {
	return true;
}

Entity EntityManager::Allocate() {
	LOCK_MUTEX(EMImpl.m_Lock);
	EntityIndex index;
	if (!EMImpl.m_IndexQueue.get(index)) {
		AddLogf(Error, "No more free entity indexes!");
		Entity e;
		e.m_IntegerValue = 0;
		return e;
	}
	Entity e;
	e.m_Index = index;
	e.m_Generation = EMImpl.m_Generations.Generation(index);
	return e;
}

void EntityManager::Release(Entity e) {
	LOCK_MUTEX(EMImpl.m_Lock);
	EMImpl.m_Generations.NewGeneration(e.m_Index);
	EMImpl.m_IndexQueue.push(e.m_Index);
}

#ifdef DEBUG_MEMORY
static struct EntityManagerInfo_t : Config::Debug::MemoryInterface {
	virtual Info* GetInfo() const {
		static Info i = { 0, 0, sizeof(EntityIndexQueue::Item) + sizeof(EntityGenerationBuffer::Item), EntityIndexQueue::Size, "EntityManager" };
		i.Update(EntityIndexQueue::Size - EMImpl.m_IndexQueue.count());
		return &i;
	}
} EntityManagerInfo;
#endif

#endif

} //namespace Core 
} //namespace MoonGlare 
