/*
  * Generated by cppsrc.sh
  * On 2016-08-14 22:04:32,35
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <nfMoonGlare.h>
#include "Component/SubsystemManager.h"
#include "Component/ComponentRegister.h"
#include "Component/TemplateStandardComponent.h"
#include "EntityBuilder.h"

#include <Foundation/Component/EntityManager.h>

#include <boost/algorithm/string.hpp>

namespace MoonGlare {
namespace Core {

struct EntityImport {
    Entity entity{};
    int32_t parentIndex = -1;
    std::string name;
    bool enabled = true;
    std::unordered_map<std::string, int32_t> children;
};

struct EntityBuilder::ComponentImport {
    int32_t entityIndex = 1;
    bool enabled = true;
    bool active = true;
    pugi::xml_node xmlNode;
    std::vector<std::string> localRelationNames;
    std::vector<int32_t> localRelationIndex;
    std::vector<Entity> localRelationEntity;
};

struct EntityBuilder::ImportData {
    std::vector<EntityImport> entities;
    using ComponentImportVector = std::vector<ComponentImport>;
    std::map<Component::SubSystemId, ComponentImportVector> components;
    std::vector<XMLFile> xmlFiles;
    std::string srcName;
    
    int32_t FindSibling(int32_t startIndex, const std::string &Name) {
        if (startIndex < 0)
            return startIndex;
        auto &e = entities[startIndex];
        return FindChild(e.parentIndex < 0 ? startIndex : e.parentIndex, Name);
    }

    int32_t FindChild(int32_t startIndex, const std::string &Name) {
        if (startIndex < 0)
            return startIndex;

        auto &e = entities[startIndex];
        if (e.name == Name)
            return startIndex;

        for (auto&[n, idx] : e.children) {
            if (auto r = FindChild(idx, Name); r >= 0)
                return r;
        }
        return -1;
    }

    void Prepare() {
        for (auto &c : components) {
            std::sort(c.second.begin(), c.second.end(), [](const ComponentImport &c1, const ComponentImport &c2) {
                return c1.entityIndex < c2.entityIndex;
            });
        }
    }

    void Dump(const std::string &ename) {
        static std::unordered_map<std::string, std::string> dumpedSrcs;
        static int dumpid = 0;

        if (dumpedSrcs.find(srcName) != dumpedSrcs.end())
            return;

        std::string fname = "logs/";
        fname = fmt::format("logs/{}.{}.entity", ename, dumpid++);
        dumpedSrcs[srcName] = fname;

        std::ofstream of(fname, std::ios::out);

        if (!srcName.empty())
            of << "SOURCE: " << srcName << "\n\n";

        of << fmt::format("Entities: {}\n", entities.size());
        size_t index = 0;
        for (auto&it : entities) {
            of << fmt::format("\tIndex:{:3} ParentIndex:{:3} Enabled:{} Name:{}\n", index, it.parentIndex, it.enabled, it.name);
            ++index;
        }
        of << "\n";
        of << fmt::format("Components: {}\n", components.size());
        for (auto &it : components) {
            std::string Name;
            if (it.first > SubSystemId::CoreBegin)
                Name = Component::ComponentRegister::GetComponentInfo(it.first)->m_Name;
            else
                Name = Component::BaseComponentInfo::GetComponentTypeInfo(static_cast<Component::ComponentClassId>(it.first)).componentName;

            of << fmt::format("\tComponent:{}  Name:{}\n", (int)it.first, Name);
            for (auto &c : it.second) {
                std::string rels;
                for (size_t i = 0; i < c.localRelationNames.size(); ++i) {
                    if (!rels.empty())
                        rels += ",";
                    rels += c.localRelationNames[i] + "=" + std::to_string(c.localRelationIndex[i]);
                }
                of << fmt::format("\t\tParentIndex:{:3}  Enabled:{}  Active:{}  Relations:{} \n" , c.entityIndex, c.enabled, c.active, rels);
            }
        }               

        of.close();
    }
};

//-------------------------------------------------------------------------------------------------

EntityBuilder::EntityBuilder(Component::SubsystemManager *Manager)
        : m_Manager(Manager) {
}

EntityBuilder::~EntityBuilder() {
}

//-------------------------------------------------------------------------------------------------

bool EntityBuilder::Build(Entity parent, const char *PatternUri, Entity &eout, std::string Name) {
    ImportData data;

    data.srcName = PatternUri;

    EntityImport ei;
    ei.parentIndex = -1;
    ei.name = std::move(Name);
    data.entities.emplace_back(std::move(ei));

    Import(data, PatternUri, 0);
    data.Prepare();
    Spawn(data, parent);

#ifdef DEBUG_DUMP
    data.Dump(Name);
#endif
    eout = data.entities[0].entity;
    return true;
}

bool EntityBuilder::Build(Entity parent, const char *srcName, pugi::xml_node node, std::string Name) {
    ImportData data;
    data.srcName = srcName;

    Import(data, node, -1);
    data.Prepare();
    Spawn(data, parent);
#ifdef DEBUG_DUMP
    data.Dump(Name);
#endif
    return true;
}

//-------------------------------------------------------------------------------------------------

void EntityBuilder::Spawn(ImportData &data, Entity parent) {
    auto world = m_Manager->GetWorld();
    auto &em = world->GetEntityManager();

    for (auto &ei : data.entities) {
        if (!ei.enabled)
            continue;

        Entity thisParent;
        if (ei.parentIndex >= 0)
            thisParent = data.entities[ei.parentIndex].entity;
        else
            thisParent = parent;

        if (!em.Allocate(thisParent, ei.entity, ei.name)) {
            AddLogf(Error, "Failed to allocate entity!");
            return;
        }
    }


    auto SpawnComponents = [this, parent, &data](std::vector<ComponentImport>& cs) {
        for (auto &ci : cs) {
            if (!ci.enabled)
                continue;
            Entity thisParent = {};
            Entity thisOwner = {};
            if (ci.entityIndex >= 0) {
                auto &e = data.entities[ci.entityIndex];
                thisOwner = e.entity;
                if (e.parentIndex >= 0)
                    thisParent = data.entities[e.parentIndex].entity;
                else
                    thisParent = parent;
            } else {
                __debugbreak();
                //owner = Owner;
            }

            for (auto& item : ci.localRelationNames) {
                auto rel = data.FindSibling(ci.entityIndex, item);
                ci.localRelationIndex.push_back(rel);
                if (rel >= 0)
                    ci.localRelationEntity.push_back(data.entities[rel].entity);
                else
                    ci.localRelationEntity.push_back({});
            }

            LoadComponent(thisParent, thisOwner, ci);
        }
    };

    std::vector<std::pair<SubSystemId, ImportData::ComponentImportVector*>> components;
    for (auto &item : data.components)
        components.emplace_back(item.first, &item.second);

    static const std::map<SubSystemId, int> ComponentOrder = {
        {SubSystemId::Transform, 0},
        {SubSystemId::RectTransform, 1},
        {SubSystemId::Body, 2},
        {SubSystemId::Script, 0xFFFF},
    };

    std::sort(components.begin(), components.end(), [](const auto &aP, const auto &bP) {
        auto a = aP.first;
        auto b = bP.first;

        if (a == b)
            return true;

        int aR, bR;

        auto aIt = ComponentOrder.find(a);
        auto bIt = ComponentOrder.find(b);
        aR = aIt != ComponentOrder.end() ? aIt->second : (int)a + 0x0100;
        bR = bIt != ComponentOrder.end() ? bIt->second : (int)b + 0x0100;
                   
        return aR < bR;
    });

    for (auto &c : components)
        SpawnComponents(*c.second);
}

//-------------------------------------------------------------------------------------------------

void EntityBuilder::Import(ImportData &data, const char *PatternUri, int32_t entityIndex) {
    data.xmlFiles.emplace_back();
    XMLFile &xml = data.xmlFiles.back();
    if (!((iFileSystem*)GetFileSystem())->OpenXML(xml, std::string(PatternUri))) {
        AddLogf(Error, "Failed to open uri: %s", PatternUri);
        return;
    }

    auto node = xml->document_element();

    Import(data, node, entityIndex);
}

void EntityBuilder::Import(ImportData &data, pugi::xml_node node, int32_t entityIndex) {
    bool parentEnabled = entityIndex >= 0 ? data.entities[entityIndex].enabled : true;

    if (entityIndex >= 0) {
        auto &ei = data.entities[entityIndex];
        if (ei.name.empty()) 
            ei.name = node.attribute("Name").as_string("");

        ei.enabled = node.attribute("Enabled").as_bool(true) && parentEnabled;
    }

    for (auto it = node.first_child(); it; it = it.next_sibling()) {
        const char *nodename = it.name();
        auto hash = Space::Utils::MakeHash32(nodename);

        switch (hash) {
        case "Component"_Hash32: {
            ComponentImport ci;
            ci.xmlNode = it;
            ci.enabled = it.attribute("Enabled").as_bool(true) && parentEnabled;
            ci.active = it.attribute("Active").as_bool(true);
            std::string localRels = it.child("LocalRelations").text().as_string("");
            if(!localRels.empty())
                boost::split(ci.localRelationNames, localRels, boost::is_any_of(","));

            SubSystemId cid = SubSystemId::Invalid;
            if (!Component::ComponentRegister::ExtractCIDFromXML(it, cid)) {
                AddLogf(Warning, "Unknown component!");
                continue;
            }
            ci.entityIndex = entityIndex;

            auto &c = data.components[cid];
            auto found = std::find_if(c.begin(), c.end(), [entityIndex](const ComponentImport& import) { return import.entityIndex == entityIndex; });
            if (found != c.cend()) {
                *found = std::move(ci);
            } else {
                c.emplace_back(std::move(ci));
            }
            continue;
        }
        case "Child"_Hash32: 
        case "Entity"_Hash32:
        {
            EntityImport ei;
            ei.parentIndex = entityIndex;
            ei.enabled = it.attribute("Enabled").as_bool(true) && parentEnabled;
            ei.name = it.attribute("Name").as_string("");;

            int32_t index = static_cast<int32_t>(data.entities.size());
            if (ei.parentIndex >= 0)
                data.entities[ei.parentIndex].children[ei.name] = index;

            data.entities.emplace_back(std::move(ei));

            auto pattern = it.attribute("Pattern").as_string(nullptr);
            if (pattern) {                                 
                Import(data, pattern, index);
            } 
            Import(data, it, index);
            continue;
        }
        default:
            AddLogf(Warning, "Unknown node: %s", nodename);
            continue;
        }
    }
}

//-------------------------------------------------------------------------------------------------

bool EntityBuilder::LoadComponent(Entity parent, Entity owner, const ComponentImport &ci) {
    SubSystemId cid = SubSystemId::Invalid;

    if (!Component::ComponentRegister::ExtractCIDFromXML(ci.xmlNode, cid)) {
        AddLogf(Warning, "Unknown component!");
        return false;
    }

    MoonGlare::Component::ComponentReader reader{ m_Manager, ci.xmlNode };
    if (!ci.localRelationEntity.empty()) {
        reader.localRelations = &ci.localRelationEntity[0];
        reader.localRelationsCount = ci.localRelationEntity.size();
    }
    if (cid < SubSystemId::CoreBegin) {

        auto cci = static_cast<Component::ComponentClassId>(cid);
        bool r = m_Manager->GetComponentArray().Load(owner, cci, reader);
        if (r)
            m_Manager->GetComponentArray().SetActive(owner, ci.active, cci);
        return r;
    }   
             
    auto c = m_Manager->GetComponent(cid);
    if (!c) {
        AddLogf(Warning, "No such component: %d", cid);
        return false;
    }

    if (!c->Load(reader, parent, owner)) {
        AddLogf(Error, "Failure during loading component! cid:%d class: %s", cid, typeid(*c).name());
        return false;
    }

    return true;
}

} //namespace Core 
} //namespace MoonGlare 

