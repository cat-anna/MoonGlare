/*
  * Generated by cppsrc.sh
  * On 2015-05-19 17:27:02,94
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <nfMoonGlare.h>
#include "ModulesManager.h"

namespace MoonGlare {
namespace Modules {

SPACERTTI_IMPLEMENT_CLASS_SINGLETON(ModulesManager);

using ModuleInfoList =  ModulesManager::ModuleInfoList;

static ModuleInfoList *_ModuleList = 0;

static ModuleInfoList* ModuleList() {
	if (!_ModuleList) {
		_ModuleList = new ModuleInfoList();
		_ModuleList->reserve(StaticSettings::ModulesManager::ModuleReservedSpace);
	}
	return _ModuleList;
}

//----------------------------------------------------------------

ModuleInfo::ModuleInfo(const char *Name, ModuleType Type):
		m_Name(Name), m_Type(Type) {
	ModuleList()->push_back(this);
}
ModuleInfo::~ModuleInfo() { }
bool ModuleInfo::Initialize() { return true; }
bool ModuleInfo::Finalize() { return true; }
void ModuleInfo::Notify(NotifyEvent event) { /* ignore */ }
void ModuleInfo::Notify(SettingsGroup what) { /* ignore */ }
const ModuleDescription* ModuleInfo::GetDescription() const { return nullptr; }
void ModuleInfo::RegisterModuleApi(ApiInitializer &api) { /* ignore */ }
void ModuleInfo::RegisterInternalApi(ApiInitializer &api) { /* ignore */ }

//----------------------------------------------------------------

ModulesManager::ModulesManager() {
	SetThisAsInstance();
}

ModulesManager::~ModulesManager() {
}

//----------------------------------------------------------------

bool ModulesManager::Initialize() {
	auto list = ModuleList();
	std::sort(list->begin(), list->end(), [](const ModuleInfo* l, const ModuleInfo *r) -> bool {
		return (unsigned)l->GetType() < (unsigned)r->GetType();
	});
	for (auto it = list->rbegin(), jt = list->rend(); it != jt; ++it) {
		auto *module = *it;
		AddLogf(Debug, "Initializing module %s", module->GetName());
		if (!module->Initialize()) {
			AddLogf(Warning, "Unable to initialize module %s", module->GetName());
		}
	}
	return true;
}

bool ModulesManager::Finalize() {
	auto list = GetModuleList();
	for (auto it = list->begin(), jt = list->end(); it != jt; ++it) {
		auto *module = *it;
		AddLogf(Debug, "Finalizing module %s", module->GetName());
		if (!module->Finalize()) {
			AddLogf(Warning, "Unable to Finalize module %s", module->GetName());
		}
	}
	return true;
}

//----------------------------------------------------------------

void ModulesManager::BroadcastNotification(NotifyEvent event) {
	AddLogf(Debug, "Broadcasting event: %d.", (unsigned)event);
	if (!IsInitialized()) {
		AddLog(Error, "Unable to broadcast notification. Modules are not initialized!");
		return;
	}
	auto list = GetModuleList();
	for (auto &it: *list) {
		auto *module = it;
		module->Notify(event);
	}
}

void ModulesManager::BroadcastNotification(SettingsGroup what) {
	AddLogf(Debug, "Broadcasting settings changed notification: %d.", (unsigned)what);
	if (!IsInitialized()) {
		AddLog(Error, "Unable to broadcast notification. Modules are not initialized!");
		return;
	}
	auto list = GetModuleList();
	for (auto &it: *list) {
		auto *module = it;
		module->Notify(what);
	}
}

//----------------------------------------------------------------

const ModuleInfoList * ModulesManager::GetModuleList() {
	return _ModuleList;
}

#ifdef DEBUG_DUMP
void ModulesManager::DumpModuleList(std::ostream &out) {
	const char *pattern = "%30s %20s";
	char linebuf[1024];
	out << "Modules:\n";
	sprintf(linebuf, pattern, "Module name", "Type");
	out << linebuf << "\n";

	for (auto* module : *GetModuleList()) {
		char typebuf[64];

		sprintf(typebuf, "%s", ModuleTypeEnum::ToString(module->GetType()).c_str());

		sprintf(linebuf, pattern, module->GetName(), typebuf);
		out << linebuf << "\n";
	}
	out << "\n";
}
#endif

} //namespace Modules 
} //namespace MoonGlare 
