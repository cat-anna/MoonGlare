/*
	Generated by cppsrc.sh
	On 2015-01-11 18:15:28,46
	by Paweu
*/
#include <pch.h>
#include <MoonGlare.h>
#include "PlaneModel.h"
#include "SimpleModelConstructor.h"

namespace DataClasses {
namespace Models {

SPACERTTI_IMPLEMENT_STATIC_CLASS(PlaneModel);
ModelClassRegister::Register<PlaneModel> PlaneModelReg("PlaneModel");

PlaneModel::PlaneModel(const string &Name):
		BaseClass(Name) {
}

PlaneModel::~PlaneModel() {
}

//------------------------------------------------------------------------

bool PlaneModel::LoadPlanes(xml_node Node) {
	if (!Node) return false;

	math::vec3 Size(1, 1, 1);
	XML::Vector::Read(Node, "Size", Size, Size);
	math::vec3 HalfSize = Size / 2.0f;
	xml_node MaterialsNode = Node.child("Materials");

	std::unique_ptr<Models::SimpleModelConstructor> constr(new SimpleModelConstructor());
	std::map<string, SimpleModelConstructor::Material*> MaterialMap;
	auto GetMaterial =[&](const string& name) {
		auto it = MaterialMap.find(name); 
		if (it != MaterialMap.end()) {
			return it->second;
		}

		xml_node MaterialNode = MaterialsNode.find_child_by_attribute("Material", "Name", name.c_str());
		if (!MaterialNode) return (SimpleModelConstructor::Material*)0;

		auto material = constr->NewMaterial();
		material->SetMaterialNode(MaterialNode);
		MaterialMap[name] = material;
		return material;
	};

	xml_node Planes = Node.child("Planes");
	for (auto item = Planes.child("Distribute"); item; item = item.next_sibling("Distribute")) {
		auto material = GetMaterial(item.attribute("Material").as_string(""));

		auto mesh = constr->NewMesh();
		if (material)
			mesh->SelectMaterial(material->GetID());

		unsigned count = item.attribute("Count").as_uint();
		Physics::vec3 Rotation;
		XML::Vector::Read(item, "Rotation", Rotation);

		float angle = 0, dalpha = math::Constants::pi::value / (float)count;
		for (unsigned i = 0; i < count; ++i) {
			auto &s = HalfSize;

			float acos = cos(angle), asin = sin(angle);
			float bcos = cos(angle + math::Constants::pi::value), bsin = sin(angle + math::Constants::pi::value);

			math::vec3 Vertexes[4] = {
				math::vec3( s.x * bsin,  s.y,  s.z * bcos),
				math::vec3( s.x * asin,  s.y,  s.z * acos),
				math::vec3( s.x * asin, -s.y,  s.z * acos),
				math::vec3( s.x * bsin, -s.y,  s.z * bcos),
			};

			math::vec2 Texture[4] = {
				math::vec2(1, 1),
				math::vec2(0, 1),
				math::vec2(0, 0),
				math::vec2(1, 0),
			};
			mesh->PushQuad(Vertexes, 0, Texture);
			angle += dalpha;
		}
	}

	SimpleModelConstructor::EditableModelFields req;
	req.Reader = FileSystem::DirectoryReader(DataPath::Models, GetName());
	req.VAO = &m_VAO;
	req.Meshes = &m_Meshes;
	req.Materials = &m_Materials;
	req.ShapeConstructor = &m_ShapeConstructor;
	req.OwnerModel = this;
	if (!constr->GenerateModel(req)) {
		AddLog(Error, "Unable to generate mesh for plane model " << GetName());
		return false;
	}

	return true;
}

bool PlaneModel::LoadFromXML(const xml_node Node) {
	if (!Node) {
		AddLog(Error, "Attempt to load model from empty node!");
		return false;
	}

	if (!BaseClass::LoadFromXML(Node))
		return false;

	if (!LoadPlanes(Node)) {
		AddLog(Error, "Unable to load planes!");
		return false;
	}

	return true;
}

//------------------------------------------------------------------------

} //namespace Models 
} //namespace DataClasses 

