/*
	Generated by cppsrc.sh
	On 2014-12-26 20:10:07,32
	by Paweu
*/
#include <pch.h>

#define NEED_MATERIAL_BUILDER

#include <MoonGlare.h>
#include "SimpleModelImpl.h"

#include "Core/Engine.h"
#include <Renderer/Renderer.h>
#include <Renderer/Resources/ResourceManager.h>

namespace MoonGlare {
namespace DataClasses {
namespace Models {

SPACERTTI_IMPLEMENT_STATIC_CLASS(SimpleModelImpl);

SimpleModelImpl::SimpleModelImpl(const string& Name) :
		BaseClass(Name){
}

SimpleModelImpl::~SimpleModelImpl() {
}

//------------------------------------------------------------------------

bool SimpleModelImpl::Load(const std::string &Name) {

	if (Name.find("://") != std::string::npos) {
		return DoLoadModel(Name);
	}

	FileSystem::XMLFile xml;
	if (!GetFileSystem()->OpenResourceXML(xml, Name, DataPath::Models)) {
		AddLogf(Error, "Unable to open master resource xml for model '%s'", Name.c_str());
		return false;
	}
	return LoadFromXML(xml->document_element());
}

bool SimpleModelImpl::LoadFromXML(const xml_node Node) {
	if (!Node) {
		AddLog(Error, "Attempt to load model from empty node!");
		return false;
	}

	if (!BaseClass::LoadFromXML(Node))
		return false;

	string file = Node.child("File").text().as_string("");
	if (file.empty()) {
		AddLog(Error, "Model definition without file name!");
		return false;
	}

	file = "file:///Models/" + (GetName() + "/") += file;

	return DoLoadModel(file);
}

//------------------------------------------------------------------------

bool SimpleModelImpl::DoLoadModel(const std::string & fName) {
	StarVFS::ByteTable data;
	if (!GetFileSystem()->OpenFile(fName, DataPath::URI, data)) {
		AddLogf(Error, "Unable to load model: %s", GetName().c_str());
		return false;
	}
	Assimp::Importer importer;
	const aiScene* scene = importer.ReadFileFromMemory(
		data.get(), data.size(),
		aiProcess_JoinIdenticalVertices |/* aiProcess_PreTransformVertices | */aiProcess_Triangulate | aiProcess_GenUVCoords | aiProcess_SortByPType,
		strrchr(fName.c_str(), '.'));

	if (!scene) {
		AddLog(Error, "Unable to to load model file[Name:'" << GetName().c_str() << "']. Error: " << importer.GetErrorString());
		return false;
	}

	if (!DoLoadMeshes(scene)) {
		AddLogf(Error, "Unable to load model meshes: %s", GetName().c_str());
		return false;
	}

	return true;
}

bool SimpleModelImpl::LoadMaterial(unsigned index, const aiScene* scene, Renderer::MaterialResourceHandle &matout) {
	matout.Zero();
	if (index >= scene->mNumMaterials) {
		AddLogf(Error, "Invalid material index");
		return false;
	}

	const aiMaterial* aiMat = scene->mMaterials[index];
	if (aiMat->GetTextureCount(aiTextureType_DIFFUSE) <= 0) {
		AddLogf(Error, "No diffuse component");
		return false;
	}

	auto *e = Core::GetEngine();
	auto *rf = e->GetWorld()->GetRendererFacade();
	auto *resmgr = rf->GetResourceManager();
	MoonGlare::Renderer::Material *material = nullptr;

	aiString Path;
	if (aiMat->GetTexture(aiTextureType_DIFFUSE, 0, &Path, NULL, NULL, NULL, NULL, NULL) != AI_SUCCESS) {
		AddLogf(Error, "Unable to load material");
		return false;
	}

	if (Path.data[0] == '*') {
		////internal texture
		//auto idx = strtoul(Path.data + 1, nullptr, 10);
		//if (idx >= Scene->mNumTextures) {
		//	AddLogf(Error, "Invalid internal texture id!");
		//	return;
		//}
		//
		//auto texptr = Scene->mTextures[idx];
		//
		//if (texptr->mHeight == 0) {
		//	//raw image bytes
		//	if (!DataClasses::Texture::LoadTexture(m_Material.Texture, (char*)texptr->pcData, texptr->mWidth)) {
		//		AddLogf(Error, "Texture load failed!");
		//	}
		//}
		//else {
		//	AddLogf(Error, "NOT SUPPORTED!");
		//
		//}
		AddLogf(Error, "inner texture not supported yet");
		return false;
	}

	{
		FileSystem::DirectoryReader reader(DataPath::Models, GetName());
		auto fpath = reader.translate(Path.data);

		auto matb = resmgr->GetMaterialManager().GetMaterialBuilder(matout, true);
		matb.SetDiffuseMap("file://" + fpath);
		matb.SetDiffuseColor(emath::fvec4(1));
	}
}

bool SimpleModelImpl::DoLoadMeshes(const aiScene* scene) {
	Graphic::VertexVector verticles;
	Graphic::NormalVector normals;
	Graphic::TexCoordVector texCords;
	Graphic::IndexVector indices;

	unsigned NumVertices = 0, NumIndices = 0;
	m_Meshes.resize(scene->mNumMeshes);
	for (unsigned i = 0; i < m_Meshes.size(); i++) {
		MeshData &meshd = m_Meshes[i];
		meshd.NumIndices = scene->mMeshes[i]->mNumFaces * 3;
		meshd.BaseVertex = NumVertices;
		meshd.BaseIndex = NumIndices;
		meshd.ElementMode = Graphic::Flags::fTriangles;

		NumVertices += scene->mMeshes[i]->mNumVertices;
		NumIndices += meshd.BaseIndex;
	}

	verticles.reserve(NumVertices);
	normals.reserve(NumVertices);
	texCords.reserve(NumVertices);
	indices.reserve(NumIndices);

	std::vector<Renderer::MaterialResourceHandle> Materials;
	Materials.resize(scene->mNumMaterials, {});

	for (unsigned i = 0; i < m_Meshes.size(); ++i) {
		const aiMesh* mesh = scene->mMeshes[i];
		MeshData& meshd = m_Meshes[i];

		auto matidx = mesh->mMaterialIndex;
		if (!Materials[matidx].deviceHandle) {//wrong method
			if (!LoadMaterial(matidx, scene, Materials[matidx])) {
				DebugLogf(Warning, "Failed to load matertial index %u", matidx);
			}
		} 
		meshd.m_Material = Materials[matidx];

		for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
			aiVector3D &vertex = mesh->mVertices[j];
			aiVector3D &normal = mesh->mNormals[j];

			if (mesh->mTextureCoords[0]) {
				aiVector3D &UVW = mesh->mTextureCoords[0][j]; // Assume only 1 set of UV coords; AssImp supports 8 UV sets.
				math::vec2 uv(UVW.x, UVW.y);

				texCords.push_back(uv);
			} else {
				texCords.push_back(math::vec2());
			}

			verticles.push_back(math::vec3(vertex.x, vertex.y, vertex.z));
			normals.push_back(math::vec3(normal.x, normal.y, normal.z));
		}

		for (unsigned int k = 0; k < mesh->mNumFaces; k++) {
			aiFace *f = &mesh->mFaces[k];
			THROW_ASSERT(f->mNumIndices == 3, 0);
			for (unsigned j = 0; j < 3; ++j) {
				indices.push_back(f->mIndices[j]);
			}
		}
	}

	m_VAO.DelayInit(verticles, texCords, normals, indices);

/*
	m_VAO.New();
	m_VAO.AddDataChannel<3, float>(&verticles[0][0], verticles.size());
	m_VAO.AddDataChannel<2, float>(&texCords[0][0], texCords.size());
	m_VAO.AddDataChannel<3, float>(&normals[0][0], normals.size());
	m_VAO.WriteIndexes<>(&indices[0], indices.size());
	m_VAO.UnBind();
*/

	return true;
}

//------------------------------------------------------------------------

} //namespace Models 
} //namespace DataClasses 
} //namespace MoonGlare 
