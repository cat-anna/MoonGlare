/*
	Generated by cppsrc.sh
	On 2015-02-04 22:27:32,09
	by Paweu
*/

#include <pch.h>
#include <MoonGlare.h>
#include "StaticPath.h"

namespace DataClasses {
namespace Paths {

GABI_IMPLEMENT_CLASS(StaticPath);
RegisterApiDerivedClass(StaticPath, &StaticPath::RegisterScriptApi);
::Core::Interfaces::AutoResourceClassReg<StaticPath> StaticPathReg;

StaticPath::StaticPath(DataModule *DataModule):
		BaseClass(DataModule) {
}

StaticPath::~StaticPath() {
}

void StaticPath::RegisterScriptApi(ApiInitializer &api) {
	api
	.deriveClass<ThisClass, BaseClass>("cStaticPath")
	.endClass();
}

bool StaticPath::DoInitialize() {
	return BaseClass::DoInitialize();
}

bool StaticPath::DoFinalize() {
	return BaseClass::DoFinalize();
}

float StaticPath::Length() const {
	return m_Length;
}

Physics::vec3 StaticPath::PositionAt(float t) const {
	if (t >= 1.0f && IsRepetitive())
		t -= (int)t;
	else {
		return m_Nodes.back();
	}
	unsigned NodeCount = m_Nodes.size() - 1;
	float AbsolutePos = t * (float)NodeCount;
	auto IndexPos = static_cast<int>(AbsolutePos);
	float RelativePos = AbsolutePos - IndexPos;
	IndexPos %= (int)NodeCount;

	return math::LinearVectorMix(m_Nodes[IndexPos], m_Nodes[IndexPos + 1], RelativePos);
}

bool StaticPath::UpdatePosition(PathCalcState &state) const {
	if (state.Position >= 1.0f){
		if (IsRepetitive()) {
			state.Position -= (int)state.Position;
			state.Repeated = true;
		} else 
			state.Position = 1.0f;
	} else {
		if (state.Position < 0.0f) {
			if (IsRepetitive()) {
				state.Position = state.Position - (int)state.Position;
				state.Repeated = true;
			} else 
				state.Position = 0.0f;
		}
	}

	unsigned NodeCount = m_Nodes.size();
	unsigned Sections = m_SectionLengths.size();

	float AbsolutePos = state.Position * (float)Sections;
	auto IndexPos = static_cast<int>(AbsolutePos);
	float RelativePos = AbsolutePos - IndexPos;
	IndexPos %= (int)Sections;

	auto &node1 = m_Nodes[IndexPos];
	int index2 = (IndexPos + 1) % NodeCount;
	auto &node2 = m_Nodes[index2];

	state.PreviousLocation = state.Location;
	state.Location = math::LinearVectorMix(node2, node1, RelativePos);
	state.Direction = (node2 - node1).normalize();

	if (state.Speed != 0) {
		state.Position += state.Speed / (float)m_SectionLengths[IndexPos] / (float)Sections;
	}

	return true;
}

bool StaticPath::LoadMeta(const xml_node Node) {
	if (!Node) return false;

	m_SectionLengths.clear();

	auto FlagsNode = Node.child("Flags");
	SetRepetitive(FlagsNode.attribute("Repetitive").as_bool(false));

	XML::ForEachChild(Node.child("Nodes"), "Item", [this](xml_node node) -> int {
		Physics::vec3 vec;
		if (!XML::Vector::Read(node, 0, vec)) {
			AddLog(Error, "Unable to read node for static path!");
			m_Nodes.clear();
			return 1;
		}

		m_Nodes.push_back(vec);
		return 0;
	});

	//if there is only one node there is no point :)
	if (m_Nodes.size() < 2) 
		m_Nodes.clear();

	m_Nodes.shrink_to_fit();

	if (!m_Nodes.empty()) {
		m_Length = 0.0f;
		m_SectionLengths.resize(m_Nodes.size());
		for (int i = 0, j = m_Nodes.size() - 1; i < j; ++i) {
			float l = m_Nodes[i].distance(m_Nodes[i + 1]);
			m_Length += l;
			m_SectionLengths[i] = l;
		}
		if (IsRepetitive()) {
			float l = m_Nodes[0].distance(m_Nodes[m_Nodes.size() - 1]);
			m_Length += l;
			m_SectionLengths.back() = l;
		}
	}
	
	return !m_Nodes.empty();
}

} //namespace Paths 
} //namespace DataClasses 
