/*
  * Generated by cppsrc.sh
  * On 2015-03-08 19:20:50,34
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <nfMoonGlare.h>
#include "StringTable.h"

namespace DataClasses {

SPACERTTI_IMPLEMENT_STATIC_CLASS(StringTable)
//RegisterApiDerivedClass(StringTable, &StringTable::RegisterScriptApi);

StringTable::StringTable() {
}

StringTable::~StringTable() {
}

//----------------------------------------------------------------------------------

//void StringTable::RegisterScriptApi(ApiInitializer &api) {
//	api
//		.deriveClass<ThisClass, BaseClass>("cStringTable")
//		.addFunction("Get", ThisClass::GetString)
//#ifdef DEBUG_SCRIPTAPI
//		.addFunction("Clear", ThisClass::Clear)
//#endif
//		.endClass()
//		;
//}

//------------------------------------------------------------------------------------------

bool StringTable::Load(const string& TableName) {
	XMLFile TableFile, TableTranslationFile;
	char buf[256];
	sprintf(buf, "%s.%s.xml", TableName.c_str(), ::Settings->Localization.Code.c_str());
	if (!GetFileSystem()->OpenXML(TableTranslationFile, buf, DataPath::Tables)) {
		AddLogf(Warning, "Unable to load translation string table xml file! Table: '%s' File: '%s'", TableName.c_str(), buf);
	}
	sprintf(buf, "%s.xml", TableName.c_str());
	if (!GetFileSystem()->OpenXML(TableFile, buf, DataPath::Tables)) {
		AddLogf(Debug, "Unable to load string table xml file! Table: '%s' File: '%s'", TableName.c_str(), buf);
	}
	 
	if (!TableFile && !TableTranslationFile) {
		AddLogf(Error, "Unable to load string table xml files! Table: '%s'", TableName.c_str());
		return false;
	}

	auto &table = m_TableMap[TableName];
	table.XMLTable.swap(TableFile);
	table.XMLTableTranslation.swap(TableTranslationFile);
	table.StringMap.clear();
	return true;
}

void StringTable::Clear() {
	m_TableMap.clear();
}

//------------------------------------------------------------------------------------------

static string __NoTable("{Unable to load string table}");
static string __NoString("{String does not exists}");
static string __EmptyString("");

const string& StringTable::GetString(const string& id, const string& Table) {
	if (id.empty()) {
		return __EmptyString;
	}
	auto tableit = m_TableMap.find(Table);
	if (tableit == m_TableMap.end()) {
		if (!Load(Table)) {
			AddLogf(Error, "Unable to load table string '%s' to read string '%s'", Table.c_str(), id.c_str());
			return __NoTable;
		}
		return GetString(id, Table);
	}

	auto &tableinfo = tableit->second;
	auto stringit = tableinfo.StringMap.find(id);
	if (stringit == tableinfo.StringMap.end()) {
		string Result;
		auto LookupTable = [&id, &Result](XMLFile &file)->bool {
			if (!file) return false;
			auto tablenode = file->document_element();
			auto stringnode = tablenode.find_child_by_attribute("Id", id.c_str());
			if (!stringnode) return false;

			Result = stringnode.text().as_string(__NoString.c_str());
			return true;
		};
		do {
			if (LookupTable(tableinfo.XMLTableTranslation)) break;
			if (LookupTable(tableinfo.XMLTable)) break;
			AddLogf(Error, "String '%s' does not exists in table '%s'", id.c_str(), Table.c_str());
			Result = __NoString;
		} while (0);
		tableinfo.StringMap[id] = std::move(Result);
		return tableinfo.StringMap[id];
	}
	return stringit->second;
}

} //namespace DataClasses 
