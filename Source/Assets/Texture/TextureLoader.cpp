/*
  * Generated by cppsrc.sh
  * On 2017-02-04 20:57:16,59
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "../AssetManager.h"
#include "../FileSystem.h"
#include "TextureLoader.h"

#include "FreeImageUtils.h"

namespace MoonGlare::Asset::Texture {

Loader::Loader(FileSystem *fs):
    m_FileSystem(fs) {

    MoonGlareAssert(fs);
}

Loader::~Loader() {
}

//---------------------------------------------------------------------------------------

void Loader::Initialize() {
#ifndef _DISABLE_FREEIMAGE_LIB_
    FreeImage_SetOutputMessage(FreeImageErrorHandler);
#endif 
#ifdef DEBUG
    AddLog(System, "FreeImage version: " << FreeImage_GetVersion());
#endif
}

void Loader::Finalize() {
}

//---------------------------------------------------------------------------------------

void Loader::StoreScreenShot(TexturePixelData out) {
#ifndef _DISABLE_FREEIMAGE_LIB_

    char buf[128];
    std::time_t t = std::time(NULL);
    auto tm = *std::localtime(&t);
    sprintf(buf, "ScreenShot_%d-%d-%d_%d-%d-%d.png", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);

    //if (image->value_type == Graphic::Flags::fBGR) {
    //    SwapRedAndBlue((FIBITMAP*)image->FIImage);
    //    image->value_type = Graphic::Flags::fRGB;
    //}

    //if (image->value_type == Graphic::Flags::fBGRA) {
    //    SwapRedAndBlue((FIBITMAP*)image->FIImage);
    //    image->value_type = Graphic::Flags::fRGBA;
    //}

    FreeImage_Save(FIF_PNG, (FIBITMAP*)out.m_ImageMemory.get(), buf, 0);
#endif
}

Loader::TexturePixelData Loader::AllocateImage(PixelFormat pf, const emath::usvec2 &Size) {
#ifndef _DISABLE_FREEIMAGE_LIB_

    auto bpp = BppFromPixelFormat(pf);
    FIBITMAP *dib = FreeImage_Allocate(Size[0], Size[1], static_cast<int>(bpp));

    TexturePixelData out;
    out.m_PixelType = ValueFormat::UnsignedByte;
    out.m_PixelFormat = pf;
    out.m_PixelSize = Size;
    out.m_ImageMemory = ImageUniquePtr((void*)dib, &DibDeallocator);
    out.m_PixelsByteSize = Size[0] * Size[1] * (bpp / 8);
    out.m_Pixels = FreeImage_GetBits(dib);

    return out;
#else
    return TexturePixelData();
#endif
}

bool Loader::LoadTexture(const std::string &fpath, TexturePixelData & out) {
    return LoadTextureURI(fpath, out, true);
}

bool Loader::LoadTextureMeta(const std::string &fpath, TexturePixelData &out) {
    return LoadTextureURI(fpath, out, false);
}

//---------------------------------------------------------------------------------------

bool Loader::LoadTextureMemory(const void * ImgData, unsigned ImgLen, TexturePixelData &out, bool LoadPixels) {
#ifdef _DISABLE_FREEIMAGE_LIB_
    return false;
#else
    FIMEMORY *fim = FreeImage_OpenMemory((BYTE*)ImgData, ImgLen);
    FREE_IMAGE_FORMAT fif = FreeImage_GetFileTypeFromMemory(fim);

    int flags = 0;
    switch (fif) {
    case FIF_PNG:
        //flags |= PNG_IGNOREGAMMA;
        break;
    default:
        break;
    }

    if (!LoadPixels)
        flags |= FIF_LOAD_NOPIXELS;

    FIBITMAP *dib = FreeImage_LoadFromMemory(fif, fim, flags);
    FreeImage_CloseMemory(fim);
    if (!dib) 
        return false;

    switch (fif) {
    case FIF_PNG: //png images need to be flipped
                  //	FreeImage_FlipVertical(dib);
        break;
    default:
        //nothing todo
        break;
    }

    //FreeImage_FlipVertical(dib);
    //FreeImage_FlipHorizontal(dib);
    switch (FreeImage_GetBPP(dib)) {
    case 32:
        if(LoadPixels)
            SwapRedAndBlue(dib);
        out.m_PixelFormat = PixelFormat::RGBA8;
        break;
    case 24:
        if (LoadPixels && fif != FIF_PNG)
            SwapRedAndBlue(dib);
        out.m_PixelFormat = PixelFormat::RGB8;
        break;
    default: {
        if (LoadPixels) {
            FIBITMAP *dib24 = FreeImage_ConvertTo24Bits(dib);
            FreeImage_Unload(dib);
            dib = dib24;
            SwapRedAndBlue(dib);
        }
        out.m_PixelFormat = PixelFormat::RGB8;
    }
    }

    out.m_PixelType = ValueFormat::UnsignedByte;
    out.m_PixelSize = emath::usvec2(FreeImage_GetWidth(dib), FreeImage_GetHeight(dib));
    out.m_PixelsByteSize = out.m_PixelSize[0] * out.m_PixelSize[1] * (FreeImage_GetBPP(dib) / 8);

    if (LoadPixels) {
        out.m_Pixels = FreeImage_GetBits(dib);
        out.m_ImageMemory = ImageUniquePtr((void*)dib, &DibDeallocator);
    } else {
        out.m_Pixels = nullptr;
    }
    return true;
#endif
}

bool Loader::LoadTextureURI(const std::string & URI, TexturePixelData & out, bool LoadPixels) {
    StarVFS::ByteTable data;
    if (!GetFileSystem()->OpenFile(URI, DataPath::URI, data)) {
        //already logged, no need for more
        return false;
    }

    return LoadTextureMemory((char*)data.get(), data.byte_size(), out, LoadPixels);
}

} //namespace MoonGlare::Asset::Texture
