/*
  * Generated by cppsrc.sh
  * On 2017-02-04 20:57:07,50
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef Preprocessor_H
#define Preprocessor_H

namespace MoonGlare::Asset::Shader {

class Preprocessor final {
public:
 	Preprocessor(FileSystem *fs);
 	~Preprocessor();

	struct ParseException {
		std::string m_FileName;
		std::string m_Message;
		int m_IncludeLevel;
	};

	void PushFile(const std::string &Name) throw(ParseException);
	void GetOutput(std::string &Output);

	void ClearOutput();
	void Clear();

	void Define(std::string id, std::string value) { m_Defines[id] = value; }
	void Define(std::string id, const char* value) { m_Defines[id] = value; }
	template<typename T> void Define(std::string id, T t) { Define(id, std::to_string(t)); }

	void DefineString(std::string id, std::string value) { Define(id, '"' + value + '"'); }
	void DefineString(std::string id, const char* value) { DefineString(id, value); }
	template<typename T> void DefineString(std::string id, T t) { DefineString(id, std::to_string(t)); }
private: 
	FileSystem *m_FileSystem;

	std::unordered_map<std::string, std::string> m_Defines;
	std::unordered_map<std::string, bool> m_IncludedFiles;

	struct OutputBuffer : public std::list<std::string> {
		template<typename ... ARGS>
		void pushf(const char *fmt, ARGS&& ... args) {
			char buf[4 * 1024];
			sprintf_s(buf, fmt, std::forward<ARGS>(args)...);
			push_back(buf);
		}
		void pushs(const char *fmt, const std::string &str) {
			pushf(fmt, str.c_str());
		}
	};
	OutputBuffer m_OutputBuffer;

	using ReadBuffer = std::list<std::string>;

	bool ReadFile(const std::string &FName, ReadBuffer &out);
	void Process(const std::string &FName, int level);
	void GenerateDefines();

	using PreprocessorTokenHadler = void(Preprocessor::*)(const std::string &FName, std::string &line, int level, std::smatch match);

	void IncludeToken(const std::string &FName, std::string &line, int level, std::smatch match);

	struct PreprocessorToken {
		std::regex m_RegExp;
		PreprocessorTokenHadler m_Handler;
	};
	static const std::array<PreprocessorToken, 1> s_Tokens;
};

} //namespace MoonGlare::Asset::Shader 

#endif
