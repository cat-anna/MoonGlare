/*
  * Generated by cppsrc.sh
  * On 2017-02-09 21:46:28,36
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#pragma once

#include "nfRenderer.h"
#include "Configuration.Renderer.h"

#include "TextureRenderTask.h"

namespace MoonGlare::Renderer {

class RendererFacade;

class alignas(16) RenderDevice final {
    using ThisClass = RenderDevice;
    using Conf = Configuration::FrameBuffer;
public:
    bool Initialize(RendererFacade *renderer);
    bool Finalize();
    
    Frame* NextFrame();
    void Submit(Frame *frame);
    void ReleaseFrame(Frame *frame);
    Frame* PendingFrame();

    bool IsFramePending() const { return m_PendingFrame.load() != nullptr; }

    void Step();
    void ProcessPendingCtrlQueues();

    TextureRenderTask* AllocateTextureRenderTask() {
        RendererAssert(this);
        return m_UnusedTextureRender.pop(nullptr);
    }

    bool CommitControlCommandQueue(Commands::CommitCommandQueue *queue) {
        Commands::CommitCommandQueue* null = nullptr;
        return m_CommitCommandQueue.compare_exchange_weak(null, queue);
    }

    uint64_t FrameCounter() const { return frameCouter; }
private:
    std::array<mem::aligned_ptr<Frame>, Conf::Count> m_Frames;
    std::atomic<uint32_t> m_FreeFrameBuffers = 0;
    std::atomic<Frame*> m_PendingFrame = nullptr;
    std::atomic<Commands::CommitCommandQueue*> m_CommitCommandQueue = nullptr;
    uint64_t frameCouter = 0;

    Space::Container::StaticVector<TextureRenderTask*, Configuration::TextureRenderTask::Limit> m_UnusedTextureRender;
    std::array<TextureRenderTask, Configuration::TextureRenderTask::Limit> m_TextureRenderTask;

    RendererFacade *m_RendererFacade = nullptr;

    DeclarePerformanceCounter(DroppedFrames);
    DeclarePerformanceCounter(FramesProcessed);
    
    void ProcessFrame(Frame *frame);
};

} //namespace MoonGlare::Renderer
