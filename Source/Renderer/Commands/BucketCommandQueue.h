/*
* Generated by cppsrc.sh
* On 2016-09-21 19:16:53,84
* by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once

#include "../nfRenderer.h"
#include "../Configuration.Renderer.h"
#include "CommandQueueBase.h"

namespace MoonGlare::Renderer {

class alignas(16) BucketCommandQueue final {
	using Conf = Configuration::CommandBucket;
public:
	BucketCommandQueue() {
		Clear();
	}
	BucketCommandQueue(const BucketCommandQueue&) = delete;
	BucketCommandQueue(BucketCommandQueue&&) = delete;
	const BucketCommandQueue& operator = (const BucketCommandQueue&) = delete;
	const BucketCommandQueue& operator = (BucketCommandQueue&&) = delete;

	uint32_t BucketsCapacity() const {
		return Conf::MaxBuckets;
	}
	uint32_t MemoryCapacity() const {
		return Conf::ArgumentMemoryBuffer;
	}
	uint32_t MemoryAllocated() const {
		return m_AllocatedMemory;
	}
	uint32_t BucketsAllocated() const {
		return m_AllocatedBuckets;
	}
	bool IsEmpty() const {
		return BucketsAllocated() == 0;
	}
	bool IsFull() const {
		return BucketsAllocated() >= BucketsCapacity();
	}

	void Clear() {
		m_AllocatedBuckets = 0;
		m_AllocatedMemory = 0;
	}
	void MemZero() {
		memset(this, 0, sizeof(*this));
	}

	void Execute(bool DoClear = true) {
		for (uint32_t it = 0; it < m_AllocatedBuckets; ++it) {
			auto first = m_BucketFirstCommand[it];
			auto limit = first + m_BucketCommandCount[it];
			for (Conf::BucketCommandIndex idx = first; idx < limit; ++idx) {
				auto f = m_CommandFunctions[idx];
				auto a = m_CommandArguments[idx];
				f(a);
			}
		}
		if (DoClear)
			Clear();
	}

	void SortAndExecute() {
	//	Sort();
		Execute();
	}


	template<typename BUCKET>
	BUCKET CreateBucket(CommandKey SortKey) {
		BUCKET b;
		b.m_Queue = this;
//		auto *argptr = AllocateMemory<CMD::Argument>(CMD::ArgumentSize());
//		if (IsFull() || !argptr) {
//			AddLogf(Warning, "Command queue is full. Command %s has not been allocated!", typeid(CMD).name());
//			return nullptr;
//		}
//		
//		size_t index = m_AllocatedCommands;
//		++m_AllocatedCommands;
//		
//		m_CommandFunctions[index] = CMD::GetFunction();
//		m_CommandArguments[index] = argptr;
//		//SortKey.m_Details.m_Order = (uint16_t)SortKey.m_Details.m_Ptr;
//		//SortKey.m_Details.m_Ptr = (uint32_t)argptr;
//		m_SortKeys[index] = SortKey;
//		
//		return argptr;
		return b;
	}

private:
	uint16_t m_AllocatedBuckets;
	uint16_t m_AllocatedCommands;

	uint32_t m_AllocatedMemory;
	uint64_t m_padding64;

	template<typename T> using BucketArray = std::array<T, Conf::MaxBuckets>;
	BucketArray<CommandKey> m_BucketKeys;
	BucketArray<Conf::BucketCommandCount> m_BucketCommandCount;
	BucketArray<Conf::BucketCommandIndex> m_BucketFirstCommand;

	template<typename T> using CommandArray = std::array<T, Conf::MaxCommands>;
	CommandArray<CommandArgument> m_CommandArguments;
	CommandArray<CommandFunction> m_CommandFunctions;

	std::array<uint8_t, Conf::ArgumentMemoryBuffer> m_Memory;
#if 0
	uint16_t m_CommandsPreamble;
	uint16_t m_MemoryPreamble;
//

	void SetQueuePreamble() {
		m_CommandsPreamble = m_AllocatedCommands;
		m_MemoryPreamble = m_AllocatedMemory;
	}

	void ClearAllocation() {
		m_AllocatedCommands = m_CommandsPreamble;
		m_AllocatedMemory = m_MemoryPreamble;
	}

	void Sort() {
		if (!IsEmpty()) {
			m_SortKeys[m_AllocatedCommands].m_UIntValue = 0xFFFF;
			SortBegin(static_cast<int>(m_CommandsPreamble), static_cast<int>(m_AllocatedCommands));
		}
	}

	template<typename CMD>
	typename CMD::Argument* PushCommand(RendererConf::CommandKey SortKey) {
		auto *argptr = AllocateMemory<CMD::Argument>(CMD::ArgumentSize());
		if (IsFull() || !argptr) {
			AddLogf(Warning, "Command queue is full. Command %s has not been allocated!", typeid(CMD).name());
			return nullptr;
		}

		size_t index = m_AllocatedCommands;
		++m_AllocatedCommands;

		m_CommandFunctions[index] = CMD::GetFunction();
		m_CommandArguments[index] = argptr;
		//SortKey.m_Details.m_Order = (uint16_t)SortKey.m_Details.m_Ptr;
		//SortKey.m_Details.m_Ptr = (uint32_t)argptr;
		m_SortKeys[index] = SortKey;

		return argptr;
	}

	struct RollbackPoint {
		uint32_t m_CommandCount;
		uint32_t m_MemoryUsed;
	};

	//unsafe; Rolling-back has to be used carefully
	RollbackPoint GetSavePoint() const {
		return RollbackPoint{ m_AllocatedCommands, m_AllocatedMemory };
	}
	//unsafe; Rolling-back has to be used carefully
	void Rollback(RollbackPoint point) {
		m_AllocatedCommands = point.m_CommandCount; m_AllocatedMemory = point.m_MemoryUsed;
	}
private:
	template<typename T> using Array = std::array<T, RendererConf::CommandQueue::CommandLimit>;

	template<typename T>
	T* AllocateMemory(uint32_t size) {
		if (m_AllocatedMemory + size >= MemoryCapacity())
			return nullptr;

		T *ptr = reinterpret_cast<T*>(&m_Memory[0] + m_AllocatedMemory);
		m_AllocatedMemory += size;
		return ptr;
	}

	uint32_t m_AllocatedCommands;

	Array<CommandFunction> m_CommandFunctions;
	Array<void*> m_CommandArguments;
	Array<RendererConf::CommandKey> m_SortKeys;

	void SortBegin(int first, int last);
#endif
};

static_assert((sizeof(BucketCommandQueue) & 0xF) == 0, "Invalid size!");
//static_assert(std::is_trivial<BucketCommandQueue>::value, "Mut be trivial!");
//static_assert(std::is_pod<BucketCommandQueue>::value, "Mut be trivial!");
//#TODO

} //namespace MoonGlare::Renderer 
