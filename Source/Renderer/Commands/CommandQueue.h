/*
  * Generated by cppsrc.sh
  * On 2016-09-21 19:16:53,84
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once

#include "../nfRenderer.h"
#include "CommandQueueBase.h"

namespace MoonGlare::Renderer::Commands {

//vitality and copying is forbidden
//should be zeroed manually before first use!
class alignas(16) CommandQueue final {
	using Conf = Configuration::CommandQueue;
public:
	uint32_t CommandsCapacity() const { return Conf::CommandLimit; }
	uint32_t CommandsAllocated() const { return m_AllocatedCommands; }
	uint32_t MemoryCapacity() const { return Conf::ArgumentMemoryBuffer; }
	uint32_t MemoryAllocated() const { return m_AllocatedMemory; }

	bool IsEmpty() const { return CommandsAllocated() == 0; }
	bool IsFull() const { return CommandsAllocated() >= CommandsCapacity(); }

	void SortExecuteClear() {
		Sort();
		Execute();
	}
	void Execute(bool Clear = true) {
		RendererAssert(this);
		for (uint32_t it = 0; it < m_AllocatedCommands; ++it) {
			auto f = m_CommandFunctions[it];
			auto a = m_CommandArguments[it];
			f(a);
		}
		if (Clear) 
			ClearAllocation();
	}

	void MemZero() { memset(this, 0, sizeof(*this)); }
	void ClearAllocation() { 
		m_AllocatedCommands = m_CommandsPreamble;
		m_AllocatedMemory = m_MemoryPreamble;
	}
	void Clear() {
		m_AllocatedCommands = m_CommandsPreamble = 0;
		m_AllocatedMemory = m_MemoryPreamble = 0;
	}

	void Sort() {
		if (!IsEmpty()) {
			m_SortKeys[m_AllocatedCommands].m_UIntValue = 0xFFFF;
			SortBegin(static_cast<int>(m_CommandsPreamble), static_cast<int>(m_AllocatedCommands));
		}
	}

	template<typename CMD>
	typename CMD::Argument* PushCommand(CommandKey SortKey = CommandKey()) {
		auto *argptr = AllocateMemory<CMD::Argument>(CMD::ArgumentSize());
		if (IsFull() || !argptr) {
			AddLogf(Warning, "Command queue is full. Command %s has not been allocated!", typeid(CMD).name());
			return nullptr;
		}

		size_t index = m_AllocatedCommands;
		++m_AllocatedCommands;

		m_CommandFunctions[index] = CMD::GetFunction();
		m_CommandArguments[index] = argptr;
		m_SortKeys[index] = SortKey;

		return argptr;
	}


	template<typename CMD, typename ... ARGS>
	typename CMD::Argument* MakeCommand(ARGS&& ... args) {
		auto *argptr = AllocateMemory<CMD::Argument>(CMD::ArgumentSize());
		if (IsFull() || !argptr) {
			AddLogf(Warning, "Command queue is full. Command %s has not been allocated!", typeid(CMD).name());
			return nullptr;
		}

		size_t index = m_AllocatedCommands;
		++m_AllocatedCommands;

		m_CommandFunctions[index] = CMD::GetFunction();
		m_CommandArguments[index] = argptr;
		m_SortKeys[index] = CommandKey();

		return new(argptr)CMD::Argument{ std::forward<ARGS>(args)... };
	}

	struct ExecuteQueueArgument {
		CommandQueue *m_Queue;
		static void Execute(const ExecuteQueueArgument *arg) {
			RendererAssert(arg->m_Queue);
			arg->m_Queue->Execute();
		}
	};
	using ExecuteQueue = CommandTemplate<ExecuteQueueArgument>;

	bool PushQueue(CommandQueue *queue, CommandKey key = CommandKey()) {
		if (!queue) {
			AddLogf(Warning, "Attempt to queue null queue!");
			return false;
		}
		auto *argptr = AllocateMemory<ExecuteQueue::Argument>(ExecuteQueue::ArgumentSize());
		if (IsFull() || !argptr) {
			AddLogf(Warning, "Command queue is full. Command %s has not been allocated!", typeid(ExecuteQueue).name());
			return false;
		}

		size_t index = m_AllocatedCommands;
		++m_AllocatedCommands;

		m_CommandFunctions[index] = ExecuteQueue::GetFunction();
		m_CommandArguments[index] = argptr;
		m_SortKeys[index] = key;

		argptr->m_Queue = queue;

		return true;
	}

	void SetQueuePreamble() {
		m_CommandsPreamble = m_AllocatedCommands;
		m_MemoryPreamble = m_AllocatedMemory;
	}

	struct RollbackPoint {
		uint32_t m_CommandCount;
		uint32_t m_MemoryUsed;
	};

	//To be removed?
	//unsafe; Rolling-back has to be used carefully
	RollbackPoint GetSavePoint() const { return RollbackPoint{ m_AllocatedCommands, m_AllocatedMemory }; }
	//unsafe; Rolling-back has to be used carefully
	void Rollback(RollbackPoint point) { m_AllocatedCommands = point.m_CommandCount; m_AllocatedMemory = point.m_MemoryUsed; }
private: 
	template<typename T> using Array = std::array<T, Conf::CommandLimit>;

	template<typename T>
	T* AllocateMemory(uint32_t size) {
		if (m_AllocatedMemory + size >= MemoryCapacity())
			return nullptr;

		T *ptr = reinterpret_cast<T*>(&m_Memory[0] + m_AllocatedMemory);
		m_AllocatedMemory += size;
		return ptr;
	}

	//TODO make this class atomic
	
	uint32_t m_AllocatedCommands;
	uint32_t m_AllocatedMemory;
	uint32_t m_CommandsPreamble;
	uint32_t m_MemoryPreamble;

	Array<CommandFunction> m_CommandFunctions;
	Array<void*> m_CommandArguments;
	std::array<uint8_t, Conf::ArgumentMemoryBuffer> m_Memory;
	Array<CommandKey> m_SortKeys;

	void SortBegin(int first, int last);
};

static_assert((sizeof(CommandQueue) % 16) == 0, "Invalid size!");

using ExecuteQueue = CommandQueue::ExecuteQueue;

} //namespace MoonGlare::Renderer::Commands
