/*
  * Generated by cppsrc.sh
  * On 2016-09-21 19:16:53,84
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once

#include "CommandQueueBase.h"

namespace MoonGlare::Renderer {

//vitality and copying is forbidden
//should be zeroed manually before first use!
class alignas(16) CommandQueue final {
	using Conf = Configuration::CommandQueue;
public:
	CommandQueue() { ClearAllocation(); }
	CommandQueue(const CommandQueue&) = delete;
	CommandQueue(CommandQueue&&) = delete;
	const CommandQueue& operator = (const CommandQueue&) = delete;
	const CommandQueue& operator = (CommandQueue&&) = delete;
 	~CommandQueue() { }

	uint32_t CommandsCapacity() const { return Conf::CommandLimit; }
	uint32_t CommandsAllocated() const { return m_AllocatedCommands; }
	uint32_t MemoryCapacity() const { return Conf::ArgumentMemoryBuffer; }
	uint32_t MemoryAllocated() const { return m_AllocatedMemory; }

	bool IsEmpty() const { return CommandsAllocated() == 0; }
	bool IsFull() const { return CommandsAllocated() >= CommandsCapacity(); }

	void SortExecuteClear() {
		Sort();
		Execute();
	}
	void Execute(bool Clear = true) {
		for (uint32_t it = 0; it < m_AllocatedCommands; ++it) {
			auto f = m_CommandFunctions[it];
			auto a = m_CommandArguments[it];
			f(a);
		}
		if (Clear) 
			ClearAllocation();
	}

	void MemZero() { memset(this, 0, sizeof(*this)); }
	void ClearAllocation() { 
		m_AllocatedCommands = m_CommandsPreamble;
		m_AllocatedMemory = m_MemoryPreamble; 
	}

	void Sort() {
		if (!IsEmpty()) {
			m_SortKeys[m_AllocatedCommands].m_UIntValue = 0xFFFF;
			SortBegin(static_cast<int>(m_CommandsPreamble), static_cast<int>(m_AllocatedCommands));
		}
	}

	template<typename CMD>
	typename CMD::Argument* PushCommand(CommandKey SortKey) {
		auto *argptr = AllocateMemory<CMD::Argument>(CMD::ArgumentSize());
		if (IsFull() || !argptr) {
			AddLogf(Warning, "Command queue is full. Command %s has not been allocated!", typeid(CMD).name());
			return nullptr;
		}

		size_t index = m_AllocatedCommands;
		++m_AllocatedCommands;

		m_CommandFunctions[index] = CMD::GetFunction();
		m_CommandArguments[index] = argptr;
		//SortKey.m_Details.m_Order = (uint16_t)SortKey.m_Details.m_Ptr;
		//SortKey.m_Details.m_Ptr = (uint32_t)argptr;
		m_SortKeys[index] = SortKey;

		return argptr;
	}

//	template<typename CMD>
//	typename CMD::Argument* PushCommand() { return PushCommand<CMD>(RendererConf::CommandKey{ 0 }); }

	void SetQueuePreamble() {
		m_CommandsPreamble = m_AllocatedCommands;
		m_MemoryPreamble = m_AllocatedMemory;
	}

	struct RollbackPoint {
		uint32_t m_CommandCount;
		uint32_t m_MemoryUsed;
	};

	//unsafe; Rolling-back has to be used carefully
	RollbackPoint GetSavePoint() const { return RollbackPoint{ m_AllocatedCommands, m_AllocatedMemory }; }
	//unsafe; Rolling-back has to be used carefully
	void Rollback(RollbackPoint point) { m_AllocatedCommands = point.m_CommandCount; m_AllocatedMemory = point.m_MemoryUsed; }
private: 
	template<typename T> using Array = std::array<T, Conf::CommandLimit>;

	template<typename T>
	T* AllocateMemory(uint32_t size) {
		if (m_AllocatedMemory + size >= MemoryCapacity())
			return nullptr;

		T *ptr = reinterpret_cast<T*>(&m_Memory[0] + m_AllocatedMemory);
		m_AllocatedMemory += size;
		return ptr;
	}
	
	uint32_t m_AllocatedCommands;
	uint32_t m_AllocatedMemory;
	uint32_t m_CommandsPreamble;
	uint32_t m_MemoryPreamble;

	Array<CommandFunction> m_CommandFunctions;
	Array<void*> m_CommandArguments;
	std::array<uint8_t, Conf::ArgumentMemoryBuffer> m_Memory;
	Array<CommandKey> m_SortKeys;

	void SortBegin(int first, int last);
};

static_assert((sizeof(CommandQueue) & 0xF) == 0, "Invalid size!");

} //namespace MoonGlare::Renderer
