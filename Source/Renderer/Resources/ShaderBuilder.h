/*
* Generated by cppsrc.sh
* On 2017-02-13 22:45:35,93
* by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#pragma once

#include "../nfRenderer.h"
#include "../Configuration.Renderer.h"

#include "../Commands/CommandQueue.h"
#include "../Commands/OpenGL/ShaderCommands.h"

namespace MoonGlare::Renderer::Resources {

template<typename Descriptor>
struct
	//alignas(16) 
	ShaderBuilder {
//	static_assert(std::is_trivial<ShaderBuilder>::value, "must be trivial!");
//	static_assert((sizeof(ShaderBuilder) % 16) == 0, "Invalid size!");
	using Conf = Configuration::Shader;

	void SelfTest() {
		RendererAssert(this);
		RendererAssert(m_Queue);
		RendererAssert(m_UniformsPtr);
		RendererAssert(m_HandlePtr);
	}

	void Bind() {
		SelfTest();
		m_Queue->MakeCommand<Commands::ShaderResourceBind>(m_HandlePtr);
	}
	void UnBind() {
		SelfTest();
		m_Queue->MakeCommand<Commands::ShaderBind>(InvalidShaderHandle);
	}

	using Uniform = typename Descriptor::Uniform;
	template<Uniform u, typename T>
	void Set(const T &t) {
			auto arg = m_Queue->PushCommand<Commands::ShaderResourcSetUniform<T>>();
			arg->m_Handle = &(*m_UniformsPtr)[static_cast<uint32_t>(u)];
			arg->m_Value = t;
		}

	Commands::CommandQueue *m_Queue;
	Conf::UniformLocations *m_UniformsPtr;
	ShaderHandle* m_HandlePtr;
	void* _padding;
};

} //namespace MoonGlare::Renderer::Resources 
