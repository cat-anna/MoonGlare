/*
* Generated by cppsrc.sh
* On 2017-02-13 22:45:35,93
* by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#pragma once

#include "../nfRenderer.h"
#include "../Configuration.Renderer.h"

#include "../Commands/CommandQueue.h"
#include "../Commands/OpenGL/ShaderCommands.h"

namespace MoonGlare::Renderer::Resources {

template<typename Descriptor>
struct
	//alignas(16) 
	ShaderBuilder {
//	static_assert(std::is_trivial<ShaderBuilder>::value, "must be trivial!");
//	static_assert((sizeof(ShaderBuilder) % 16) == 0, "Invalid size!");
	using Conf = Configuration::Shader;

	void SelfTest() {
		RendererAssert(this);
		RendererAssert(m_UniformsPtr);
		RendererAssert(m_HandlePtr);
	}

	void Bind() {
		SelfTest();
		m_Queue->MakeCommand<Commands::ShaderResourceBind>(m_HandlePtr);
	}
	void UnBind() {
		SelfTest();
		m_Queue->MakeCommand<Commands::ShaderBind>(InvalidShaderHandle);
	}

	using Uniform = typename Descriptor::Uniform;
	template<Uniform u, typename T>
	void Set(const T &t, Commands::CommandKey key = Commands::CommandKey()) {
			auto arg = m_Queue->PushCommand<Commands::ShaderResourcSetUniform<T>>(key);
			arg->m_Handle = &(*m_UniformsPtr)[static_cast<uint32_t>(u)];
			arg->m_Value = t;
		}

	Commands::CommandQueue *m_Queue;
	Conf::UniformLocations *m_UniformsPtr;
	ShaderHandle* m_HandlePtr;
	void* _padding;
};

template<typename Descriptor>
struct
	//alignas(16) 
	ShaderExecutor {
	//	static_assert(std::is_trivial<ShaderBuilder>::value, "must be trivial!");
	//	static_assert((sizeof(ShaderBuilder) % 16) == 0, "Invalid size!");
	using Conf = Configuration::Shader;

	void SelfTest() {
		RendererAssert(this);
		RendererAssert(m_UniformsPtr);
		RendererAssert(m_HandlePtr);
	}

	void Bind() {
		SelfTest();
		Run<Commands::ShaderResourceBind>(m_HandlePtr);
	}
	void UnBind() {
		SelfTest();
		Run<Commands::ShaderBind>(InvalidShaderHandle);
	}

	using Uniform = typename Descriptor::Uniform;
	template<Uniform u, typename T>
	void Set(const T &t, Commands::CommandKey key = Commands::CommandKey()) {
		(void)key;
		Run<Commands::ShaderResourcSetUniform<T>>(&(*m_UniformsPtr)[static_cast<uint32_t>(u)], t);
	}

	Conf::UniformLocations *m_UniformsPtr;
	ShaderHandle* m_HandlePtr;
	void* _padding0;
	void* _padding1;
private:
	template<typename T, typename ... ARG>
	void Run(ARG && ...arg) {
		T::Argument a{ std::forward<ARG>(arg)... };
		a.Execute(&a);
	}
};

} //namespace MoonGlare::Renderer::Resources 
