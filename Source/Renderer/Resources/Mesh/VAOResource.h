/*
  * Generated by cppsrc.sh
  * On 2017-02-13 22:45:35,93
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#pragma once

#include "../../nfRenderer.h"
#include "../../Configuration.Renderer.h"


#ifdef NEED_VAO_BUILDER
#include "VAOBuilder.h"
#endif

namespace MoonGlare::Renderer::Resources {

class alignas(16) VAOResource {
	using ConfRes = Configuration::Resources;
	using Conf = Configuration::VAO;
public:         
    VAOResource(ResourceManager* Owner);
    ~VAOResource();

	bool Allocate(Commands::CommandQueue &queue, VAOResourceHandle &out);
	void Release(Commands::CommandQueue &queue, VAOResourceHandle &h);

	bool Allocate(Frame *frame, VAOResourceHandle &out);
	void Release(Frame *frame, VAOResourceHandle &h);

	Device::VAOHandle* GetHandleArrayBase() { return &m_GLHandle[0]; }

    bool IsHandleValid(VAOResourceHandle &h) const;

#ifdef NEED_VAO_BUILDER
    Builder::VAOBuilder GetVAOBuilder(Commands::CommandQueue &q, VAOResourceHandle &h, bool AllowAllocation = false) {
		if (AllowAllocation && !IsHandleValid(h)) {
			Allocate(q, h);
		}

		return Builder::VAOBuilder {
			&q,
			&m_GLVAOBuffsers[h.index][0],
			&m_GLHandle[h.index],
		};
	}
#endif
private:
	template<typename T>
	using Array = std::array<T, Conf::VAOLimit>;
	using Bitmap = ConfRes::BitmapAllocator<Conf::VAOLimit>;
	using VAOBuffers = Conf::VAOBuffers;

	Bitmap m_AllocationBitmap;
	Array<Device::VAOHandle> m_GLHandle;
	Array<VAOBuffers> m_GLVAOBuffsers;
    Array<TextureResourceHandle::Generation_t> generations;
	ResourceManager *m_ResourceManager = nullptr;
    void* padding[2];
};

static_assert((sizeof(VAOResource) % 16) == 0, "Invalid size!");

} //namespace MoonGlare::Renderer::Resources 
