/*
  * Generated by cppsrc.sh
  * On 2017-03-19  8:31:39,21
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "../nfRenderer.h"
#include "ResourceManager.h"
#include "AsyncLoader.h"
#include "../Renderer.h"
#include "../RenderDevice.h"

#include "../Commands/OpenGL/TextureCommands.h"
#include "../Commands/OpenGL/TextureInitCommands.h"

using namespace std::chrono_literals;

namespace MoonGlare::Renderer::Resources {

AsyncLoader::AsyncLoader(ResourceManager *Owner, Asset::AssetLoader *Loader, const Configuration::RuntimeConfiguration *Configuration) {
    RendererAssert(Owner);
    RendererAssert(Loader);
    RendererAssert(Configuration);
    m_ResourceManager = Owner;
    m_AssetLoader = Loader;
    m_Configuration = Configuration;

    m_PendingQueue = &m_QueueTable[0];
    m_SubmitedQueue = &m_QueueTable[1];
    m_SubmitedQueue->m_ccq.m_Commited = true;

    m_CanWork = true;
    m_Thread = std::thread([this]() { 
        ::OrbitLogger::ThreadInfo::SetName("RALD");
        ThreadMain();
    });
}

AsyncLoader::~AsyncLoader() {
    m_CanWork = false;
    if (m_Thread.joinable())
        m_Thread.join();
}

//---------------------------------------------------------------------------------------

unsigned AsyncLoader::JobsPending() const {
    LOCK_MUTEX(m_QueueMutex);
    return m_Queue.size();
}

bool AsyncLoader::AnyJobPending() {
    return JobsPending()> 0;
}

bool AsyncLoader::AllResoucecsLoaded() {
    return JobsPending() == 0 && !m_QueueDirty;
} 

//---------------------------------------------------------------------------------------

void AsyncLoader::ThreadMain() {
    auto Facade = m_ResourceManager->GetRendererFacade();
    auto Device = Facade->GetDevice();

    unsigned JobCounter = 0;

    while (m_CanWork) {
        if (m_PendingQueue->m_Finished) {
            if (m_SubmitedQueue->m_ccq.m_Commited.load() == false) {
                std::this_thread::sleep_for(1ms);
                continue;
            }
            AddLogf(Performance, "Flushing queue to device. Submitted jobs: %u", JobCounter);
            JobCounter = 0;
            Device->CommitControlCommandQueue(&m_PendingQueue->m_ccq);
            std::swap(m_PendingQueue, m_SubmitedQueue);
            m_PendingQueue->Clear();
            m_QueueDirty = false;
            continue;
        }
        else {
            ProcessorResult result = ProcessorResult::NothingDone;

            AnyTask at;
            bool have = false;
            {
                LOCK_MUTEX(m_QueueMutex);
                if (!m_Queue.empty()) {
                    at.swap(m_Queue.front());
                    m_Queue.pop_front();
                    have = true;
                }
            }

            if (have) {
                result = std::visit([this](auto& item) {
                    return ProcessTask(m_PendingQueue, item);
                }, at);

                ++JobCounter;
                IncrementPerformanceCounter(JobsDone);
            }

            switch (result) {
            case ProcessorResult::Success:
                m_QueueDirty = true;
                break;
            case ProcessorResult::Retry:
                DebugLogf(Info, "Retrying job");
                QueuePush(std::move(at));
                break;
            case ProcessorResult::CriticalError:
                //not handled here
                DebugLogf(Error, "Error during processing task!");
                break;
            case ProcessorResult::NothingDone:
                if (!m_QueueDirty) {
                    std::mutex mutex;
                    std::unique_lock<std::mutex> lock(mutex);
                    m_Lock.wait_for(lock, 100ms);
                    break;
                }
                //[[fallthrough]]
            case ProcessorResult::QueueFull:
                if (have) {
                    QueuePush(std::move(at));
                }
                if (m_QueueDirty) {
                    m_PendingQueue->m_Finished = true;
                }
                else {
                    AddLogf(Error, "Queue full and not dirty!");
                }
                break;
            default:
                LogInvalidEnum(result);
                break;
            }

        }
    }
}

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

void AsyncLoader::SubmitTextureLoad(std::string URI, TextureResourceHandle handle,
        Device::TextureHandle *glHandlePtr,
        emath::usvec2 *OutSize,
        Configuration::TextureLoad settings) {

    if (OutSize) {
        char mem[sizeof(Asset::TextureLoader::TexturePixelData)] = { 0 };
        auto &data = *((Asset::TextureLoader::TexturePixelData *)mem);

        auto Loader = m_AssetLoader->GetTextureLoader();
        if (Loader->LoadTexture(URI, data)) {
            *OutSize = data.m_PixelSize;
        }
        data.m_ImageMemory.reset();
    }

    QueuePush(TextureLoadTask{ std::move(URI), handle, glHandlePtr, settings });
    m_Lock.notify_one();
}

AsyncLoader::ProcessorResult AsyncLoader::ProcessTask(QueueData *queue, TextureLoadTask &tlt) {
    auto Loader = m_AssetLoader->GetTextureLoader();

    RendererAssert(Loader);
    auto &q = queue->m_Queue;

    if (*tlt.m_DeviceHandle == Device::InvalidTextureHandle)
        q.MakeCommand<Commands::TextureSingleAllocate>(tlt.m_DeviceHandle);

    auto texres = q.PushCommand<Commands::Texture2DResourceBind>();
    texres->m_HandlePtr = tlt.m_DeviceHandle;

    auto pixels = q.PushCommand<Commands::Texture2DSetPixelData>();
    memset(pixels, 0, sizeof(*pixels));
    if (!Loader->LoadTexture(tlt.m_URI, pixels->data)) {
        AddLogf(Error, "Texture load failed: %s", tlt.m_URI.c_str());
        return ProcessorResult::CriticalError;
    }

    using TexConf = Configuration::Texture;

    //if (config.m_Edges == Conf::Edges::Default) {
    //	config.m_Edges = Conf::Edges::Repeat;
    //}

    if (tlt.m_Settings.m_Filtering == TexConf::Filtering::Default) {
        tlt.m_Settings.m_Filtering = m_Configuration->m_Texture.m_Filtering;
    }

    q.MakeCommand<Commands::Texture2DSetup>(tlt.m_Settings);

    return ProcessorResult::Success;
}

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

void AsyncLoader::SubmitShaderLoad(ShaderResourceHandleBase handle) {
    QueuePush(ShaderLoadTask{ handle });
    m_Lock.notify_one();
}

AsyncLoader::ProcessorResult AsyncLoader::ProcessTask(QueueData *queue, ShaderLoadTask &slt) {
    auto &shres = m_ResourceManager->GetShaderResource();
    bool success = shres.GenerateReload(queue->m_Queue, queue->m_Memory.m_Allocator, slt.m_Handle);

    if (success) {
        return ProcessorResult::Success;
    }
    else {
        return ProcessorResult::CriticalError;
    }
}

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

} //namespace MoonGlare::Renderer::Resources 
 