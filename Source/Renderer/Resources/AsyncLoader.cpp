/*
  * Generated by cppsrc.sh
  * On 2017-03-19  8:31:39,21
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "../nfRenderer.h"
#include "ResourceManager.h"
#include "AsyncLoader.h"
#include "../Renderer.h"
#include "../RenderDevice.h"

#include "../Commands/OpenGL/TextureCommands.h"
#include "../Commands/OpenGL/TextureInitCommands.h"

using namespace std::chrono_literals;

namespace MoonGlare::Renderer::Resources {

AsyncLoader::AsyncLoader(ResourceManager *Owner, AssetLoader *Loader, const Configuration::RuntimeConfiguration *Configuration) {
    RendererAssert(Owner);
    RendererAssert(Loader);
    RendererAssert(Configuration);
    m_ResourceManager = Owner;
    m_AssetLoader = Loader;
    m_Configuration = Configuration;

    m_PendingQueue = &m_QueueTable[0];
    m_SubmitedQueue = &m_QueueTable[1];
    m_SubmitedQueue->m_ccq.m_Commited = true;

    m_QueueProcesors[0] = &AsyncLoader::ProcessShaderQueue;
    m_QueueProcesors[1] = &AsyncLoader::ProcessTextureQueue;

    m_CanWork = true;
    m_Thread = std::thread([this]() { 
        ::OrbitLogger::ThreadInfo::SetName("RALD");
        ThreadMain();
    });
}

AsyncLoader::~AsyncLoader() {
    m_CanWork = false;
    if (m_Thread.joinable())
        m_Thread.join();
}

//---------------------------------------------------------------------------------------

unsigned AsyncLoader::JobsPending() const {
    return
        m_TextureQueue.read_available() +
        m_ShaderQueue.read_available();
}

bool AsyncLoader::AnyJobPending() {
    return
        !m_TextureQueue.empty() ||
        !m_ShaderQueue.empty();
}

bool AsyncLoader::AllResoucecsLoaded() {
    return !AnyJobPending() && !m_QueueDirty;
} 

//---------------------------------------------------------------------------------------

void AsyncLoader::ThreadMain() {
    auto Facade = m_ResourceManager->GetRendererFacade();
    auto Device = Facade->GetDevice();

    unsigned JobCounter = 0;

    while (m_CanWork) {
        if (m_PendingQueue->m_Finished) {
            if (m_SubmitedQueue->m_ccq.m_Commited.load() == false) {
                std::this_thread::sleep_for(1ms);
                continue;
            }
            AddLogf(Performance, "Flushing queue to device. Submitted jobs: %u", JobCounter);
            JobCounter = 0;
            Device->CommitControlCommandQueue(&m_PendingQueue->m_ccq);
            std::swap(m_PendingQueue, m_SubmitedQueue);
            m_PendingQueue->Clear();
            m_QueueDirty = false;
            continue;
        }
        else {
            ProcessorResult result = ProcessorResult::Success;

            for (auto proc : m_QueueProcesors) {
                assert(proc);
                result = (this->*proc)(m_PendingQueue);
                if (result != ProcessorResult::NothingToBeDone) {
                    ++JobCounter;
                    IncrementPerformanceCounter(JobsDone);
                    break;
                }
            }

            switch (result) {
            case ProcessorResult::Success:
                m_QueueDirty = true;
            default:
                break;

            case ProcessorResult::CriticalError:
                //not handled here
                DebugLogf(Error, "Error during processing task!");
                break;

            case ProcessorResult::NothingToBeDone:
                if (!m_QueueDirty) {
                    std::mutex mutex;
                    std::unique_lock<std::mutex> lock(mutex);
                    m_Lock.wait_for(lock, 100ms);
                    break;
                }
//                [[fallthrough]]
            case ProcessorResult::QueueFull:
                if (m_QueueDirty) {
                    m_PendingQueue->m_Finished = true;
                }
                else {
                    AddLogf(Error, "Queue full and not dirty!");
                }
                break;
            }
        }
    }
}

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

void AsyncLoader::SubmitTextureLoad(std::string URI, TextureResourceHandle handle,
        Device::TextureHandle *glHandlePtr,
        emath::usvec2 *OutSize,
        Configuration::TextureLoad settings) {

    if (OutSize) {
        char mem[sizeof(Resources::TextureLoader::TexturePixelData)] = { 0 };
        auto &data = *((Resources::TextureLoader::TexturePixelData *)mem);

        auto Loader = m_AssetLoader->GetTextureLoader();
        if (Loader->LoadTexture(URI, data)) {
            *OutSize = data.m_PixelSize;
        }
        data.m_ImageMemory.reset();
    }

    m_TextureQueue.push(TextureLoadTask{ std::move(URI), handle, glHandlePtr, settings });
    m_Lock.notify_one();
}

AsyncLoader::ProcessorResult AsyncLoader::ProcessTextureQueue(QueueData *queue) {
    ProcessorResult result = ProcessorResult::Success;

    bool consumed = m_TextureQueue.consume_one([&](const TextureLoadTask &tlt) {
        auto loadret = LoadTexture(&const_cast<TextureLoadTask&>(tlt), m_PendingQueue);
        switch (loadret) {
        case TaskResult::Success:
            return;
        case TaskResult::CriticalError:
            result = ProcessorResult::CriticalError;
            return;

        case TaskResult::QueueFull:
            DebugLogf(Info, "Queue full during texture Load");
            result = ProcessorResult::QueueFull;
            m_TextureQueue.push(tlt);
            return;
        case TaskResult::Retry:
            DebugLogf(Info, "Retry during texture Load");
            m_TextureQueue.push(tlt);
            return;
        default:
            break;
        }
    });

    if (!consumed)
        result = ProcessorResult::NothingToBeDone;
    return result;
}

AsyncLoader::TaskResult AsyncLoader::LoadTexture(TextureLoadTask *tlt, QueueData* queue) const {
    auto Loader = m_AssetLoader->GetTextureLoader();

    RendererAssert(Loader);
    RendererAssert(queue);

    auto &q = queue->m_Queue;

    if (*tlt->m_DeviceHandle == Device::InvalidTextureHandle)
        q.MakeCommand<Commands::TextureSingleAllocate>(tlt->m_DeviceHandle);

    auto texres = q.PushCommand<Commands::Texture2DResourceBind>();
    texres->m_HandlePtr = tlt->m_DeviceHandle;

    auto pixels = q.PushCommand<Commands::Texture2DSetPixelData>();
    memset(pixels, 0, sizeof(*pixels));
    if (!Loader->LoadTexture(tlt->m_URI, pixels->data)) {
        AddLogf(Error, "Texture load failed: %s", tlt->m_URI.c_str());
        return TaskResult::CriticalError;
    }

    using TexConf = Configuration::Texture;

    //if (config.m_Edges == Conf::Edges::Default) {
    //	config.m_Edges = Conf::Edges::Repeat;
    //}

    if (tlt->m_Settings.m_Filtering == TexConf::Filtering::Default) {
        tlt->m_Settings.m_Filtering = m_Configuration->m_Texture.m_Filtering;
    }

    q.MakeCommand<Commands::Texture2DSetup>(tlt->m_Settings);

    return TaskResult::Success;
}

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

void AsyncLoader::SubmitShaderLoad(ShaderResourceHandleBase handle) {
    m_ShaderQueue.push(ShaderLoadTask{ handle });
    m_Lock.notify_one();
}

AsyncLoader::ProcessorResult AsyncLoader::ProcessShaderQueue(QueueData *queue) {
    bool success = true;
    bool consumed = m_ShaderQueue.consume_one([&](const ShaderLoadTask &slt) {
        auto &shres = m_ResourceManager->GetShaderResource();
        success = shres.GenerateReload(queue->m_Queue, queue->m_Memory.m_Allocator, slt.m_Handle);
    });

    if (success) {
        if (!consumed)
           return ProcessorResult::NothingToBeDone;
    }
    else {
        return ProcessorResult::CriticalError;
    }

    return ProcessorResult::Success;
}

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

} //namespace MoonGlare::Renderer::Resources 
 