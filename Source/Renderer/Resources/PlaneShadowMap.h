/*
Generated by cppsrc.sh
On 2015-01-18  9:02:18,36
by Paweu
*/

#pragma once

#include "../Commands/OpenGL/TextureCommands.h"

namespace MoonGlare::Renderer {

struct alignas(16) PlaneShadowMap {
    using Conf = Configuration::Shadow;

    Device::TextureHandle textureHandle;
    Device::FramebufferHandle framebufferHandle;

    Conf::ShadowMapSize size;
    bool valid;
    uint8_t _padding1;
    uint32_t _padding2;

    void Init(Commands::CommandQueue &q) {
         auto *cmd = q.PushCommand<Commands::InitPlaneShadowMap>();
         cmd->size = size;
         cmd->bufferHandle = &framebufferHandle;
         cmd->textureHandle = &textureHandle;
         valid = true;
    }
};
//static_assert((sizeof(PlaneShadowMap) % 16) == 0, "Invalid size!");

}

#if 0
class PlaneShadowMap : public FrameBuffer {
public:
    PlaneShadowMap() {
        m_ShadowTexture = 0;
    }
    ~PlaneShadowMap() {
        Free();
    }

    bool New();
    bool Free() {
        FreeFrameBuffer();
        if (m_ShadowTexture != 0)
            GetRenderDevice()->RequestContextManip([this] {
            glDeleteTextures(1, &m_ShadowTexture);
            m_ShadowTexture = 0;
        });
        return true;
    }

    bool Valid() const {
        return m_ShadowTexture != 0;
    }
    operator bool() const {
        return Valid();
    }

    void BindAndClear() {
        glViewport(0, 0, static_cast<int>(m_Size[0]), static_cast<int>(m_Size[1]));
        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_FrameBuffer);
        glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
    }

    void BindAsTexture(GLenum TextureIndex) const {
        glActiveTexture(GL_TEXTURE0 + TextureIndex);
        glBindTexture(GL_TEXTURE_2D, m_ShadowTexture);
    }

    const math::vec2& GetSize() const {
        return m_Size;
    }
    GLuint Handle() {
        return m_ShadowTexture;
    }
    GLuint FBHandle() {
        return m_FrameBuffer;
    }
protected:
    GLuint m_ShadowTexture;
    math::vec2 m_Size;
};

#endif
