/*
  * Generated by cppsrc.sh
  * On 2017-02-28 19:46:14,71
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "MaterialManager.h"

namespace MoonGlare::Renderer::Resources {

MaterialManager::MaterialManager(ResourceManager * Owner): m_ResourceManager(Owner) {
    RendererAssert(Owner);
    m_AllocationBitmap.ClearAllocation();
    generations.fill(1);
    materials.fill({});
}

MaterialManager::~MaterialManager() {
}

//---------------------------------------------------------------------------------------

Material *MaterialManager::GetMaterial(MaterialResourceHandle h) {
    if (!IsHandleValid(h))
        return nullptr;
    return &materials[h.index];
}

bool MaterialManager::IsHandleValid(MaterialResourceHandle &h) const {
    if (h.index >= Conf::Limit)
        return false;
    if (generations[h.index] != h.generation) {
        return false;
    }
    return true;
}

//---------------------------------------------------------------------------------------

bool MaterialManager::Allocate(MaterialResourceHandle &hout, const std::string &uri) {
    auto cache = loadedMaterials.find(uri);
    if (cache != loadedMaterials.end() && IsHandleValid(cache->second)) {
        AddLogf(Performance, "material load cache hit");
        hout = cache->second;
        return true;
    }

    if (Allocate(hout)) {
        loadedMaterials[uri] = hout;
        return true;
    }

    return false;
}

bool MaterialManager::Allocate(MaterialResourceHandle &hout) {
    Bitmap::Index_t index;
    if (m_AllocationBitmap.Allocate(index)) {

        hout.index = static_cast<MaterialResourceHandle::Index_t>(index);
        hout.generation = generations[hout.index];
        hout.deviceHandle = &materials[hout.index];

        return true;
    }
    else {
        AddLogf(Debug, "material allocation failed");
        return false;
    }
}

} //namespace MoonGlare::Renderer::Resources 
