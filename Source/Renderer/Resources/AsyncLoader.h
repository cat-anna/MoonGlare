/*
  * Generated by cppsrc.sh
  * On 2017-03-19  8:31:39,21
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#pragma once

#include "../Configuration.Renderer.h"

namespace MoonGlare::Renderer::Resources {

class AsyncLoader {
    using ThisClass = AsyncLoader;
    using Conf = Configuration::Resources;
public:
 	AsyncLoader(ResourceManager *Owner, Asset::AssetLoader *Loader, const Configuration::RuntimeConfiguration *Configuration);
 	~AsyncLoader();

    unsigned JobsPending() const;
    bool AnyJobPending();
    bool AllResoucecsLoaded();

    void SubmitTextureLoad(std::string URI, TextureResourceHandle handle,
        Device::TextureHandle *glHandlePtr,
        emath::usvec2 *OutSize,
        Configuration::TextureLoad settings);
    void SubmitShaderLoad(ShaderResourceHandleBase handle);
private: 
    bool m_CanWork = false;
    std::condition_variable m_Lock;
    std::thread m_Thread;
    Asset::AssetLoader *m_AssetLoader;
    const Configuration::RuntimeConfiguration *m_Configuration;

    struct QueueData {
        Commands::CommitCommandQueue m_ccq;
        bool m_Finished;
        uint8_t _padding[3];
        void *padding2[1];
        Commands::CommandQueue m_Queue;
        StackAllocatorMemory<Conf::QueueMemory> m_Memory;

        QueueData() {
            m_ccq.m_Queue = &m_Queue;
            m_Queue.MemZero();
            Clear();
        }

        void Clear() {
            m_Finished = false;
            m_ccq.m_Commited = false;
            m_Queue.ClearAllocation();
            m_Memory.m_Allocator.Clear();
        }
    };
    static_assert(Conf::AsyncQueueCount == 2, "error!");//not implemented

    bool m_QueueDirty = false;
    QueueData *m_PendingQueue;
    QueueData *m_SubmitedQueue;
    ResourceManager *m_ResourceManager;
    std::array<QueueData, Conf::AsyncQueueCount> m_QueueTable;

    enum class ProcessorResult {
        Success,
        NothingToBeDone,
        CriticalError,
        QueueFull,
    };

    enum class TaskResult {
        Success,
        CriticalError,
        QueueFull,
        Retry,
    };

//--
    struct TextureLoadTask {
        std::string m_URI;
        TextureResourceHandle m_Handle;
        Device::TextureHandle *m_DeviceHandle;
        Configuration::TextureLoad m_Settings;
    };
    boost::lockfree::spsc_queue<TextureLoadTask, boost::lockfree::capacity<1024>> m_TextureQueue;
    TaskResult LoadTexture(TextureLoadTask *tlt, QueueData *queue) const;
    ProcessorResult ProcessTextureQueue(QueueData *queue);
//--
    struct ShaderLoadTask {
        ShaderResourceHandleBase m_Handle;
    };
    boost::lockfree::spsc_queue<ShaderLoadTask, boost::lockfree::capacity<16>> m_ShaderQueue;
    ProcessorResult ProcessShaderQueue(QueueData *queue);
//--

    std::array<decltype(&ProcessTextureQueue), 2> m_QueueProcesors;

    DeclarePerformanceCounter(JobsDone);

    void ThreadMain();
};

} //namespace MoonGlare::Renderer::Resources 
