/*
  * Generated by cppsrc.sh
  * On 2017-02-22 19:09:53,00
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "ShaderResource.h"

#include "../Frame.h"
#include "../Commands/CommandQueue.h"
#include "../Commands/OpenGL/ArrayCommands.h"

namespace MoonGlare::Renderer::Resources {

uint32_t ShaderHandlerInterface::s_InterfaceIndexAlloc = 0;

bool ShaderResource::Initialize(ResourceManager *Owner, ShaderCodeLoader *CodeLoader) {
	RendererAssert(Owner);
	RendererAssert(CodeLoader);

	m_ResourceManager = Owner;
	m_ShaderCodeLoader = CodeLoader;

	m_ShaderHandle.fill(InvalidShaderHandle);
	m_ShaderInterface.fill(nullptr);
	Conf::UniformLocations locs;
	locs.fill(InvalidShaderUniformHandle);
	m_ShaderUniform.fill(locs);
	m_ShaderName.fill(std::string());

	m_ShaderConfigurationDefs = 
R"(
//no custom defs yet
)";

	return true;
}

bool ShaderResource::Finalize() {
	return true;
}

//---------------------------------------------------------------------------------------

struct ConstructShaderArgument {
	using ShaderCode = ShaderCodeLoader::ShaderCode;
	using ShaderType = ShaderCodeLoader::ShaderType;

	static constexpr size_t MaxShaderLines = 8;
	static constexpr size_t MaxShaderTypes = static_cast<size_t>(ShaderType::MaxValue);
	using ShaderCodeBuffer = std::array<const char *, MaxShaderLines>;

	template<typename T>
	using Array = std::array<T, MaxShaderTypes>;

	Array<bool> m_Valid;
	Array<ShaderCodeBuffer> m_CodeArray;
	const char* m_ShaderName;
	ShaderHandle *m_ShaderOutput;

	struct ShaderTypeInfo {
		ShaderType m_Type;
		GLuint m_GLID;
		const char *m_Name;
	};
	static constexpr std::array<ShaderTypeInfo, MaxShaderTypes> ShaderTypes = {
		ShaderTypeInfo{ ShaderType::Vertex, GL_VERTEX_SHADER, "vertex", },
		ShaderTypeInfo{ ShaderType::Fragment, GL_FRAGMENT_SHADER, "fragment", },
		ShaderTypeInfo{ ShaderType::Geometry, GL_GEOMETRY_SHADER, "geometry", },
	};

	void Run() const {
		std::array<GLuint, MaxShaderTypes> LoadedShaders;
		LoadedShaders.fill(InvalidShaderStageHandle);

		unsigned LoadedCount = 0;
		auto DeleteShaders = [&LoadedCount, &LoadedShaders] {
			if (LoadedCount > 0) {
				for (auto i : LoadedShaders)
					glDeleteShader(i);
			}
		};

		bool Success = true;

		for (auto &shadertype : ShaderTypes) {
			auto index = static_cast<unsigned>(shadertype.m_Type);

			if (!m_Valid[index])
				continue;

			GLuint shader = glCreateShader(shadertype.m_GLID);
			LoadedShaders[index] = shader;

			glShaderSource(shader, m_CodeArray[index].size(), (const GLchar**)&m_CodeArray[index][0], NULL);	//TODO: check what is last argument
			glCompileShader(shader);

			GLint Result = GL_FALSE;
			int InfoLogLength = 0;
			glGetShaderiv(shader, GL_COMPILE_STATUS, &Result);
			glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &InfoLogLength);

			if (InfoLogLength <= 0) {
				++LoadedCount;
				continue; //compiled ok
			}

			Success = false;

			std::string ShaderErrorMessage(InfoLogLength + 1, '\0');
			glGetShaderInfoLog(shader, InfoLogLength, NULL, &ShaderErrorMessage[0]);
			AddLogf(Error, "Unable to compile %s shader for %s. Error message:\n%s", 
				shadertype.m_Name, m_ShaderName, ShaderErrorMessage.c_str());

			break;
		}

		if (!Success) {
			AddLogf(Error, "Shader compilation failed!");
			DeleteShaders();
			return;
		}

		//attach all shaders
		GLuint ProgramID = glCreateProgram();

		for (auto i : LoadedShaders)
			if (i != InvalidShaderStageHandle)
				glAttachShader(ProgramID, i);

		//link program
		glLinkProgram(ProgramID);

		//check program for errors
		GLint Result = GL_FALSE;
		int InfoLogLength = 0;

		glGetProgramiv(ProgramID, GL_LINK_STATUS, &Result);
		glGetProgramiv(ProgramID, GL_INFO_LOG_LENGTH, &InfoLogLength);

		if (InfoLogLength > 1) {
			std::string ProgramErrorMessage(InfoLogLength + 1, '\0');
			glGetProgramInfoLog(ProgramID, InfoLogLength, NULL, &ProgramErrorMessage[0]);
			AddLogf(Error, "Unable to link %s program. Error message:\n%s", m_ShaderName, &ProgramErrorMessage[0]);
			AddLogf(Error, "Shader linking failed!");
			glDeleteProgram(ProgramID);
			DeleteShaders();
			return;
		}

		DeleteShaders();
		*m_ShaderOutput = ProgramID;
	}

	static void Execute(const ConstructShaderArgument *arg) {
		return arg->Run();
	}
};
using ConstructShader = Commands::CommandTemplate<ConstructShaderArgument>;

//---------------------------------------------------------------------------------------

bool ShaderResource::Reload(Commands::CommandQueue &queue, const std::string &Name) {
	RendererAssert(this);

	for (size_t index = 0u; index < m_ShaderName.size(); ++index) {
		if (m_ShaderName[index] == Name) {
			return Reload(queue, index);
		}
	}

	DebugLogf(Error, "There is no loaded shader: %s", Name.c_str());
	return false;
}

bool ShaderResource::Reload(Commands::CommandQueue &queue, uint32_t ifindex) {
	RendererAssert(this);
	return GenerateLoadCommand(queue, ifindex) && GenerateUnformDiscoverCommand(queue, ifindex);
}

//---------------------------------------------------------------------------------------

bool ShaderResource::LoadShader(Commands::CommandQueue &queue, ShaderResourceHandle &out, const std::string & ShaderName, ShaderHandlerInterface * ShaderIface) {
	RendererAssert(this);
	RendererAssert(ShaderIface);

	auto ifindex = ShaderIface->InterfaceID();

	bool isalloc = false;
	if (!m_ShaderLoaded[ifindex].compare_exchange_strong(isalloc, true)) {
		out.m_TmpGuard = out.GuardValue;
		out.m_Index = static_cast<uint16_t>(ifindex);
		return true;
	}

	m_ShaderName[ifindex] = ShaderName;
	m_ShaderHandle[ifindex] = InvalidShaderHandle;
	m_ShaderUniform[ifindex].fill(InvalidShaderUniformHandle);
	m_ShaderInterface[ifindex] = ShaderIface;

	out.m_TmpGuard = out.GuardValue;
	out.m_Index = static_cast<uint16_t>(ifindex);

	return Reload(queue, ifindex);
}

bool ShaderResource::GenerateLoadCommand(Commands::CommandQueue &queue, uint32_t ifindex) {
	RendererAssert(this);

	ShaderCodeLoader::ShaderCode code;
	if (!m_ShaderCodeLoader->LoadCode(m_ShaderName[ifindex], code)) {
		RendererAssert(false);
		return false;
	}

	auto &q = queue;
	auto &m = queue.GetMemory();

	auto *arg = q.PushCommand<ConstructShader>();

	arg->m_Valid.fill(false);
	arg->m_CodeArray;
	arg->m_ShaderName = m_ShaderName[ifindex].c_str();
	arg->m_ShaderOutput = &m_ShaderHandle[ifindex];

	for (const auto &shadertype : arg->ShaderTypes) {
		auto index = static_cast<unsigned>(shadertype.m_Type);

		auto &Lines = arg->m_CodeArray[index];
		Lines.fill("\n");

		if (code.m_Code[index].empty())
			continue;

		char buf[64];

		Lines[0] = "#version 420\n";
		Lines[1] = "//defines begin\n";

		sprintf_s(buf, "#define %s_main main\n", shadertype.m_Name);
		Lines[2] = m.CloneString(buf);

		sprintf_s(buf, "#define shader_%s\n", shadertype.m_Name);
		Lines[3] = m.CloneString(buf);

		Lines[4] = m_ShaderConfigurationDefs.c_str();
		//5
		Lines[6] = "//preprocesed code begin\n";
		Lines[7] = m.CloneString(code.m_Code[index]);

		arg->m_Valid[index] = true;
	}

	return true;
}

bool ShaderResource::GenerateUnformDiscoverCommand(Commands::CommandQueue &queue, uint32_t ifindex) {
	RendererAssert(this);
	RendererAssert(m_ShaderInterface[ifindex]);

	struct GetShaderUnfiormsArgument {
		const char **m_Names;
		unsigned m_Count;
		ShaderHandle *m_ShaderHandle;
		Conf::UniformLocations *m_Locations;
		const char *m_ShaderName;

		void Run() const {
			if (*m_ShaderHandle == InvalidShaderHandle)
				return;

			for (auto i = 0u; i < m_Count; ++i) {
				auto loc = glGetUniformLocation(*m_ShaderHandle, m_Names[i]);
				(*m_Locations)[i] = loc;
#ifdef DEBUG
				if (loc == InvalidShaderUniformHandle) {
					AddLogf(Warning, "Unable to get location of parameter '%s' in shader '%s'", m_Names[i], m_ShaderName);
				}
#endif
			}
		}
		static void Execute(const GetShaderUnfiormsArgument *arg) {
			arg->Run();
		}
	};
	using GetShaderUnfiorms = Commands::CommandTemplate<GetShaderUnfiormsArgument>;


	auto iface = m_ShaderInterface[ifindex];

	auto UniformCount = iface->UniformCount();
	const auto **UniformName = iface->UniformName();

	auto &q = queue;
	auto &m = queue.GetMemory();

	auto *arg = q.PushCommand<GetShaderUnfiorms>();
	arg->m_Count = iface->UniformCount();
	arg->m_Names = iface->UniformName();
	arg->m_ShaderHandle = &m_ShaderHandle[ifindex];
	arg->m_Locations = &m_ShaderUniform[ifindex];
	arg->m_ShaderName = m_ShaderName[ifindex].c_str();
		
	return true;
}

} //namespace MoonGlare::Renderer::Resources 
