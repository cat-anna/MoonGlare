#pragma once

/*
* Generated by cppsrc.sh
* On 2017-02-13 22:45:35,93
* by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#pragma once

#include "../nfRenderer.h"
#include "../Configuration.Renderer.h"

#include "../Commands/CommandQueue.h"
#include "../Commands/OpenGL/ArrayCommands.h"

namespace MoonGlare::Renderer::Resources {

struct VAOBuilder {
	using Conf = Configuration::VAO;

	using VAOBuffers = Conf::VAOBuffers;
	using InputChannels = Conf::InputChannels;
	using ChannelType = Conf::ChannelType;

	void SelfTest() {
		RendererAssert(this);
		RendererAssert(m_Queue);
		RendererAssert(m_BuffersPtr);
		RendererAssert(m_HandlePtr);
	}

	void BindVAO() {
		SelfTest();
		m_Queue->MakeCommand<Commands::VAOBindResource>(m_HandlePtr);
	}
	void UnBindVAO() {
		SelfTest();
		m_Queue->MakeCommand<Commands::VAOBind>(InvalidVAOHandle);
	}

	void BeginDataChange() {
		SelfTest();
		BindVAO();
	}
	void EndDataChange() {
	}

	void CreateChannel(InputChannels iChannel) {
		auto Channel = static_cast<ChannelType>(iChannel);
		SelfTest();
		RendererAssert(Channel < m_BuffersPtr->size());
		if ((*m_BuffersPtr)[Channel] == InvalidBufferHandle)
			m_Queue->MakeCommand<Commands::BufferSingleAllocate>(&(*m_BuffersPtr)[Channel]);
	}

	template <typename T, GLint ElementSize = 1>
	void SetChannelData(InputChannels iChannel, const T* data, size_t ElementCount, bool Dynamic = false, bool Normalized = false) {
		auto Channel = static_cast<ChannelType>(iChannel);
		SelfTest();
		RendererAssert(Channel < m_BuffersPtr->size());
		m_Queue->MakeCommand<Commands::BindArrayBufferResource>()->m_Handle = &(*m_BuffersPtr)[Channel];

		GLsizeiptr bytecount = ElementCount * ElementSize * sizeof(T);
		if (Dynamic)
			m_Queue->MakeCommand<Commands::ArrayBufferDynamicData>(bytecount, (const void*)data);
		else
			m_Queue->MakeCommand<Commands::ArrayBufferStaticData>(bytecount, (const void*)data);

		if (Normalized)
			m_Queue->MakeCommand<Commands::ArrayBufferNormalizedChannel>(Channel, ElementSize, TypeId<T>);
		else
			m_Queue->MakeCommand<Commands::ArrayBufferChannel>(Channel, ElementSize, TypeId<T>);
	}


	template <typename T>
	void SetIndex(InputChannels iChannel, const T* data, size_t ElementCount, bool Dynamic = false) {
		auto Channel = static_cast<ChannelType>(iChannel);
		SelfTest();
		RendererAssert(Channel < m_BuffersPtr->size());
		m_Queue->MakeCommand<Commands::BindArrayIndexBufferResource>()->m_Handle = &(*m_BuffersPtr)[Channel];

		GLsizeiptr bytecount = ElementCount * sizeof(T);
		if (Dynamic)
			m_Queue->MakeCommand<Commands::ArrayIndexBufferDynamicData>(bytecount, (const void*)data);
		else
			m_Queue->MakeCommand<Commands::ArrayIndexBufferStaticData>(bytecount, (const void*)data);
	}


	Commands::CommandQueue *m_Queue;
	VAOBuffers *m_BuffersPtr;
	VAOHandle* m_HandlePtr;
	void* _padding;
};
static_assert(std::is_trivial<VAOBuilder>::value, "must be trivial!");
static_assert((sizeof(VAOBuilder) % 16) == 0, "Invalid size!");

} //namespace MoonGlare::Renderer::Resources 
