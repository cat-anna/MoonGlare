/*
  * Generated by cppsrc.sh
  * On 2017-02-13 22:45:35,93
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "TextureResource.h"
#include "ResourceManager.h"
#include "../Frame.h"
#include "../Renderer.h"
#include "../RenderDevice.h"

#include "../Commands/CommandQueue.h"
#include "../Commands/OpenGL/TextureCommands.h"
#include "../Commands/OpenGL/TextureInitCommands.h"

namespace MoonGlare::Renderer::Resources {

void TextureResource::Initialize(ResourceManager *Owner, TextureLoader *TexLoader) {
	RendererAssert(Owner);
	RendererAssert(TexLoader);
	m_ResourceManager = Owner;
	m_TexureLoader = TexLoader;
	m_Settings = &Owner->GetConfiguration()->m_Texture;

	m_GLHandle.fill(Device::InvalidTextureHandle);
	m_TextureSize.fill(emath::usvec2(0));
	m_AllocationBitmap.ClearAllocation();

	if (Conf::Initial > 0) {
		//TBD!!!
	}
}

void TextureResource::Finalize() {
}

//---------------------------------------------------------------------------------------

bool TextureResource::Allocate(TextureResourceHandle &out) {
	auto dev = m_ResourceManager->GetRendererFacade()->GetDevice();
	auto qhandle = dev->AllocateCtrlQueue();
	if (!qhandle.m_Queue) {
		DebugLogf(Error, "texture allocation - queue allocation failed");
		return false;
	}

	Allocate(*qhandle.m_Queue, out);

	dev->Submit(qhandle);
}

bool TextureResource::Allocate(Frame *frame, TextureResourceHandle &out) {
	RendererAssert(frame);
	return Allocate(frame->GetControllCommandQueue(), out);
}

bool TextureResource::Allocate(Commands::CommandQueue &queue, TextureResourceHandle &out) {
	Bitmap::Index_t index;
	if (m_AllocationBitmap.Allocate(index)) {
		if (m_GLHandle[index] == Device::InvalidTextureHandle) {
			IncrementPerformanceCounter(OpenGLAllocations);
			auto arg = queue.PushCommand<Commands::TextureSingleAllocate>();
			arg->m_Out = &m_GLHandle[index];
		}
		out.m_Index = static_cast<TextureResourceHandle::Index_t>(index);
		out.m_TmpGuard = out.GuardValue;
		IncrementPerformanceCounter(SuccessfulAllocations);
		return true;
	}
	else {
		AddLogf(Debug, "Texture allocation failed");
		IncrementPerformanceCounter(FailedAllocations);
		return false;
	}
}

void TextureResource::Release(Frame *frame, TextureResourceHandle h) {
	RendererAssert(h.m_TmpGuard == h.GuardValue);
	RendererAssert(h.m_Index < Conf::Limit);

	if (m_AllocationBitmap.Release(h.m_Index)) {
		IncrementPerformanceCounter(SuccessfulDellocations);
	}
	else {
		AddLogf(Debug, "Texture deallocation failed");
		IncrementPerformanceCounter(FailedDellocations);
	}
}

//---------------------------------------------------------------------------------------

bool TextureResource::LoadTexture(TextureResourceHandle & out, const std::string &fPath, Configuration::TextureLoad config, bool CanAllocate) {
	if (!out && !CanAllocate) {
		return false;
	}

	auto dev = m_ResourceManager->GetRendererFacade()->GetDevice();
	auto qhandle = dev->AllocateCtrlQueue();
	if (!qhandle.m_Queue) {
		DebugLogf(Error, "texture allocation - queue allocation failed");
		return false;
	}


	auto &q = *qhandle.m_Queue;

	if (!out && CanAllocate) {
		if (!Allocate(q, out)) {
			DebugLogf(Error, "texture allocation - allocate failed");
			dev->Submit(qhandle);
			return false;
		}
	} 

	auto texres = q.PushCommand<Commands::Texture2DResourceBind>();
	texres->m_Handle = out;
	texres->m_HandleArray = GetHandleArrayBase();

	auto pixels = q.PushCommand<Commands::Texture2DSetPixelData>();
	memset(pixels, 0, sizeof(*pixels));

	if (!m_TexureLoader->LoadTexture(fPath, pixels->data)) {
		AddLogf(Error, "Texture load failed: %s", fPath.c_str());
		dev->Submit(qhandle);//may cause crash!!!
		return false;
	}

	m_TextureSize[out.m_Index] = pixels->data.m_PixelSize;
	//if (config.m_Edges == Conf::Edges::Default) {
	//	config.m_Edges = Conf::Edges::Repeat;
	//}

	if (config.m_Filtering == Conf::Filtering::Default) {
		config.m_Filtering = m_Settings->m_Filtering;
	}

	q.MakeCommand<Commands::Texture2DSetup>(config);

	dev->Submit(qhandle);
	return true;
}

emath::usvec2 TextureResource::GetSize(TextureResourceHandle h) const {
	if (!h)
		return {};

	return m_TextureSize[h.m_Index];
}

//---------------------------------------------------------------------------------------

} //namespace MoonGlare::Renderer::Resources 
		