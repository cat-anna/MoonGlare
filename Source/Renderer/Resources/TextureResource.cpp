/*
  * Generated by cppsrc.sh
  * On 2017-02-13 22:45:35,93
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "TextureResource.h"

#include "../Frame.h"
#include "../Commands/CommandQueue.h"
#include "../Commands/OpenGL/TextureCommands.h"

namespace MoonGlare::Renderer::Resources {

bool TextureResource::Initialize(ResourceManager *Owner) {
	RendererAssert(Owner);

	m_GLHandle.fill(InvalidTextureHandle);
	m_AllocationBitmap.ClearAllocation();

	if (Conf::TextureInitial > 0) {
		//TBD!!!
	}

	m_ResourceManager = Owner;
	return true;
}

bool TextureResource::Finalize() {
	return true;
}

bool TextureResource::Allocate(Frame *frame, TextureResourceHandle &out) {
	RendererAssert(frame);
	return Allocate(frame->GetControllCommandQueue(), out);
}

bool TextureResource::Allocate(Commands::CommandQueue &queue, TextureResourceHandle &out) {
	Bitmap::Index_t index;
	if (m_AllocationBitmap.Allocate(index)) {
		if (m_GLHandle[index] == InvalidTextureHandle) {
			IncrementPerformanceCounter(OpenGLAllocations);
			auto arg = queue.PushCommand<Commands::TextureSingleAllocate>();
			arg->m_Out = &m_GLHandle[index];
		}
		out.m_Index = static_cast<TextureResourceHandle::Index_t>(index);
		out.m_TmpGuard = GuardValue;
		IncrementPerformanceCounter(SuccessfulAllocations);
		return true;
	}
	else {
		AddLogf(Debug, "Texture allocation failed");
		IncrementPerformanceCounter(FailedAllocations);
		return false;
	}
}

void TextureResource::Release(Frame *frame, TextureResourceHandle h) {
	RendererAssert(h.m_TmpGuard == GuardValue);
	RendererAssert(h.m_Index < Conf::TextureLimit);

	if (m_AllocationBitmap.Release(h.m_Index)) {
		IncrementPerformanceCounter(SuccessfulDellocations);
	}
	else {
		AddLogf(Debug, "Texture deallocation failed");
		IncrementPerformanceCounter(FailedDellocations);
	}
}

} //namespace MoonGlare::Renderer::Resources 
		