/*
  * Generated by cppsrc.sh
  * On 2017-02-13 22:45:35,93
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "../nfRenderer.h"
#include "../Frame.h"
#include "../Renderer.h"
#include "../RenderDevice.h"

#include "../Commands/CommandQueue.h"
#include "../Commands/OpenGL/TextureCommands.h"

#include "ResourceManager.h"
#include "TextureResource.h"
#include "AsyncLoader.h"

#include <Renderer/Frame.h>
#include <Renderer/Renderer.h>
#include <Renderer/RenderDevice.h>
#include <Renderer/Resources/ResourceManager.h>            

#include "Loader/FreeImageLoader.h"

namespace MoonGlare::Renderer::Resources {

void TextureResource::Initialize(ResourceManager *Owner, Asset::TextureLoader *TexLoader) {
    RendererAssert(Owner);
    RendererAssert(TexLoader);
    m_ResourceManager = Owner;
    m_Settings = &Owner->GetConfiguration()->m_Texture;

    m_GLHandle.fill(Device::InvalidTextureHandle);
    m_TextureSize.fill(emath::usvec2(0,0));
    m_AllocationBitmap.ClearAllocation();
    generations.fill(1);
}

void TextureResource::Finalize() {
}

//---------------------------------------------------------------------------------------

bool TextureResource::Allocate(TextureResourceHandle &out) {
    Bitmap::Index_t index;
    if (m_AllocationBitmap.Allocate(index)) {
        out.index = static_cast<TextureResourceHandle::Index_t>(index);
        out.generation = generations[out.index];
        out.deviceHandle = &m_GLHandle[out.index];
        return true;
    }
    else {
        AddLogf(Debug, "Texture allocation failed");
        return false;
    }
}

void TextureResource::Release(TextureResourceHandle h) {
    if (!IsHandleValid(h))
        return;

    if (m_AllocationBitmap.Release(h.index)) {
        generations[h.index]++;
    }
    else {
        AddLogf(Debug, "Texture deallocation failed");
    }
}

//---------------------------------------------------------------------------------------

bool TextureResource::LoadTexture(TextureResourceHandle &hout, const std::string &uri, Configuration::TextureLoad config, bool CanAllocate, bool NeedSize) {
    auto cache = loadedTextures.find(uri);
    if (cache != loadedTextures.end() && IsHandleValid(cache->second)) {
        AddLogf(Debug, "texture load cache hit");
        hout = cache->second;
        return true;
    }

    if (!IsHandleValid(hout)) {
        if (!CanAllocate) {
            return false;
        }
        if (!Allocate(hout)) {
            DebugLogf(Error, "texture allocation - allocate failed");
            return false;
        }
    }

    config.Check(*m_Settings);
    auto loaderif = m_ResourceManager->GetLoaderIf();
    loaderif->QueueRequest(uri, std::make_shared<Loader::FreeImageLoader>(hout, this, config));

    loadedTextures[uri] = hout;

    if (NeedSize) {
        auto loader = m_ResourceManager->GetLoader();
        auto *size = &m_TextureSize[hout.index];
        loader->QueryTextureSize(uri, size);
    }

    return true;
}

emath::usvec2 TextureResource::GetSize(TextureResourceHandle h) const {
    if (!IsHandleValid(h))
        return {};

    return m_TextureSize[h.index];
}

bool TextureResource::IsHandleValid(TextureResourceHandle &h) const {
    if (h.index >= Conf::Limit)
        return false;
    if (generations[h.index] != h.generation) {
        return false;
    }
    return true;
}

//---------------------------------------------------------------------------------------

bool TextureResource::SetTexturePixels(TextureResourceHandle & out, Commands::CommandQueue & q, const void * Pixels, const emath::usvec2 & size, Configuration::TextureLoad config, Device::PixelFormat pxtype, bool AllowAllocate, Commands::CommandKey key, uint16_t TypeValue, uint16_t ElementSize) {
    if (!IsHandleValid(out) && AllowAllocate) {
        if (!Allocate(out)) {
            DebugLogf(Error, "texture allocation - allocate failed");
            return false;
        }
    }

    if (*out.deviceHandle == Device::InvalidTextureHandle)
        q.MakeCommand<Commands::TextureSingleAllocate>(out.deviceHandle);

    auto texres = q.PushCommand<Commands::Texture2DResourceBind>(key);
    texres->m_HandlePtr = GetHandleArrayBase() + out.index;

    m_TextureSize[out.index] = size;
    auto pixels = q.PushCommand<Commands::Texture2DSetPixelsArray>(key);
    pixels->size[0] = size[0];
    pixels->size[1] = size[1];
    pixels->pixels = Pixels;
    pixels->BPP = static_cast<GLenum>(pxtype);
    pixels->type = static_cast<GLenum>(TypeValue);

    config.Check(*m_Settings);
    q.PushCommand<Commands::Texture2DSetup>(key)->m_Config = config;

    return true;
}

} //namespace MoonGlare::Renderer::Resources 
        