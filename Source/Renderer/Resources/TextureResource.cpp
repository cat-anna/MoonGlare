/*
  * Generated by cppsrc.sh
  * On 2017-02-13 22:45:35,93
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "../nfRenderer.h"
#include "../Frame.h"
#include "../Renderer.h"
#include "../RenderDevice.h"

#include "../Commands/CommandQueue.h"
#include "../Commands/OpenGL/TextureCommands.h"

#include "ResourceManager.h"
#include "TextureResource.h"
#include "AsyncLoader.h"

#include <Renderer/Frame.h>
#include <Renderer/Renderer.h>
#include <Renderer/RenderDevice.h>
#include <Renderer/Resources/ResourceManager.h>            

#include "Loader/FreeImageLoader.h"

namespace MoonGlare::Renderer::Resources {

void TextureResource::Initialize(ResourceManager *Owner, Asset::TextureLoader *TexLoader) {
    RendererAssert(Owner);
    RendererAssert(TexLoader);
    m_ResourceManager = Owner;
    m_Settings = &Owner->GetConfiguration()->m_Texture;

    m_GLHandle.fill(Device::InvalidTextureHandle);
    m_TextureSize.fill(emath::usvec2(0));
    m_AllocationBitmap.ClearAllocation();
    generations.fill(1);
}

void TextureResource::Finalize() {
}

//---------------------------------------------------------------------------------------

bool TextureResource::Allocate(Frame *frame, TextureResourceHandle &out) {
    RendererAssert(frame);
    return Allocate(&frame->GetControllCommandQueue(), out);
}

bool TextureResource::Allocate(Commands::CommandQueue *queue, TextureResourceHandle &out) {
    Bitmap::Index_t index;
    if (m_AllocationBitmap.Allocate(index)) {
        if (queue && m_GLHandle[index] == Device::InvalidTextureHandle) {
            auto arg = queue->PushCommand<Commands::TextureSingleAllocate>();
            arg->m_Out = &m_GLHandle[index];
        }
        out.index = static_cast<TextureResourceHandle::Index_t>(index);
        out.generation = generations[out.index];
        out.deviceHandle = &m_GLHandle[out.index];
        return true;
    }
    else {
        AddLogf(Debug, "Texture allocation failed");
        return false;
    }
}

void TextureResource::Release(Frame *frame, TextureResourceHandle h) {
    if (!IsHandleValid(h))
        return;

    if (m_AllocationBitmap.Release(h.index)) {
        generations[h.index]++;
    }
    else {
        AddLogf(Debug, "Texture deallocation failed");
    }
}

//---------------------------------------------------------------------------------------

bool TextureResource::LoadTexture(TextureResourceHandle &out, const std::string &fPath, Configuration::TextureLoad config, bool CanAllocate, bool NeedSize) {
    if (!IsHandleValid(out)) {
        if (!CanAllocate) {
            return false;
        }
        if (!Allocate((Commands::CommandQueue*)nullptr, out)) {
            DebugLogf(Error, "texture allocation - allocate failed");
            return false;
        }
    }

    auto loaderif = m_ResourceManager->GetLoaderIf();
    config.Check(m_ResourceManager->GetConfiguration()->m_Texture);
    loaderif->QueueRequest(fPath, std::make_shared<Loader::FreeImageLoader>(out, this, config));

    if (NeedSize) {
        auto loader = m_ResourceManager->GetLoader();
        auto *size = &m_TextureSize[out.index];
        loader->QueryTextureSize(fPath, size);
    }

    return true;
}

emath::usvec2 TextureResource::GetSize(TextureResourceHandle h) const {
    if (!IsHandleValid(h))
        return {};

    return m_TextureSize[h.index];
}

bool TextureResource::IsHandleValid(TextureResourceHandle &h) const {
    if (h.index >= Conf::Limit)
        return false;
    if (generations[h.index] != h.generation) {
        return false;
    }
    return true;
}

//---------------------------------------------------------------------------------------

bool TextureResource::SetTexturePixels(TextureResourceHandle & out, Commands::CommandQueue & q, const void * Pixels, const emath::usvec2 & size, Configuration::TextureLoad config, Device::PixelFormat pxtype, bool AllowAllocate, Commands::CommandKey key, uint16_t TypeValue, uint16_t ElementSize) {
    if (!IsHandleValid(out) && AllowAllocate) {
        if (!Allocate(&q, out)) {
            DebugLogf(Error, "texture allocation - allocate failed");
            return false;
        }
    }

    auto texres = q.PushCommand<Commands::Texture2DResourceBind>(key);
    texres->m_HandlePtr = GetHandleArrayBase() + out.index;

    m_TextureSize[out.index] = size;
    auto pixels = q.PushCommand<Commands::Texture2DSetPixelsArray>(key);
    pixels->size[0] = size[0];
    pixels->size[1] = size[1];
    pixels->pixels = Pixels;
    pixels->BPP = static_cast<GLenum>(pxtype);
    pixels->type = static_cast<GLenum>(TypeValue);

    if (config.m_Filtering == Conf::Filtering::Default) {
        config.m_Filtering = m_Settings->m_Filtering;
    }
    q.PushCommand<Commands::Texture2DSetup>(key)->m_Config = config;

    return true;
}

} //namespace MoonGlare::Renderer::Resources 
        