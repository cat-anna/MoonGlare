/*
  * Generated by cppsrc.sh
  * On 2017-02-09 21:46:28,36
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "nfRenderer.h"
#include "RenderDevice.h"
#include "Renderer.h"
#include "Frame.h"

#include "Device/ErrorHandler.h"
#include "Device/DeviceInfo.h"

#include "Resources/Texture/FreeImageStore.h"

namespace MoonGlare::Renderer {

bool RenderDevice::Initialize(RendererFacade *renderer) {
    assert(renderer);

    m_RendererFacade = renderer;

    CriticalCheck(glewInit() == GLEW_OK, "Unable to initialize GLEW!");
    AddLog(Debug, "GLEW initialized");
    AddLog(System, "GLEW version: " << (char*) glewGetString(GLEW_VERSION));

    Device::ErrorHandler::RegisterErrorCallback();
    Device::DeviceInfo::ReadInfo();

    glClearColor(0.0f, 0.0f, 0.f, 0.0f);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_TEXTURE_2D);
    //glEnable(GL_FRAMEBUFFER_SRGB);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

//initialize default texture
    glBindTexture(GL_TEXTURE_2D, 0);
    static const unsigned char texd[] = { 255, 255, 255, };// 0, 255, 0, 0, 0, 255, 255, 255, 255 };
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, texd);

    for (uint8_t idx = 0; idx < Conf::Count; ++idx) {
        auto bit = 1u << idx;
        m_FreeFrameBuffers.fetch_or(bit);
        auto &buffer = m_Frames[idx];
        buffer = Memory::make_aligned<Frame>();
        if (!buffer->Initialize(idx, this, renderer)) {
            AddLogf(Error, "Frame buffer initialization failed!");
            return false;
        }
    }

    m_UnusedTextureRender.fill(nullptr);
    for (auto &item : m_TextureRenderTask) {
        if (!item.Initialize()) {
            AddLogf(Error, "TextureRenderTask initialization failed!");
            return false;
        }
        m_UnusedTextureRender.push(&item);
    }

    return true;
}

bool RenderDevice::Finalize() {

    AddLogf(Performance, "Allocated frames: %llu", frameCouter);

    for (auto &buffer : m_Frames) {
        if (!buffer->Finalize()) {
            AddLogf(Error, "Frame buffer finalization failed!");
        }
        buffer.reset();
    }

    return true;
}

//----------------------------------------------------------------------------------

Frame* RenderDevice::NextFrame() {
    for (uint32_t idx = 0; idx < Conf::Count; ++idx) {
        auto bit = 1u << idx;
        if ((m_FreeFrameBuffers.fetch_and(~bit) & bit) == bit) {
            auto fr = m_Frames[idx].get();
            fr->BeginFrame(++frameCouter);
            return fr;
        }
    }

    return nullptr;
}

void RenderDevice::Submit(Frame *frame) {
    while (m_PendingFrame.load() != nullptr)
        std::this_thread::yield();

    auto prevframe = m_PendingFrame.exchange(frame);
    if (prevframe) {
        auto bit = 1 << prevframe->Index();
        m_FreeFrameBuffers.fetch_or(bit);
        IncrementPerformanceCounter(DroppedFrames);
    }
}

void RenderDevice::ReleaseFrame(Frame *frame) {
    assert(frame);
    
    frame->EndFrame();

    auto &trtq = frame->GetTextureRenderQueue();
    for (auto *task : trtq) {
        m_UnusedTextureRender.push(task);
    }

    auto bit = 1 << frame->Index();
    m_FreeFrameBuffers.fetch_or(bit);
}

Frame *RenderDevice::PendingFrame() {
    return m_PendingFrame.exchange(nullptr);
}

//----------------------------------------------------------------------------------

void RenderDevice::Step() {
    ProcessPendingCtrlQueues();

    auto frame = PendingFrame();
    if (!frame)
        return;

    ProcessFrame(frame);
    ReleaseFrame(frame);
}

void RenderDevice::ProcessFrame(Frame *frame) {
    assert(frame);

    using Layer = Renderer::Frame::CommandLayers::LayerEnum;

    auto &cmdl = frame->GetCommandLayers();
    cmdl.Get<Layer::GUI>().Sort();

    auto Ctx = m_RendererFacade->GetContext();

    Ctx->Process();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glFlush();
    //frame->GetCommandLayers().Execute();
    cmdl.Execute();
    glFlush();

    Ctx->Flush();

    if (captureScreenShoot.exchange(false)) {
        CaptureScreenshoot(Ctx);
    }

    IncrementPerformanceCounter(FramesProcessed);
}

void RenderDevice::CaptureScreenshoot(MoonGlare::Renderer::iContext * Ctx) {
    auto s = Ctx->GetSize();
    uint32_t bytes = s[0] * s[1] * 4;    std::unique_ptr<uint8_t[]> memory(new uint8_t[bytes]);
    glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
    glFlush();
    glFinish();
    glReadPixels(0, 0, s[0], s[1], GL_BGRA, GL_UNSIGNED_BYTE, memory.get());
    m_RendererFacade->GetAsyncLoader()->QueueTask(
        std::make_shared<Resources::Texture::FreeImageStore>(std::move(memory), s, 32));
    AddLogf(Info, "Queued screen shoot store task");
}

//----------------------------------------------------------------------------------

void RenderDevice::ProcessPendingCtrlQueues() {
    auto *ccq = m_CommitCommandQueue.exchange(nullptr);
    if (ccq) {
        ccq->m_Queue->Execute();
        ccq->m_Commited = true;
    }
}

//----------------------------------------------------------------------------------

} //namespace MoonGlare::Renderer
