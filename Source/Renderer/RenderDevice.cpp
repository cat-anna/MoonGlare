/*
  * Generated by cppsrc.sh
  * On 2017-02-09 21:46:28,36
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "nfRenderer.h"
#include "RenderDevice.h"
#include "Frame.h"

#include "Device/ErrorHandler.h"
#include "Device/DeviceInfo.h"

namespace MoonGlare::Renderer {

RenderDevice::RenderDevice() :
		m_PendingFrame(nullptr) {

	SetPerformanceCounterOwner(DroppedFrames);
	SetPerformanceCounterOwner(FramesProcessed);
}

RenderDevice::~RenderDevice() {
}

bool RenderDevice::Initialize(RendererFacade *renderer) {
	CriticalCheck(glewInit() == GLEW_OK, "Unable to initialize GLEW!");
	AddLog(Debug, "GLEW initialized");
	AddLog(System, "GLEW version: " << (char*) glewGetString(GLEW_VERSION));

	Device::ErrorHandler::RegisterErrorCallback();
	Device::DeviceInfo::ReadInfo();

	for (uint8_t idx = 0; idx < Conf::Count; ++idx) {
		auto &buffer = m_Frames[idx];
		buffer = std::make_unique<Frame>();
		if (!buffer->Initialize(idx, this)) {
			AddLogf(Error, "Frame buffer initialization failed!");
			return false;
		}
	}

	if (!m_TextureIndexBuffer.Initialize()) {
		AddLogf(Error, "TextureIndexBuffer initialization failed!");
		return false;
	}

	m_UnusedTextureRender.fill(nullptr);
	for (auto &item : m_TextureRenderTask) {
		if (!item.Initialize()) {
			AddLogf(Error, "TextureRenderTask initialization failed!");
			return false;
		}
		m_UnusedTextureRender.push(&item);
	}

	return true;
}

bool RenderDevice::Finalize() {

	if (!m_TextureIndexBuffer.Finalize()) {
		AddLogf(Error, "m_TextureIndexBuffer finalization failed!");
	}

	for (auto &buffer : m_Frames) {
		if (!buffer->Finalize()) {
			AddLogf(Error, "Frame buffer finalization failed!");
		}
		buffer.reset();
	}

	return true;
}

//----------------------------------------------------------------------------------

Frame* RenderDevice::NextFrame() {
	for (uint32_t idx = 0; idx < Conf::Count; ++idx) {
		auto bit = 1u << idx;
		if ((m_FreeFrameBuffers.fetch_and(~bit) & bit) == bit) {
			auto fr = m_Frames[idx].get();
			fr->BeginFrame();
			return fr;
		}
	}

	return nullptr;
}

void RenderDevice::Submit(Frame *frame) {
	auto prevframe = m_PendingFrame.exchange(frame);
	if (prevframe) {
		auto bit = 1 << prevframe->Index();
		m_FreeFrameBuffers.fetch_or(bit);
		IncrementPerformanceCounter(DroppedFrames);
	}
}								  

//----------------------------------------------------------------------------------

void RenderDevice::Step() {
	auto frame = m_PendingFrame.exchange(nullptr);
	if (!frame)
		return;

	ProcessFrame(frame);

	auto bit = 1 << frame->Index();
	m_FreeFrameBuffers.fetch_or(bit);

}

void RenderDevice::ProcessFrame(Frame *frame) {

	auto &trtq = frame->GetTextureRenderQueue();
	for (auto *task : trtq) {

		task->Execute();
		m_UnusedTextureRender.push(task);
	}

	frame->EndFrame();
	IncrementPerformanceCounter(FramesProcessed);
}

//----------------------------------------------------------------------------------

} //namespace MoonGlare::Renderer
