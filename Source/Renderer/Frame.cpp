/*
  * Generated by cppsrc.sh
  * On 2017-02-10 15:35:25,52
  * by Kalessin
*/
/*--END OF HEADER BLOCK--*/

#include "nfRenderer.h"
#include "Resources/ResourceManager.h"
#include "Frame.h"

#include "Renderer.h"

#include "TextureRenderTask.h"

#include "Resources/ResourceManager.h"
#include "Resources/Texture/TextureResource.h"
#include "Resources/Mesh/VAOResource.h"

namespace MoonGlare::Renderer {

void Frame::ReleaseResource(TextureResourceHandle &texres) {
    RendererAssert(this);
    GetResourceManager()->GetTextureResource().Release(texres);
}
void Frame::ReleaseResource(VAOResourceHandle &vaores) {
    RendererAssert(this);
    GetResourceManager()->GetVAOResource().Release(this, vaores);
}
bool Frame::AllocateResource(TextureResourceHandle &resH) {
    RendererAssert(this);
    return GetResourceManager()->GetTextureResource().Allocate(resH);
}
bool Frame::AllocateResource(VAOResourceHandle &resH) {
    RendererAssert(this);
    return GetResourceManager()->GetVAOResource().Allocate(this, resH);
}

//----------------------------------------------------------------------------------

bool Frame::Initialize(uint8_t BufferIndex, RenderDevice *device, RendererFacade *rfacade) {
    RendererAssert(BufferIndex < Configuration::FrameBuffer::Count);
    RendererAssert(device);
    RendererAssert(rfacade);
    
    m_BufferIndex = BufferIndex;
    m_RenderDevice = device;
    m_ResourceManager = rfacade->GetResourceManager();

    m_QueuedTextureRender.ClearAllocation();
    m_SubQueueTable.ClearAllocation();
    //m_Textures.ClearAllocation();
    m_VAOs.ClearAllocation();
    planeShadowMaps.ClearAllocation();

    m_CommandLayers.Clear();

    m_Memory.Clear();

    for (auto &q : m_SubQueueTable)
        q.Clear();

    PlaneShadowMap psm;
    psm.textureHandle = Device::InvalidTextureHandle;
    psm.framebufferHandle = Device::InvalidFramebufferHandle;
    //psm.size = conf->shadow.shadowMapSize;
    psm.valid = false;
    planeShadowMaps.fill(psm);

    flags.shadowsEnabled = rfacade->GetConfiguration()->shadow.enableShadows;
    shadowMapSize = rfacade->GetConfiguration()->shadow.shadowMapSize;

    return true;
}

bool Frame::Finalize() {
    return true;
}

//----------------------------------------------------------------------------------

void Frame::BeginFrame(uint64_t index) {
    frameIndex = index;
    m_QueuedTextureRender.ClearAllocation();
    m_SubQueueTable.ClearAllocation();

    m_CommandLayers.ClearAllocation();

    //m_Textures.ClearAllocation();
    m_VAOs.ClearAllocation();
    planeShadowMaps.ClearAllocation();

    m_Memory.Clear();
}

void Frame::EndFrame() {
}

//----------------------------------------------------------------------------------
 
bool Frame::Submit(TextureRenderTask *trt) {
    RendererAssert(trt);
    m_CommandLayers.Get<Conf::Layer::PreRender>().PushQueue(&trt->GetCommandQueue());
    return m_QueuedTextureRender.push(trt);
}

bool Frame::Submit(SubQueue *q, Conf::Layer Layer, Commands::CommandKey Key) {
    RendererAssert(q);
    m_CommandLayers[Layer].PushQueue(q, Key);
    return false;
}

//----------------------------------------------------------------------------------

} //namespace MoonGlare::Renderer 
