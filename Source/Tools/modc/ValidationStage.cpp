/*
	Generated by cppsrc.sh
	On 2015-01-04  8:08:24,71
	by Paweu
*/
#include <pch.h>
#include "Pipeline.h"
namespace modc {
namespace pipeline {	

void ValidationStage::ValidateStage(WorkConfiguration &data) {
	if (Verbosity::PrintStep())
		cout << data.StageCounter() << "Performing module validation\n";
}

void ValidationStage::SkipStage(WorkConfiguration &data) {
	if (Verbosity::PrintStep())
		cout << data.StageCounter() << "Skipping module validation\n";
	for (auto &it : data.FileList) {
		it.Validated = true;
		it.Needed = true;
	}
}

#if 0
ValidationStage::ValidationStage() {
	m_Errors = 0;
}

ValidationStage::~ValidationStage() {
}

//---------------------------------------------------------------------------------------

void ValidationStage::RegisterFile(WorkConfiguration &data, const string& SrcFile, const string& parentfile) {
	string file = SrcFile;
	if (!parentfile.empty()) {
		const char *s = parentfile.c_str();
		const char *c = strrchr(s, '/');
		if (!c) c = strrchr(s, '\\');
		if (c) {
			file = string(s, c - s + 1);
			file += SrcFile;
		}
	}
	m_SrcFileList.push_back(file);
	MediaTest::QueueMediaTest(*data.pipeline, file, m_WeakThis.lock());
}

//---------------------------------------------------------------------------------------

void ValidationStage::Queue(WorkConfiguration &data) {
	std::shared_ptr<ValidationStage> fs(new ValidationStage());
	fs->m_WeakThis = fs;

	data.pipeline->QueueFirstAction([fs](WorkConfiguration &data) { fs->PreTest(data); });

	data.pipeline->QueueAction([fs](WorkConfiguration &data) { fs->LoadPatterns(data); }, Pipeline::Priority::Second);
	data.pipeline->QueueAction([fs](WorkConfiguration &data) { fs->LoadClasses(data); }, Pipeline::Priority::Second);

	data.pipeline->QueueAction([fs](WorkConfiguration &data) { fs->BeginProcess(data); });
}

void ValidationStage::PreTest(WorkConfiguration &data) {
	if (!data.input.CanRead()) {
		throw "Cannot validate not readable module!";
	}
}

void ValidationStage::LoadPatterns(WorkConfiguration &data) {
	if (m_PatternsDoc.load_file(data.validation.PatternFile.c_str()).status != pugi::status_ok) {
		throw "Unable to load patterns xml!";
	}

	xml_node root = m_PatternsDoc.document_element();
	for (auto node = root.child("Pattern"); node; node = node.next_sibling("Pattern")) {
		string Name = node.attribute("Name").as_string();
		m_Patterns[Name] = node;
	}
}

void ValidationStage::LoadClasses(WorkConfiguration &data) {
	xml_document classes;
	if (!classes.load_file(data.validation.ClassesFile.c_str())) {
		throw "Unable to load patterns xml!";
	}

	xml_node root = classes.document_element();
	for (auto node = root.child("List"); node; node = node.next_sibling("List")) {
		string Name = node.attribute("Name").as_string();
		
		auto &list = m_Classes[Name];

		for (auto item = node.child("Class"); item; item = item.next_sibling("Class")) {
			ClassInfo ci;
			ci.Name = item.attribute("Name").as_string();
			ci.ClassName = item.attribute("ClassName").as_string();
			
			list[ci.Name] = std::move(ci);
		}
	}
}

void ValidationStage::BeginProcess(WorkConfiguration &data) {
	RegisterFile(data, "Module.xml");
	ValidateXML("Module.xml", "Module", data);
	auto fs = m_WeakThis.lock();
	data.pipeline->QueueLastAction([fs](WorkConfiguration &data) { fs->EndProcess(data); });
}

void ValidationStage::EndProcess(WorkConfiguration &data) {
	auto fs = m_WeakThis.lock();
	if (data.IsPrintClasses()) {
		data.pipeline->QueueAction([fs](WorkConfiguration &data) {
			cout << "\nAll known classes:\n";
			for (auto &it : fs->m_Classes) {
				cout << it.first << "\n";
				for (auto &jt : it.second) {
					cout << "\t" << jt.second.Name << "\n";
				}
			}
			cout << "\n";
		}, Pipeline::Priority::FreeTime);
	}

	if (data.IsPrintResources()) {
		data.pipeline->QueueAction([fs](WorkConfiguration &data) {
			cout << "\nAll known Resources:\n";
			for (auto &it : fs->m_Resources) {
				cout << it.first << "\n";
				for (auto &jt : it.second) {
					char buf[128];
					sprintf(buf, "\t%20s [class %s]\n", jt.second.Name.c_str(), jt.second.Class.c_str());
					cout << buf;
				}
			}
			cout << "\n";
		}, Pipeline::Priority::FreeTime);
	}

	if (data.IsPrintFileList()) {
		data.pipeline->QueueAction([fs](WorkConfiguration &data) {
			cout << "\nAll known files:\n";
			for (auto &it : fs->m_SrcFileList) {
				cout << it << "\n";
			}
			cout << "\n";
		}, Pipeline::Priority::FreeTime);
	}

	if (!data.ContentOut.IsDoNotGenerateXML()) {
		data.pipeline->QueueAction([fs](WorkConfiguration &data) {
			xml_document doc;
			auto root = doc.append_child("Resources");
			root.append_attribute("Module") = data.input.ModuleName.c_str();
			for (auto &it : fs->m_Resources) {
				auto list = root.append_child("List");
				list.append_attribute("Name") = it.first.c_str();
				for (auto &jt : it.second) {
					auto item = list.append_child("Item");
					item.append_attribute("Name") = jt.second.Name.c_str();
					item.append_attribute("Class") = jt.second.Class.c_str();
				}
			}
			string file = data.input.ModuleName.c_str();
			file += ".xml";
			doc.save_file(file.c_str());			
		}, Pipeline::Priority::FreeTime);
	}
}

//---------------------------------------------------------------------------------------

void ValidationStage::ValidateXML(string filepath, string pattern, WorkConfiguration &data) {
	auto fs = m_WeakThis.lock();
	data.pipeline->QueueAction([this, fs, filepath, pattern](WorkConfiguration &data) { 
		auto f = data.input.container->GetFileReader(filepath);
		if (!f) {
			cout << "Error: Unable to open module file " << filepath << "\n";
			m_Errors++;
			return;
		}
		xml_document source;
		source.load_buffer(f->GetFileData(), f->Size());

		xml_node paternxml = m_Patterns[pattern];
		if (!paternxml) {
			cout << "Error: There is no pattern " << pattern << "\n";
			return;
		}

		DoValidation(filepath, source, paternxml, data);
	});
}

struct RootError {
	string msg;
	RootError(const string &amsg) : msg(amsg) {}
};

struct PatternError : public RootError {
	xml_node node;
	PatternError(const string &amsg, xml_node anode) : RootError(amsg), node(anode) {}
};

struct XMLError : public RootError {
	string nodename;
	xml_node node;
	XMLError(const char *amsg, const string &node, xml_node anode = xml_node()) : RootError(amsg), nodename(node), node(anode) {}
};

struct XMLValueGetter {
	virtual ~XMLValueGetter() { }
	virtual const char* get() = 0;
	virtual const char* sibling_get(const char* sibling_name) {	return 0; }
};

struct XMLAttribValueGetter : public XMLValueGetter {
	xml_attribute attribute;
	xml_node parent;
	XMLAttribValueGetter(xml_attribute att, xml_node aparent) : attribute(att), parent(aparent) { }
	const char* get() { return attribute.as_string(); }
	virtual const char* sibling_get(const char* sibling_name) { return parent.attribute(sibling_name).as_string(); }
};

struct XMLTextValueGetter : public XMLValueGetter {
	pugi::xml_text text;
	xml_node parent;
	XMLTextValueGetter(pugi::xml_text t, xml_node aparent) : text(t), parent(aparent) { }
	const char* get() { return text.as_string(); }
	virtual const char* sibling_get(const char* sibling_name) { return parent.attribute(sibling_name).as_string(); }
};

void ValidationStage::DoValidation(const string& xmlfileName, xml_node src_root, xml_node src_pattern, WorkConfiguration &data) {
	enum class NodeMode : unsigned {
		Unknown,
		Node,
		List,
		Text,
		Attribute,
		Register,
		SubFile,
		Check,
		Grab,
		SubPattern,
	};
	struct NodeInfo {
		xml_node root;
		xml_node pattern;
		NodeMode mode;
		WorkConfiguration *data;
		std::list<NodeInfo> *queue;
		ValidationStage *stage;
		std::shared_ptr<XMLValueGetter> ParentValue;
		string CurrentDir;

		struct Mask {
			enum {
				mask_Node				= 1 << (unsigned)NodeMode::Node,
				mask_List				= 1 << (unsigned)NodeMode::List,
				mask_Text				= 1 << (unsigned)NodeMode::Text,
				mask_Attribute			= 1 << (unsigned)NodeMode::Attribute,
				mask_Register			= 1 << (unsigned)NodeMode::Register,
				mask_SubFile			= 1 << (unsigned)NodeMode::SubFile,
				mask_Check				= 1 << (unsigned)NodeMode::Check,
				mask_Grab				= 1 << (unsigned)NodeMode::Grab,
				mask_SubPattern			= 1 << (unsigned)NodeMode::SubPattern,
				
				maskset_List		= mask_Node | mask_Attribute | mask_SubPattern,
				maskset_Node		= mask_Node | mask_List | mask_Text | mask_Attribute | mask_SubPattern,
				maskset_Text		= mask_Register | mask_Grab | mask_SubPattern,
				maskset_Attribute	= mask_Register | mask_SubFile | mask_Check | mask_Grab | mask_SubPattern,
				maskset_SubPattern  = maskset_Node,
			};
		};

		void DispatchSubPatterns(xml_node node, unsigned mask, std::shared_ptr<XMLValueGetter> getter = 0) {
			for (auto patchild = pattern.first_child(); patchild; patchild = patchild.next_sibling()) {
				NodeInfo ni{ node, patchild, NodeMode::Unknown, data, queue, stage, getter, CurrentDir };
				if (!strcmpi("Node", patchild.name()) && (mask & Mask::mask_Node)) {
					ni.mode = NodeMode::Node;
					queue->push_back(ni);
					continue;
				}

				if (!strcmpi("List", patchild.name()) && (mask & Mask::mask_List)) {
					ni.mode = NodeMode::List;
					queue->push_back(ni);
					continue;
				}

				if (!strcmpi("Attribute", patchild.name()) && (mask & Mask::mask_Attribute)) {
					ni.mode = NodeMode::Attribute;
					queue->push_back(ni);
					continue;
				}

				if (!strcmpi("Text", patchild.name()) && (mask & Mask::mask_Text)) {
					ni.mode = NodeMode::Text;
					queue->push_back(ni);
					continue;
				}

				if (!strcmpi("SubFile", patchild.name()) && (mask & Mask::mask_SubFile)) {
					ni.mode = NodeMode::SubFile;
					queue->push_back(ni);
					continue;
				}

				if (!strcmpi("Register", patchild.name()) && (mask & Mask::mask_Register)) {
					ni.mode = NodeMode::Register;
					queue->push_back(ni);
					continue;
				}

				if (!strcmpi("Check", patchild.name()) && (mask & Mask::mask_Check)) {
					ni.mode = NodeMode::Check;
					queue->push_back(ni);
					continue;
				}

				if (!strcmpi("Grab", patchild.name()) && (mask & Mask::mask_Grab)) {
					ni.mode = NodeMode::Grab;
					queue->push_back(ni);
					continue;
				}

				if (!strcmpi("SubPattern", patchild.name()) && (mask & Mask::mask_SubPattern)) {
					ni.mode = NodeMode::SubPattern;
					queue->push_back(ni);
					continue;
				}

				throw PatternError("Unknown pattern node!", patchild);
			}
		}

		void TestSubPattern() {
			const char *Which = pattern.attribute("Which").as_string("");
			bool UseKind = pattern.attribute("UseKind").as_bool(false);

			string patname = Which;
			if (UseKind) {
				if (!ParentValue) {
					throw PatternError("SubPattern used kind mode under wrong node!", pattern);
				}
				patname += "_";
				patname += ParentValue->get();
			}

			auto it = stage->m_Patterns.find(patname);
			if (it == stage->m_Patterns.end()) 
				throw PatternError(string("Subpattern does not exists - ") += patname, pattern);

			pattern = it->second;
			DispatchSubPatterns(root, Mask::maskset_SubPattern, 0);
		}

		void TestGrab() {
			const char *Where = pattern.attribute("Where").as_string(0);
			if (!Where) throw PatternError("No destination specified", pattern);

			if (!ParentValue) {
				throw PatternError("Grab call placed under wrong node!", pattern);
			}

			if (!strcmpi("InputModuleName", Where) ) {
				data->input.ModuleName = ParentValue->get();
				return;
			}
			throw PatternError("Unsupported register type!", pattern);
		}

		void TestCheck() {
			const char *Where = pattern.attribute("Where").as_string(0);
			const char *List = pattern.attribute("List").as_string(0);
			if (!Where) throw PatternError("No 'Where' for Check action", pattern);
			if (!List) throw PatternError("No 'List' for Check action", pattern);

			if (!ParentValue) {
				throw PatternError("Ckeck call placed under wrong node!", pattern);
			}

			if (!strcmpi("Class", Where)) {
				string sList = List;
				string Value = ParentValue->get();
				auto stagep = stage->m_WeakThis.lock();
				data->pipeline->QueueAction(
					[sList, Value, stagep](WorkConfiguration &data) {
						auto &list = stagep->m_Classes[sList];
						auto itemit = list.find(Value);
						if (itemit == list.end()) {
							cout << "Module Error: There is no Class " << Value << " in list " << sList << "\n";
						}
					}, Pipeline::Priority::Later);
				return;
			}
			if (!strcmpi("Resource", Where)) {
				string sList = List;
				string Value = ParentValue->get();
				auto stagep = stage->m_WeakThis.lock();
				data->pipeline->QueueAction(
					[sList, Value, stagep](WorkConfiguration &data) {
					auto &list = stagep->m_Resources[sList];
					auto itemit = list.find(Value);
					if (itemit == list.end()) {
						cout << "Module Error: There is no resource " << Value << " in list " << sList << "\n";
					}
				}, Pipeline::Priority::Later);

				return;
			}
		}

		void TestText() {
			const char *TypeName = pattern.attribute("Type").as_string();
			bool optional = pattern.attribute("Optional").as_bool(false);
			if (!TypeName) throw PatternError("No text value type specified", pattern);

			if (data->IsFullVerbosity())
				cout << "Testing text " << root.path() << ":\n";

			auto txt = root.text();
			const char *value = txt.as_string(0);
			if (!txt || !value) {
				if (!optional)
					throw XMLError("Required text does not exists", root.name(), root);
				return;
			}
			DispatchSubPatterns(root, Mask::maskset_Text, std::shared_ptr<XMLValueGetter>(new XMLTextValueGetter(txt, root)));
		}

		void TestSubFile() {
			const char *PattName = pattern.attribute("Pattern").as_string();
			const char *Where = pattern.attribute("Where").as_string(0);
			if (!PattName) throw PatternError("No pattern name specified", pattern);

			if (!ParentValue) {
				throw PatternError("SubFile call placed under wrong node!", pattern);
			}

			string fn;
			if (pattern.attribute("Relative").as_bool(true))
				fn = CurrentDir;
			if (Where) {
				fn += Where;
				fn += "/";
			}
			fn += ParentValue->get();
			if (pattern.attribute("NameSubPath").as_bool(false)) {
				fn += "/";
				fn += ParentValue->get();
			}
			fn += pattern.attribute("FileType").as_string("");
			if (backstrcmpi(fn.c_str(), ".xml"))
				fn += ".xml";

			string patt = PattName;
			const char *kind_name = pattern.attribute("PatternKind").as_string(0);
			if (kind_name) {
				const char *patt_kind = ParentValue->sibling_get(kind_name);
				if (!patt_kind)
					throw PatternError("unable to get pattern kind!", pattern);
				patt += "_";
				patt += patt_kind;
			}

			stage->ValidateXML(fn, patt, *data);
		}

		void TestRegister() {
			const char *RegType = pattern.attribute("Type").as_string();
			const char *Where = pattern.attribute("Where").as_string(0);
			if (!RegType) throw PatternError("No register type specified", pattern);

			if (!ParentValue) {
				throw PatternError("Register call placed under wrong node!", pattern);
			}

			if (!strcmpi("File", RegType) ) {
				string fn;
				if (pattern.attribute("Relative").as_bool(true))
					fn = CurrentDir;
				if (Where && *Where) {
					fn += Where;
					fn += "/";
				}
				fn += ParentValue->get();
				if (pattern.attribute("NameSubPath").as_bool(false)) {
					fn += "/";
					fn += ParentValue->get();
				}
				fn += pattern.attribute("FileType").as_string("");
				stage->RegisterFile(*data, fn);
				return;
			}

			if (!strcmpi("Resource", RegType)) {
				if (!Where) 
					throw PatternError("No list specified to register resource!", pattern);
				stage->RegisterResource(Where, ParentValue->get(), ParentValue->sibling_get("Class"));
				return;
			}
			throw PatternError("Unsupported register type!", pattern);
		}

		void TestAttribute() {
			const char *AttName = pattern.attribute("Name").as_string();
			const char *TypeName = pattern.attribute("Type").as_string();
			bool optional = pattern.attribute("Optional").as_bool(false);
			if (!AttName) throw PatternError("No attribute name specified", pattern);
			if (!TypeName) throw PatternError("No attribute value type specified", pattern);

			if (data->IsFullVerbosity())
				cout << "Testing attibute " << root.path() << ":[" << AttName << "]\n";
			
			xml_attribute att = root.attribute(AttName);
			const char *value = att.as_string(0);
			if (!att || !value) {
				if (!optional)
					throw XMLError("Required attribute does not exists", AttName, root);
				return;
			}

			DispatchSubPatterns(root, Mask::maskset_Attribute, std::shared_ptr<XMLValueGetter>(new XMLAttribValueGetter(att, root)));
		}

		void TestList() {
			const char *NodeName = pattern.attribute("Name").as_string();
			const char *ChildName = pattern.attribute("Child").as_string();
			bool optional = pattern.attribute("Optional").as_bool(false);
			if (!NodeName) throw PatternError("No list name specified", pattern);
			if (!ChildName) throw PatternError("No list child specified", pattern);

			if (data->IsFullVerbosity())
				cout << "Testing list " << root.path() << "/[" << NodeName << ":" << ChildName << "]\n";

			xml_node node = root.child(NodeName);
			if (!node) {
				if (!optional)
					throw XMLError("Required node does not exists", NodeName, root);
				return;
			}
			for (auto item = node.child(ChildName); item; item = item.next_sibling(ChildName)) {
				DispatchSubPatterns(item, Mask::maskset_List);
			}
		}

		void TestNode() {

			const char *NodeName = pattern.attribute("Name").as_string();
			bool optional = pattern.attribute("Optional").as_bool(false);
			if (!NodeName) throw PatternError("No node name specified", pattern);

			if (data->IsFullVerbosity())
				cout << "Testing node " << root.path() << "/[" << NodeName << "]\n";

			xml_node node = root.child(NodeName);
			if (!node) {
				if (!optional)
					throw XMLError("Required node does not exists", NodeName, root);
				return;
			}

			DispatchSubPatterns(node, Mask::maskset_Node);
		}
	};
	std::list<NodeInfo> queue;

	string path = xmlfileName;
	if (!path.empty()) {
		char *c = (char*)path.c_str();
		c = strrchr(c, '/');
		if (!c) c = strrchr((char*)path.c_str(), '\\');
		if (c) {
			c[1] = 0;
		} else
			path = "";
	}
	{
		NodeInfo ni{ src_root, src_pattern, NodeMode::Node, &data, &queue, this, 0, path.c_str() };
		ni.DispatchSubPatterns(src_root, NodeInfo::Mask::maskset_Node);
	}

	while (!queue.empty()) {
		NodeInfo ni = queue.front();
		queue.pop_front();

		try {
			switch (ni.mode) {
			case NodeMode::Node:
				ni.TestNode();
				continue;
			case NodeMode::List:
				ni.TestList();
				continue;
			case NodeMode::Attribute:
				ni.TestAttribute();
				continue;
			case NodeMode::Text:
				ni.TestText();
				continue;

			case NodeMode::Register:
				ni.TestRegister();
				continue;
			case NodeMode::SubFile:
				ni.TestSubFile();
				continue;
			case NodeMode::Check:
				ni.TestCheck();
				continue;
			case NodeMode::Grab:
				ni.TestGrab();
				continue;
			case NodeMode::SubPattern:
				ni.TestSubPattern();
				continue;
			}
		}
		catch (const PatternError& e) {
			cout << "Pattern Error: " << e.msg << "  xpath:" << e.node.path() << "\n";
			continue;
		}		
		catch (const XMLError& e) {
			cout << "XML Error: " << e.msg << "  Node:" << e.nodename << " xpath:" << e.node.path() << "  file:" << xmlfileName << "\n";
			m_Errors++;
			continue;
		}
	}
}
#endif

}// namespace pipeline
}// namespace modc