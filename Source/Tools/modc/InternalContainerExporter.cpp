/*
  * Generated by cppsrc.sh
  * On 2015-03-29 16:03:06,65
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include "Pipeline.h"
#include "InternalContainerExporter.h"
#include <boost/filesystem.hpp>

using namespace MoonGlare::FileSystem;
extern string GetApplicationInfoBanner();

namespace modc {

std::atomic<unsigned> InternalContainerFileNode::_Counter(0);

class ContainerFileWritter : public MoonGlare::FileSystem::iFileWritter {
	GABI_DECLARE_STATIC_CLASS(ContainerFileWritter,MoonGlare::FileSystem:: iFileWritter);
public:
	ContainerFileWritter(InternalContainer *Owner, InternalContainerFileNode *File) :
			BaseClass(Owner), 
			m_Owner(Owner),
			m_File(File) {
	}
	~ContainerFileWritter() { 
		m_Owner->StoreFile(m_File);
	}

	bool SetFileData(const char* data, FileSize size) override { 
		m_File->Data.reset(new char[size + 1]);
		m_File->Data[size] = 0;
		memcpy(m_File->Data.get(), data, size);
		m_File->Size = size;
		return true;
	}
	bool OwnData(std::unique_ptr<char[]> data, FileSize size) override { 
		m_File->Data.reset();
		m_File->Data.swap(data);
		m_File->Size = size;
		return true;
	}

	virtual FileSize Size() const { return m_File->Size; }
	virtual const char* GetFileData() const { return m_File->Data.get(); }
	virtual const string& FileName() const { return m_File->Name; }
private:
	InternalContainer *m_Owner;
	InternalContainerFileNode *m_File;
};

GABI_IMPLEMENT_STATIC_CLASS(ContainerFileWritter)

//-------------------------------------------------------------------------------------------------

GABI_IMPLEMENT_STATIC_CLASS(InternalContainer)

InternalContainer::InternalContainer(const string &FileName, const InternalContainerSettings &settings):
		m_FileName(FileName),
		m_Root(new InternalContainerFileNode()) {
	m_Settings = settings;
	m_Root->Name = "Root";
	m_Root->Directory = true;

	m_File.open(m_FileName, std::ios::out);

	m_File <<
		"/*\n"
		" * File generated by:\n"
		" * " << GetApplicationInfoBanner() << "\n"
		" *\n"
		" * This is machine generated file. Do not edit.\n"
		" *\n"
		" */\n"
		"\n";
	m_File <<
		"#ifdef WINDOWS\n"
		"#pragma comment(\"lib\", \"/OPT:NOREF\")\n"
		"#endif\n";
	m_File << "\n";

	for (auto &it : m_Settings.NamespaceLocation)
		m_File << "namespace " << it << " {\n";

	m_File <<
		"\n"
		"#ifdef InternalContainer_H\n"
		"using Node = MoonGlare::FileSystem::InternalContainer::FileNode;\n"
		"using Flags = MoonGlare::FileSystem::InternalContainer::FileFlags;\n"
		"#else\n"
		"#error Internal container header is not included!\n"
		"#endif\n\n"
		"// File data\n\n";

	m_File.flush();
	SetWritable(true);
	SetReady(true);
}

InternalContainer::~InternalContainer() {
	CloseContainer();
}

//-------------------------------------------------------------------------------------------------

MoonGlare::FileSystem::FileWritter InternalContainer::GetFileWritter(const string& filename) {
	auto file = FindOrAlloc(filename);
	if (file->Stored)
		return nullptr;
	return std::make_shared<ContainerFileWritter>(this, file);
}

bool InternalContainer::StoreFile(InternalContainerFileNode *file) {
	AddLog(Debug, "Storing file '" << file->Path() << "'");

	file->Stored = true;
	file->DataName = file->Name;
	file->DataName += "_file_";
	char buffer[9] = {};
	sprintf(buffer, "%04d", file->FileIndex);
	file->DataName += buffer;
	for (auto &it : file->DataName)
		switch (it) {
		case '.':
		//case '':
			it = '_';
		default:
			continue;
		}
	boost::filesystem::path p(m_FileName);
	boost::filesystem::path dir = p.parent_path();
	char filename[256];
	string rdir = dir.string();
	if (!rdir.empty())
		rdir += "/";
	sprintf(filename, "%sfile.%04d", rdir.c_str(), file->FileIndex);

	m_File << "#include \"" << filename << "\"\n";
	m_File.flush();

	std::ofstream outf(filename, std::ios::out);

	outf << "const unsigned char " << file->DataName << "[] = {";
	char buf[16];
	for (FileSize i = 0; i < file->Size; ++i) {
		if ((i % 16) == 0)
			outf << "\n\t";
		sprintf(buf, "0x%02x, ", file->Data[i] & 0xFF);
		outf << buf;
	}
	outf << "\n\t0x00,\n};\n\n";
	outf.flush();
	outf.close();

	return true;
}

//-------------------------------------------------------------------------------------------------

InternalContainerFileNode* InternalContainer::FindOrAlloc(const string& FileName) {
	InternalContainerFileNode *ptr = m_Root.get();

	const char* p = FileName.c_str();
	for (;;){
		while (*p == '\\' || *p == '/') ++p;
		const char* next = strchr(p, '\\');
		if (!next) next = strchr(p, '/');
		try{
			auto it = ptr->Children.begin();
			auto jt = ptr->Children.end();
			for (; it != jt; ++it){
				InternalContainerFileNode *i = it->get();
				const char* s = p;
				const char* t = i->Name.c_str();
				for (;;){
					if ((*s == '\\' || *s == '/' || !*s) && !*t){
						throw i;
					}
					if ((*s | 0x20) != (*t | 0x20)) break;
					++s;
					++t;
				}
			}
			if (!next) {
				InternalContainerFileNodePtr newf = std::make_unique<InternalContainerFileNode>();
				newf->Directory = false;
				newf->Name = string(p);
				newf->Parent = ptr;
				AddLog(Debug, "Allocated file in container: " << newf->Name);
				ptr->Children.emplace_back(std::move(newf));
				return ptr->Children.back().get();
			}
			else 
			{
				InternalContainerFileNodePtr newf = std::make_unique<InternalContainerFileNode>();
				newf->Directory = true;
				newf->Name = string(p, next - p);
				newf->Parent = ptr;
				AddLog(Debug, "Allocated directory in container: " << newf->Name);
				ptr->Children.emplace_back(std::move(newf));
				ptr = ptr->Children.back().get();
				p = next + 1;
				continue;
			}
		}
		catch (InternalContainerFileNode *i){
			if (!next) return i;
			p = next + 1;
			ptr = i;
			continue;
		}
	}
}

//-------------------------------------------------------------------------------------------------

void InternalContainer::CloseContainer() {

	std::list<InternalContainerFileNode*> FolderStack;

	struct T {
		static void traverse(std::list<InternalContainerFileNode*> &list, InternalContainerFileNode*p) {
			if (!p->Directory)
				return;

			for (auto &it : p->Children)
				traverse(list, it.get());

			list.push_back(p);
		}
	};

	T::traverse(FolderStack, m_Root.get());

	m_File << "\n// Container structure\n\n";

	while (!FolderStack.empty()) {
		auto *dir = FolderStack.front();
		FolderStack.pop_front();

		dir->Stored = true;
		dir->DataName = dir->Name;
		dir->DataName += "_folder";
		for (auto &it : dir->DataName)
			switch (it) {
			case '.':
			//case '':
				it = '_';
			default:
				continue;
			}

		if (!dir->Parent) {
			m_File << "extern const Node " << dir->DataName << "[];\n";
		} else
			m_File << "static\n";

		m_File << "const Node " << dir->DataName << "[] = {\n";

		for (auto &it : dir->Children) {
			char buf[256];
			if (it->Directory) {
				sprintf(buf, "\t{ Flags::Folder, 0, 0, %s, \"%s\" }, // file index: %d\n", 
						it->DataName.c_str(), it->Name.c_str(), it->FileIndex);
			} else {
				sprintf(buf, "\t{ Flags::File, %s, %d, 0, \"%s\" }, // file index: %d\n", 
						it->DataName.c_str(), it->Size, it->Name.c_str(), it->FileIndex);
			}

			m_File << buf;
		}

		m_File << 
			"\t{ },\n"
			"};\n\n";
	}

	for (auto it = m_Settings.NamespaceLocation.rbegin(), jt = m_Settings.NamespaceLocation.rend(); it != jt; ++it)
		m_File << "} // namespace " << *it << "\n";
	m_File << "\n";
	m_File.close();
}

//-------------------------------------------------------------------------------------------------

void InternalContainerSettings::Parse(SettingsMap &data) {
	data.InvokeAndRemove("namespace", [this](const string& value) {
		std::stringstream ss(value);
		std::string item;
		while (std::getline(ss, item, '.')) {
			NamespaceLocation.push_back(item);
		}
	});
}

} //namespace modc 
