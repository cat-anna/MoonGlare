/*
  * Generated by cppsrc.sh
  * On 2015-03-10 22:23:21,05
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include "Pipeline.h"
#include <libs/InternalFileSystem/FolderContainer.h>
#include <libs/InternalFileSystem/MoonGlareContainer/nMoonGlareContainer.h>

namespace modc {
namespace pipeline {

struct InputStageImpl : InputStage {

	void ValidateStage(WorkConfiguration &data) {
		if (Verbosity::PrintSubStep())
			cout << data->StageCounter()  << "Validating input stage\n";

		if (!data.input.Validate())
			throw "Invalid input container!";
		if (!data.input.CanRead())
			throw "Input container is not readable!";

		auto fs = shared<InputStageImpl>();
		data.pipeline->QueueAction([fs](WorkConfiguration &data) { fs->ProcessStage(data); });
	}

	void OpenSource(WorkConfiguration &data) {
		auto &src = data.input;

		switch (src.Type) {
		case ModuleFileType::CompiledModule:
			src.container = std::make_shared<FileSystem::MoonGlareContainer::Reader>(src.FileName);
			break;
		case ModuleFileType::RawModule:
			src.container = std::make_shared<FileSystem::FolderContainer>(src.FileName);
			break;

		case ModuleFileType::None:
		case ModuleFileType::Unknown:
		default:
			throw std::runtime_error("Unknown input type!");
		}
		if (!src.container->IsReady()) {
			throw "Unable to open source!";
		}
		src.RW = RWMode::R;
	}
	
	void StagePostProcess(WorkConfiguration &data) {
		if (Verbosity::PrintStep())
			cout << data->StageCounter()  << "Finalizing input container\n";
		data.input.container.reset();
	}

	void ProcessStage(WorkConfiguration &data) {
		if (Verbosity::PrintStep())
			cout << data->StageCounter()  << "Scanning input container\n";
	
		//std::stac
		std::queue<std::pair<string, const FileSystem::RawFilePointer*>> FolderQueue;
		FolderQueue.push(std::make_pair(string("/"), nullptr));
		unsigned fcounter = 0;
		unsigned dcounter = 0;
		while (!FolderQueue.empty()) {
			auto pdir = FolderQueue.front();
			FolderQueue.pop();

			data.input.container->EnumerateFolder(pdir.second, [&](const string&fn, FileSystem::FileType type, const FileSystem::RawFilePointer* ptr) {
				string path = pdir.first + fn;

				switch (type) {
				case FileSystem::FileType::File: {
					++fcounter;
					FileInfo fi;
					fi.Source = FileSource::Container;
					fi.Name = fn;
					fi.SrcContainer = data.input.container;
					fi.FileSystemPath = "";
					fi.VirtualPath = pdir.first;
					if (fi.VirtualPath.back() == '/' && fi.VirtualPath.length() > 1)
						fi.VirtualPath.pop_back();
					data.FileList.emplace_back(fi);
					break;
				}
				case FileSystem::FileType::Directory:
					path += "/";
					FolderQueue.push(std::make_pair(path, ptr));
					dcounter++;
					return;
				default:
					throw "Unknown container file type!";
				}
			});
		}
	
		if (Verbosity::PrintInfo()) {
			cout << data.StageCounter() << fcounter << " files found\n";
			cout << data.StageCounter() << dcounter << " directories found\n";
		}

		auto fs = shared<InputStageImpl>();
		data.pipeline->QueueLastAction([fs](WorkConfiguration &data) { fs->StagePostProcess(data); });
	}

};

//---------------------------------------------------------------------------------------

void InputStage::Queue(Pipeline &p) {
	auto fs = Init<InputStageImpl>(p);
	p.QueueFirstAction([fs](WorkConfiguration &data) { fs->OpenSource(data); });
	p.QueueAction([fs](WorkConfiguration &data) { fs->ValidateStage(data); });
}

} // namespace pipeline 
} // namespace modc
