/*
  * Generated by cppsrc.sh
  * On 2016-09-24  9:36:39,23
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef CustomType_H
#define CustomType_H

#include "Structure.h"

Q_DECLARE_METATYPE(MoonGlare::TypeEditor::StructureValue*)

namespace MoonGlare {
namespace TypeEditor {

class CustomTypeEditor {
public:
	virtual ~CustomTypeEditor() {}
	virtual void SetValue(const std::string &in) = 0;
	virtual std::string GetValue() = 0;
	virtual QWidget *GetWidget() { return dynamic_cast<QWidget*>(this); }
};

class TypeEditorInfo {
public:
	virtual ~TypeEditorInfo() {}
	virtual CustomTypeEditor* CreateEditor(QWidget *Parent) const = 0;
	virtual std::string ToDisplayText(const std::string &in) const = 0;

	static void RegisterTypeEditor(std::shared_ptr<const TypeEditorInfo> typeinfo, const std::string &Name);
	static std::shared_ptr<const TypeEditorInfo> GetEditor(const std::string &Name);
};

template<class EDITOR>
struct TemplateTypeEditorInfo : public TypeEditorInfo {
	virtual CustomTypeEditor* CreateEditor(QWidget *Parent) const override {
		return new EDITOR(Parent);
	};
	virtual std::string ToDisplayText(const std::string &in) const override {
		return EDITOR::ToDisplayText(in);
	}
};

struct CustomEditorItemDelegate : public QStyledItemDelegate {
	struct QtRoles {
		enum {
			StructureValue = Qt::UserRole + 1000,
		};
	};

	CustomEditorItemDelegate(QWidget *parent = 0) : QStyledItemDelegate(parent) {}
	virtual QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const override {
		auto vinfo = index.data(QtRoles::StructureValue).value<StructureValue*>();
		if (vinfo) {
			auto einfoit = TypeEditor::TypeEditorInfo::GetEditor(vinfo->GetTypeName());
			if (einfoit) {
				return einfoit->CreateEditor(parent)->GetWidget();
			}
		}
		return QStyledItemDelegate::createEditor(parent, option, index);
	};
	virtual void setEditorData(QWidget *editor, const QModelIndex &index) const override {
		auto vinfo = index.data(QtRoles::StructureValue).value<StructureValue*>();
		auto *cte = dynamic_cast<TypeEditor::CustomTypeEditor*>(editor);
		if (vinfo && cte) {
			cte->SetValue(vinfo->GetValue());
		}
		return QStyledItemDelegate::setEditorData(editor, index);
	};
	virtual void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const override {
		auto vinfo = index.data(QtRoles::StructureValue).value<StructureValue*>();
		auto *cte = dynamic_cast<TypeEditor::CustomTypeEditor*>(editor);
		if (vinfo) {
			if (cte) {
				vinfo->SetValue(cte->GetValue());
			} else {
				vinfo->SetValue(index.data(Qt::DisplayRole).toString().toLocal8Bit().constData());
			}
		}
		return QStyledItemDelegate::setModelData(editor, model, index);
	};
};

#ifdef _X2C_IMPLEMENTATION_
template<typename ENUM>
class EnumTemplate : public CustomTypeEditor, public QComboBox {
public:
	EnumTemplate(QWidget *Parent) : QComboBox(Parent) {
		if (ENUM::GetValues(m_Values)) {
			for (auto &it : m_Values) {
				addItem(it.first.c_str(), it.second);
			}
			setInsertPolicy(QComboBox::NoInsert);
			model()->sort(0);
		} else {
			setEditable(true);
			setInsertPolicy(QComboBox::InsertAtTop);
		}
	}

	static std::string ToDisplayText(const std::string &in) {
		decltype(m_Values) Values;
		if (ENUM::GetValues(Values)) {
			for (auto &it : Values) {
				if (std::to_string(it.second) == in) {
					return it.first;
				}
			}
		}
		return in;
	}

	virtual void SetValue(const std::string &in) {
		for (auto &it : m_Values) {
			if (std::to_string(it.second) == in) {
				setCurrentText(it.first.c_str());
				return;
			}
		}
		setCurrentText(in.c_str());
	}
	virtual std::string GetValue() {
		auto cdata = currentData();
		if (!cdata.isValid()) {
			return currentText().toLocal8Bit().constData();
		}
		bool succ;
		auto value = cdata.toULongLong(&succ);
		if (succ) {
			return std::to_string(value);
		}
		return currentText().toLocal8Bit().constData();
	}
private:
	std::unordered_map<std::string, uint64_t> m_Values;
};
#endif

} //namespace TypeEditor 
} //namespace MoonGlare 

#endif
