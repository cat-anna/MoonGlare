/*
 * Generated by cppsrc.sh
 * On 2016-10-09 20:20:47,90
 * by Paweu
 */
/*--END OF HEADER BLOCK--*/

#include PCH_HEADER
#include "iCustomEnum.h"

#include <boost/algorithm/string/case_conv.hpp>

namespace MoonGlare {
namespace QtShared {

ModuleClassRegister::Register<CustomEnumProvider> CustomEnumProviderReg("CustomEnumProvider");

CustomEnumProvider::CustomEnumProvider(SharedModuleManager modmgr) : iModule(std::move(modmgr)) {}

bool CustomEnumProvider::PostInit() {
    for (auto module : GetModuleManager()->QueryInterfaces<iCustomEnumSupplier>()) {
        for (auto e : module.m_Interface->GetCustomEnums(this)) {
            RegisterEnum(e);
            AddLogf(Info, "Got CustomEnum provider: %s", e->GetEnumTypeName().c_str());
        }
    }
    return true;
}

void CustomEnumProvider::SetAlias(const std::string &Typename, std::shared_ptr<iCustomEnum> e) {
    RegisterEnum(std::make_shared<AliasEnum>(std::move(Typename), std::move(e)));
}

void CustomEnumProvider::RegisterEnum(std::shared_ptr<iCustomEnum> e) {
    auto name = e->GetEnumTypeName();
    boost::to_lower(name);
    auto it = enumMap.find(name);
    if (it == enumMap.end())
        enumMap[name] = e;
    else {
        if (it->second.get() == e.get())
            return;

        // TODO: some error
        __debugbreak();
    }
}

const std::shared_ptr<iCustomEnum> CustomEnumProvider::GetEnum(const std::string &Typename) const {
    auto it = enumMap.find(boost::to_lower_copy(Typename));
    if (it == enumMap.end())
        return nullptr;
    return it->second;
}

} // namespace QtShared
} // namespace MoonGlare
