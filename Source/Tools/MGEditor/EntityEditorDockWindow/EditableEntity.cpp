/*
  * Generated by cppsrc.sh
  * On 2016-09-10 16:34:37,71
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include PCH_HEADER

#include "EditableEntity.h"
#include <Windows/MainWindow.h>
#include <FileSystem.h>

#include <TypeEditor/Structure.h>

namespace MoonGlare {
namespace Editor {
namespace EntityEditor {

using Core::Component::ComponentID;
using Core::Component::ComponentID;

//----------------------------------------------------------------------------------

EditableEntity::EditableEntity(EditableEntity *Parent)
	: m_Parent(Parent) {
}

EditableEntity::~EditableEntity() {
}

bool EditableEntity::Read(pugi::xml_node node) {
	m_Name = node.attribute("Name").as_string("");
	m_PatternURI = node.attribute("Pattern").as_string("");

	for (auto it = node.first_child(); it; it = it.next_sibling()) {
		const char *nodename = it.name();
		auto hash = Space::Utils::MakeHash32(nodename);

		switch (hash) {

		case "Component"_Hash32:
		{
			auto child = EditableComponent::CreateComponent(this, it);
			if (!child) {
				//TODO: log sth
				continue;
			}
			m_Components.emplace_back(std::move(child));
			break;
		}

		//case "Entity"_Hash32:
		//{
			//auto pattern = it.attribute("Pattern").as_string(nullptr);
			//if (pattern) {
			//	FileSystem::XMLFile xdoc;
			//	Entity child;
			//	std::string paturi = pattern;
			//	if (!GetFileSystem()->OpenXML(xdoc, paturi, DataPath::URI)) {
			//		AddLogf(Error, "Failed to open pattern: %s", pattern);
			//		continue;
			//	}
			//
			//	auto c = BuildChild(Owner, xdoc->document_element(), child);
			//	if (c == 0) {
			//		AddLogf(Error, "Failed to load child!");
			//		continue;
			//	}
			//	count += c;
			//	continue;
			//}
		//}
		//no break;
		//[[fallthrough]]
		case "Entity"_Hash32:
		case "Child"_Hash32:
		{
			UniqueEditableEntity child (new EditableChild(this));
			if (!child->Read(it)) {
				//TODO: log sth
				continue;
			}
			m_Children.emplace_back(std::move(child));
		}
		continue;
		default:
			AddLogf(Warning, "Unknown node: %s", nodename);
			continue;
		}
	}

	return true;
}

bool EditableEntity::Write(pugi::xml_node node) {
	auto selfnode = node.append_child("Entity");
	selfnode.append_attribute("Name") = m_Name.c_str();

	if(!m_PatternURI.empty())
		selfnode.append_attribute("Pattern") = m_PatternURI.c_str();

	bool ret = true;
	for (auto &it : m_Components) {
		auto cnode = selfnode.append_child("Component");
		cnode.append_attribute("Name") = it->GetName().c_str();
		ret = ret && it->Write(cnode);
	}
	for (auto &it : m_Children) {
		ret = ret && it->Write(selfnode);
	}
	return ret;
}

void EditableEntity::MoveDown(EditableComponent *c) {
	auto idx = Find(c);
	if (idx < 0)
		return;
	if (idx + 1 >= m_Components.size())
		return;
	m_Components[idx].swap(m_Components[idx + 1]);
}

void EditableEntity::MoveUp(EditableComponent *c) {
	auto idx = Find(c);
	if (idx <= 0)
		return;
	m_Components[idx].swap(m_Components[idx - 1]);
}

void EditableEntity::MoveDown(EditableEntity * c) {
	auto idx = Find(c);
	if (idx < 0)
		return;
	if (idx + 1 >= m_Children.size())
		return;
	m_Children[idx].swap(m_Children[idx + 1]);
}

void EditableEntity::MoveUp(EditableEntity * c) {
	auto idx = Find(c);
	if (idx <= 0)
		return;
	m_Children[idx].swap(m_Children[idx - 1]);
}

EditableEntity *EditableEntity::AddChild() {
	UniqueEditableEntity child(new EditableChild(this));
	child->GetName() = "child";
	auto rawptr = child.get();
	m_Children.emplace_back(std::move(child));
	return rawptr;
}

void EditableEntity::DeleteChild(EditableEntity * c) {
	auto idx = Find(c);
	if (idx < 0)
		return;

	m_Children[idx].reset();
	for (; idx < (int)m_Children.size()-1; ++idx)
		m_Children[idx].swap(m_Children[idx + 1]);;

	m_Children.pop_back();
}

EditableComponent* EditableEntity::AddComponent(Core::ComponentID cid) {
	auto child = EditableComponent::CreateComponent(this, cid);
	if (!child) {
		//TODO: log sth
		return nullptr;
	}
	auto rawptr = child.get();
	m_Components.emplace_back(std::move(child));
	return rawptr;
}

void EditableEntity::DeleteComponent(EditableComponent * c) {
	auto idx = Find(c);
	if (idx < 0)
		return;

	m_Components[idx].reset();
	for (; idx < (int)m_Components.size() - 1; ++idx)
		m_Components[idx].swap(m_Components[idx + 1]);;
	m_Components.pop_back();
}

//----------------------------------------------------------------------------------

EditablePattern::EditablePattern()
	: EditableEntity(nullptr) {
}

bool EditablePattern::OpenPattern(const std::string &filename) {
	pugi::xml_document xdoc;

	auto fs = MainWindow::Get()->GetFilesystem();
	StarVFS::ByteTable bt;
	if (!fs->GetFileData(filename, bt)) {
		//todo: log sth
		return false;
	}
	if (bt.byte_size() == 0) {
		GetName() = "Empty";
		return true;
	}

	if (!xdoc.load_string((char*)bt.get())) {
		//TODO: log sth
		return false;
	}

	return Read(xdoc.document_element());
}

bool EditablePattern::SavePattern(const std::string & filename) {
	pugi::xml_document xdoc;

	if (!Write(xdoc)) {
		//TODO: log sth
		return false;
	}

	std::stringstream ss;
	xdoc.save(ss);
	StarVFS::ByteTable bt;
	bt.from_string(ss.str());

	auto fs = MainWindow::Get()->GetFilesystem();
	if (!fs->SetFileData(filename, bt)) {
		//todo: log sth
		return false;
	}

	return true;
}

//----------------------------------------------------------------------------------

UniqueEditableComponent EditableComponent::CreateComponent(EditableEntity *Parent, pugi::xml_node node) {
	MoonGlare::Core::ComponentID cid = (ComponentID)ComponentID::Invalid;

	auto idxml = node.attribute("Id");
	if (idxml) {
		cid = idxml.as_uint(0);
	} else {
		auto namexml = node.attribute("Name");
		if (!namexml) {
			AddLogf(Error, "Component definition without id or name!");
			return nullptr;
		}
		auto ci = TypeEditor::ComponentInfo::GetComponentInfo(namexml.as_string(""));
		if (ci)
			cid = ci->m_CID;
		if (cid == (ComponentID)ComponentID::Invalid) {
			AddLogf(Error, "Unknown component name: %s", namexml.as_string(""));
		}
	}

	if (cid == (ComponentID)ComponentID::Invalid)
		return nullptr;

	auto ret = CreateComponent(Parent, cid);
	if (!ret) {
		//already logged
		return nullptr;
	}

	if (!ret->Read(node)) {
		//TODO: log sth
		return nullptr;
	}

	return std::move(ret);
}

UniqueEditableComponent EditableComponent::CreateComponent(EditableEntity *Parent, MoonGlare::Core::ComponentID cid) {
	auto ci = TypeEditor::ComponentInfo::GetComponentInfo(cid);
	if (!ci) {
		AddLogf(Error, "Unknown component id: %d", (int)cid);
		return nullptr;
	}

	auto x2cs = ci->m_EntryStructure->m_CreateFunc(nullptr, nullptr);
	return std::make_unique<EditableComponent>(Parent, ci, std::move(x2cs));
}

} //namespace EntityEditor 
} //namespace Editor 
} //namespace MoonGlare 
