/*
  * Generated by cppsrc.sh
  * On 2016-09-10 16:34:37,71
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef EditableEntity_H
#define EditableEntity_H

#include <Source/Engine/Core/Component/nfComponent.h>

namespace MoonGlare {
namespace Editor {
namespace EntityEditor {

class EditableEntity;
using UniqueEditableEntity = std::unique_ptr<EditableEntity>;
class EditableComponent;
using UniqueEditableComponent = std::unique_ptr<EditableComponent>;

using EditableComponentList = std::vector<UniqueEditableComponent>;
using EditableEntityList = std::vector<UniqueEditableEntity>;

class EditableEntity {
public:
 	EditableEntity(EditableEntity *Parent);
 	virtual ~EditableEntity();

	virtual bool Read(pugi::xml_node node);
	virtual bool Write(pugi::xml_node node);

	std::string& GetName() { return m_Name; }
	EditableEntityList& GetChildrenList() { return m_Children; }
	EditableComponentList& GetComponentList() { return m_Components; }

	EditableEntity* GetParent() const { return m_Parent; }

	void MoveUp(EditableComponent *c);
	void MoveDown(EditableComponent *c);
	void MoveUp(EditableEntity *c);
	void MoveDown(EditableEntity *c);

	int Find(EditableComponent *c) {
		for (int i = 0; i < (int)m_Components.size(); ++i)
			if (m_Components[i].get() == c)
				return i;
		return -1;
	}
	int Find(EditableEntity *c) {
		for (int i = 0; i < (int)m_Children.size(); ++i)
			if (m_Children[i].get() == c)
				return i;
		return -1;
	}

	EditableEntity* AddChild();
	void DeleteChild(EditableEntity *c);
	EditableComponent* AddComponent(Core::ComponentID cid);
	void DeleteComponent(EditableComponent *c);
protected:
	EditableEntity *m_Parent;
	std::string m_Name;
	EditableEntityList m_Children;
	EditableComponentList m_Components;
};

class EditablePattern 
	: public EditableEntity {
public:
	EditablePattern();

	bool OpenPattern(const std::string &filename);
	bool SavePattern(const std::string &filename);
};

class EditableChild
	: public EditableEntity {
public:
	EditableChild(EditableEntity *Parent);

protected:

};

//----------------------------------------------------------------------------------

struct ComponentInfo {
	MoonGlare::Core::ComponentID m_CID;
	UniqueEditableComponent (*m_CreteFunc)(EditableEntity *Parent, const ComponentInfo *cInfo);
	std::string m_Name;
};
extern const std::unordered_map<MoonGlare::Core::ComponentID, ComponentInfo> ComponentInfoMap;

class EditableComponentValue {
public:
	virtual ~EditableComponentValue() { }

	virtual const std::string& GetName() = 0;
	virtual std::string GetValue() = 0;
	virtual void SetValue(const std::string& v) = 0;
	virtual const std::string& GetDescription() = 0;
};

using UniqueEditableComponentValue = std::unique_ptr<EditableComponentValue>;
using EditableComponentValueList = std::vector<UniqueEditableComponentValue>;

class EditableComponent {
public:
	EditableComponent(EditableEntity *Parent, const ComponentInfo *cInfo);
	virtual ~EditableComponent();

	virtual EditableComponentValueList& GetValues() = 0;
	virtual bool Read(pugi::xml_node node) = 0;
	virtual bool Write(pugi::xml_node node) = 0;

	virtual const std::string& GetName() = 0;

	static UniqueEditableComponent CreateComponent(EditableEntity *Parent, pugi::xml_node node);
	static UniqueEditableComponent CreateComponent(EditableEntity *Parent, MoonGlare::Core::ComponentID cid);
protected:
	EditableEntity *m_Parent;
	const ComponentInfo *m_ComponentInfo;
};

#ifdef _X2C_IMPLEMENTATION_
template<typename X2CLASS>
class X2CEditableStructure : public EditableComponent {
public:
	struct EditableValue : public EditableComponentValue {
		virtual const std::string& GetName() { return m_Name; }
		virtual std::string GetValue() {
			std::string v;
			m_Read(v);
			return std::move(v);
		}
		virtual void SetValue(const std::string& v) {
			m_Write(v);
		}
		virtual const std::string& GetDescription() { return m_Description; }

		std::function<void(std::string &output)> m_Read;
		std::function<void(const std::string &input)> m_Write;
		std::string m_Name;
		std::string m_Description;
	};

	X2CEditableStructure(EditableEntity *Parent, const ComponentInfo *cInfo):
			EditableComponent(Parent, cInfo) {
		m_Value.ResetToDefault();

		::x2c::cxxpugi::StructureMemberInfoTable members;
		std::unordered_map<std::string, std::function<void(X2CLASS &self, const std::string &input)>> WriteFuncs;
		std::unordered_map<std::string, std::function<void(const X2CLASS &self, std::string &output)>> ReadFuncs;

		m_Value.GetMemberInfo(members);
		m_Value.GetWriteFuncs(WriteFuncs);
		m_Value.GetReadFuncs(ReadFuncs);
		m_Values.reserve(members.size());
		for (auto &member : members) {
			auto ptr = std::make_unique<EditableValue>();
			ptr->m_Name = member.m_Name;
			ptr->m_Description = member.m_Description;

			auto read = ReadFuncs[member.m_Name];
			auto write = WriteFuncs[member.m_Name];

			X2CLASS &value = m_Value;
			ptr->m_Read = [&value, read](std::string &out) {
				read(value, out);
			};
			ptr->m_Write = [&value, write](const std::string &out) {
				write(value, out);
			};
			m_Values.emplace_back(UniqueEditableComponentValue(ptr.release()));
		}
	}
	~X2CEditableStructure() {
	}

	virtual EditableComponentValueList& GetValues() { return m_Values; }
	virtual bool Read(pugi::xml_node node) {
		return m_Value.Read(node);
	}
	virtual bool Write(pugi::xml_node node) {
		auto selfnode = node.append_child("Component");
		selfnode.append_attribute("Name") = m_ComponentInfo->m_Name.c_str();
		return m_Value.Write(selfnode);
	}
	virtual const std::string& GetName() {
		return m_ComponentInfo->m_Name;
	}
private:
	EditableComponentValueList m_Values;
	X2CLASS m_Value;
};
#endif

} //namespace EntityEditor 
} //namespace Editor 
} //namespace MoonGlare 

#endif
