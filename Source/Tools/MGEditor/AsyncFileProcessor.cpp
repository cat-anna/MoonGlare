/*
  * Generated by cppsrc.sh
  * On 2016-10-09 21:37:20,45
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include PCH_HEADER
#include "AsyncFileProcessor.h"

namespace MoonGlare {
namespace Editor {

//----------------------------------------------------------------------------------

AsyncFileProcessor::AsyncFileProcessor() {
	m_ThreadCanWork = true;
	m_QueueEmpty.notify_one();
	m_Thread = std::thread([this]() { ThreadEntry(); });

	connect(this, &AsyncFileProcessor::FileProcessingFinished, this, &AsyncFileProcessor::JobFinished, Qt::QueuedConnection);
}

AsyncFileProcessor::~AsyncFileProcessor() {
	m_ThreadCanWork = false;
	m_Thread.join();
}

void AsyncFileProcessor::JobFinished(QtShared::SharedFileProcessor p) {
	p->HandlePostProcess();
}

void AsyncFileProcessor::FileProcessorCreated(QtShared::SharedFileProcessor p) {
	LOCK_MUTEX(m_Mutex);
	m_Queue.emplace_back(std::move(p));
	//AddLogf(Info, "Queued job, count: %u", m_Queue.size());
	m_QueueEmpty.notify_one();
}

void AsyncFileProcessor::ThreadEntry() {
	OrbitLogger::ThreadInfo::SetName("AFPT");
	size_t jobcount = 0;
	while (m_ThreadCanWork) {
		QtShared::SharedFileProcessor processor;
		{
			LOCK_MUTEX(m_Mutex);
			if (!m_Queue.empty()) {
				processor = m_Queue.front();
				m_Queue.pop_front();
			}
		}

		if (processor) {
			++jobcount;
			AddLogf(Info, "Fetched job #%u", jobcount);
			auto result = processor->ProcessFile();
			AddLogf(Info, "Job #%u result: %u", jobcount, static_cast<unsigned>(result));

			if (result == QtShared::iFileProcessor::ProcessResult::RetryLater) {
				LOCK_MUTEX(m_Mutex);
				m_Queue.emplace_back(processor);
			} else {
				emit FileProcessingFinished(processor);
			}
			continue;
		}

		std::mutex m;
		std::unique_lock<std::mutex> lk(m);
		m_QueueEmpty.wait_for(lk, std::chrono::seconds(1));
	}
}

} //namespace Editor 
} //namespace MoonGlare 

