/*
  * Generated by cppsrc.sh
  * On 2016-10-13 18:53:51,09
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include PCH_HEADER

#include <icons.h>
#include <iFileProcessor.h>
#include <iFileIconProvider.h>
#include <iCustomEnum.h>
#include <Module.h>
#include <iIssueReporter.h>

#include <libs/LuaWrap/src/LuaDeleter.h>
#include <libs/LuaWrap/src/LuaException.h>

#include "../Windows/MainWindow.h"
#include "../FileSystem.h"
#include "ScriptProcessor.h"

namespace MoonGlare {
namespace Editor {
namespace Processor {
                                  
//----------------------------------------------------------------------------------

struct ScriptFileProcessorInfo
    : public QtShared::iModule
    , public QtShared::iFileProcessorInfo
    , public QtShared::iCustomEnumSupplier
    , public QtShared::iFileIconInfo {

    ScriptFileProcessorInfo(SharedModuleManager modmgr) : iModule(std::move(modmgr)) {}

    std::shared_ptr<QtShared::SetEnum>  scriptListEnum = std::make_shared<QtShared::SetEnum>("string:Script.Script");

    QtShared::SharedFileProcessor CreateFileProcessor(std::string URI) override {
        return std::make_shared<ScriptFileProcessor>(this, std::move(URI));
    }

    std::vector<std::string> GetSupportedTypes() {
        return{ "lua", };
    }

    std::vector<std::shared_ptr<QtShared::iCustomEnum>> GetCustomEnums() const override  {
        return { scriptListEnum, };
    }

    std::vector<FileIconInfo> GetFileIconInfo() const override {
        return{ FileIconInfo{ "lua", ICON_16_LUALOGO_RESOURCE, }, };
    }
};
QtShared::ModuleClassRgister::Register<ScriptFileProcessorInfo> ScriptFileProcessorInfoReg("ScriptFileProcessorInfo");

//----------------------------------------------------------------------------------

static const char InternalScript[] = R"===(

Script = { 
    Table = { },
}
    
function Script:New(Name) 
    local s = { }
    self.Table[Name] = s
    return s
end

local Script_mt = { __index = Script, }
setmetatable(Script, Script_mt)

oo = { }        

function oo.Inherit(base)
    local class = { }

    class.__index = class
    class.BaseClass = base

    setmetatable(class, base)

    return class
end

function oo.Class()
    return oo.Inherit()
end

function require()
    return {}
end

)===";

//----------------------------------------------------------------------------------

ScriptFileProcessor::ScriptFileProcessor(ScriptFileProcessorInfo *Module, std::string URI)
        : QtShared::iFileProcessor(std::move(URI)), module(Module) {
}

std::string ScriptFileProcessor::MakeIssueId() {
    return "ScriptFileProcessor|" + m_URI + "|CompilationError";
}

ScriptFileProcessor::ProcessResult ScriptFileProcessor::ProcessFile()  {
    try {
        InitLua();
        ExecuteScript();
        ProcessOutput();
        Finalize();
    }
    catch (...) {
        return ProcessResult::UnknownFailure;
    }
    return ProcessResult::Success;
}

void ScriptFileProcessor::InitLua() {
    m_Lua.reset(luaL_newstate());
    auto lua = m_Lua.get();
    luaopen_base(lua);
    luaopen_math(lua);
    luaopen_bit(lua);
    luaopen_string(lua);
    luaopen_table(lua);
#ifdef DEBUG
    luaopen_debug(lua);
#endif
    lua_atpanic(lua, &LuaWrap::eLuaPanic::ThrowPanicHandler);

    int result = luaL_loadstring(lua, InternalScript);
    switch (result) {
    case 0:
        if (lua_pcall(lua, 0, 0, 0) == 0)
            return;
        AddLog(Error, "Lua error: " << lua_tostring(lua, -1));
        break;
    case LUA_ERRSYNTAX:
        AddLogf(Error, "Unable to load internal script: Error string: '%s'", lua_tostring(lua, -1));
        break;
    case LUA_ERRMEM:
        AddLog(Error, "Unable to load script: Memory allocation failed!");
        break;
    }

    throw std::runtime_error("Unable to Execute internal lua processor script!");
}

void ScriptFileProcessor::ReportIssue(MoonGlare::QtShared::Issue issue) {
    auto reporter = module->GetModuleManager()->QuerryModule<QtShared::IssueReporter>();
    issue.internalID = MakeIssueId();
    reporter->ReportIssue(std::move(issue));  
}

void ScriptFileProcessor::ExecuteScript() {
    auto fs = module->GetModuleManager()->QuerryModule<FileSystem>();
    StarVFS::ByteTable bt;
    if (!fs->GetFileData(m_URI, bt)) {
        //todo: log sth
        throw std::runtime_error("Unable to read file: " + m_URI);
    }
    if (bt.byte_size() == 0) {
        //todo: log sth
    }

    //script exists, so insert it into custom enum set
    {
        std::regex pieces_regex(R"(file\:\/\/(\/[a-z0-9\.\/]+)\.lua)", std::regex::icase);
        std::smatch pieces_match;
        if (std::regex_match(m_URI, pieces_match, pieces_regex)) {
            module->scriptListEnum->Add(pieces_match[1]);
        }
    }

    auto ParseError = [this](const std::string &errorstr, QtShared::Issue::Type type) {
        std::regex pieces_regex(R"==(\[(.+)\]\:(\d+)\:\ (.+))==", std::regex::icase);
        std::smatch pieces_match;
        if (std::regex_match(errorstr, pieces_match, pieces_regex)) {
            QtShared::Issue issue;
            issue.fileName = m_URI;
            issue.sourceLine = std::strtol(pieces_match[2].str().c_str(), nullptr, 10);
            issue.message = pieces_match[3];
            issue.type = type;
            issue.group = "Lua";
       
            ReportIssue(std::move(issue));
        }
    };

    auto lua = m_Lua.get();
    int result = luaL_loadstring(lua, bt.c_str());
    switch (result) {
    case 0: {
       //only syntax check is working correctly
       // if (lua_pcall(lua, 0, 0, 0) == 0)
       //     return;
       // std::string errorstr = lua_tostring(lua, -1);
       // ParseError(errorstr, QtShared::Issue::Type::Warning);
       // AddLogf(Hint, "Lua script '%s' error: %s", m_URI.c_str(), errorstr.c_str());
        auto reporter = module->GetModuleManager()->QuerryModule<QtShared::IssueReporter>();
        reporter->DeleteIssue(MakeIssueId());
        break;
    }
    case LUA_ERRSYNTAX: {
        std::string errorstr = lua_tostring(lua, -1);
        ParseError(errorstr, QtShared::Issue::Type::Error);
        AddLogf(Hint, "Unable to load '%s': Error string: '%s'", m_URI.c_str(), errorstr.c_str());
        break;     
    }
    case LUA_ERRMEM:
        AddLogf(Error, "Unable to load '%s': Memory allocation failed!", m_URI.c_str());
        break;
    }

    throw std::runtime_error("Unable to load script: " + m_URI);
}

void ScriptFileProcessor::ProcessOutput() {
    auto lua = m_Lua.get();
    lua_getfield(lua, LUA_GLOBALSINDEX, "Script");
    lua_getfield(lua, -1, "Table");
    int tbidx = lua_gettop(lua);
    lua_pushnil(lua);							

    while (lua_next(lua, tbidx) != 0) {
        const char *name = lua_tostring(lua, -2);

        AddLogf(Error, "Script: %s", name);
    }

    lua_pop(lua, 2);
}

void ScriptFileProcessor::Finalize() {
    m_Lua.reset();
}
                    
} //namespace Processor 
} //namespace Editor 
} //namespace MoonGlare 
