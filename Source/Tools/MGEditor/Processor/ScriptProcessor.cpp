/*
  * Generated by cppsrc.sh
  * On 2016-10-13 18:53:51,09
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include PCH_HEADER

#include <icons.h>
#include <iFileProcessor.h>
#include <iFileIconProvider.h>

#include <libs/LuaWrap/src/LuaDeleter.h>
#include <libs/LuaWrap/src/LuaException.h>

#include "../Windows/MainWindow.h"
#include "../FileSystem.h"
#include "ScriptProcessor.h"

namespace MoonGlare {
namespace Editor {
namespace Processor {

struct ScriptFileProcessorInfo
	: public QtShared::iFileProcessorInfo
	, public QtShared::iFileIconProvider 
{
	virtual QtShared::SharedFileProcessor CreateFileProcessor(std::string URI) override {
		return std::make_shared<ScriptFileProcessor>(std::move(URI));
	}

	virtual std::vector<std::string> GetSupportedTypes() { return{ "lua", }; }
	virtual std::vector<FileIconInfo> GetFileIconInfo() { return{ FileIconInfo{ "lua", ICON_16_LUALOGO_RESOURCE, }, }; }
};
static QtShared::FileProcessorInfoClassRegister::Register<ScriptFileProcessorInfo> Reg0("ScriptFileProcessor");
static QtShared::FileIconProviderClassRegister::Register<ScriptFileProcessorInfo> Reg1("ScriptFileProcessor");

//----------------------------------------------------------------------------------

static const char InternalScript[] = R"(

global = { }
static = { }

Script = { 
	Table = { },
}
	
function Script:New(Name) 
	local s = { }
	self.Table[Name] = s
	return s
end

local Script_mt = { __index = Script, }
setmetatable(Script, Script_mt)

)";

//----------------------------------------------------------------------------------

ScriptFileProcessor::ScriptFileProcessor(std::string URI) 
		: QtShared::iFileProcessor(std::move(URI)) {
}

ScriptFileProcessor::ProcessResult ScriptFileProcessor::ProcessFile()  {
	try {
		InitLua();
		ExecuteScript();
		ProcessOutput();
		Finalize();
	}
	catch (...) {
		return ProcessResult::UnknownFailure;
	}
	return ProcessResult::Success;
}

void ScriptFileProcessor::InitLua() {
	m_Lua.reset(luaL_newstate());
	auto lua = m_Lua.get();
	luaopen_base(lua);
	luaopen_math(lua);
	luaopen_bit(lua);
	luaopen_string(lua);
	luaopen_table(lua);
#ifdef DEBUG
	luaopen_debug(lua);
#endif
	lua_atpanic(lua, &LuaWrap::eLuaPanic::ThrowPanicHandler);

	int result = luaL_loadstring(lua, InternalScript);
	switch (result) {
	case 0:
		if (lua_pcall(lua, 0, 0, 0) == 0)
			return;
		AddLog(Error, "Lua error: " << lua_tostring(lua, -1));
		break;
	case LUA_ERRSYNTAX:
		AddLogf(Error, "Unable to load internal script: Error string: '%s'", lua_tostring(lua, -1));
		break;
	case LUA_ERRMEM:
		AddLog(Error, "Unable to load script: Memory allocation failed!");
		break;
	}

	throw std::runtime_error("Unable to Execute internal lua processor script!");
}

void ScriptFileProcessor::ExecuteScript() {
	auto fs = MainWindow::Get()->GetFilesystem();
	StarVFS::ByteTable bt;
	if (!fs->GetFileData(m_URI, bt)) {
		//todo: log sth
		throw std::runtime_error("Unable to read file: " + m_URI);
	}
	if (bt.byte_size() == 0) {
		//todo: log sth
	}

	auto lua = m_Lua.get();
	int result = luaL_loadstring(lua, bt.c_str());
	switch (result) {
	case 0:
		if (lua_pcall(lua, 0, 0, 0) == 0)
			return;
		AddLogf(Error, "Lua script '%s' error: %s", m_URI.c_str(), lua_tostring(lua, -1));
		break;
	case LUA_ERRSYNTAX:
		AddLogf(Error, "Unable to load '%s': Error string: '%s'", m_URI.c_str(), lua_tostring(lua, -1));
		break;
	case LUA_ERRMEM:
		AddLogf(Error, "Unable to load '%s': Memory allocation failed!", m_URI.c_str());
		break;
	}

	throw std::runtime_error("Unable to load script: " + m_URI);
}

void ScriptFileProcessor::ProcessOutput() {
	auto lua = m_Lua.get();
	lua_getfield(lua, LUA_GLOBALSINDEX, "Script");
	lua_getfield(lua, -1, "Table");
	int tbidx = lua_gettop(lua);
	lua_pushnil(lua);							

	while (lua_next(lua, tbidx) != 0) {
		const char *name = lua_tostring(lua, -2);

		AddLogf(Error, "Script: %s", name);
	}

	lua_pop(lua, 2);
}

void ScriptFileProcessor::Finalize() {
	m_Lua.reset();
}

} //namespace Processor 
} //namespace Editor 
} //namespace MoonGlare 
