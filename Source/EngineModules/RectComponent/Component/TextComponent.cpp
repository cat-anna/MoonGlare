/*
  * Generated by cppsrc.sh
  * On 2016-09-23 21:24:39,56
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>
#include <Engine/DataClasses/iFont.h>
#include "../nfGUI.h"

#include <Core/Component/ComponentManager.h>
#include <Core/Component/ComponentRegister.h>
#include "RectTransformComponent.h"
#include "TextComponent.h"

#include <Renderer/Commands/OpenGL/ControllCommands.h>
#include <Renderer/Commands/OpenGL/ShaderCommands.h>
#include <Renderer/Commands/OpenGL/TextureCommands.h>
#include <Renderer/Commands/OpenGL/ArrayCommands.h>
#include <Renderer/RenderInput.h>
#include "../GUIShader.h"

#include <Math.x2c.h>
#include <ComponentCommon.x2c.h>
#include <TextComponent.x2c.h>

#include <Source/Renderer/RenderDevice.h>
#include <Source/Renderer/Frame.h>

#include <Source/Renderer/Resources/ResourceManager.h>

namespace MoonGlare {
namespace GUI {
namespace Component {

//---------------------------------------------------------------------------------------

::Space::RTTI::TypeInfoInitializer<TextComponent, TextComponentEntry> TextComponentTypeInfo;
RegisterComponentID<TextComponent>TextComponentIDReg("Text", true, &TextComponent::RegisterScriptApi);

//---------------------------------------------------------------------------------------

TextComponent::TextComponent(ComponentManager * Owner)
		: TemplateStandardComponent(Owner) {
	m_RectTransform = nullptr;
	m_Shader = nullptr;
	m_RtShader = nullptr;
}

TextComponent::~TextComponent() {
}

//---------------------------------------------------------------------------------------

void TextComponent::RegisterScriptApi(ApiInitializer & root) {
	root
		.beginClass<TextComponentEntry>("cTextComponentEntry")
			.addProperty("Color", &TextComponentEntry::GetColor, &TextComponentEntry::SetColor)
			.addProperty("Text", &TextComponentEntry::GetText, &TextComponentEntry::SetText)
			.addProperty("FontSize", &TextComponentEntry::GetFontSize, &TextComponentEntry::SetFontSize)
		.endClass()
		; 
}

//---------------------------------------------------------------------------------------

bool TextComponent::Initialize() {
	//memset(&m_Array, 0, m_Array.Capacity() * sizeof(m_Array[0]));
	//m_Array.fill(TextComponentEntry());
	for (auto &item : m_Array)
		item.Reset();
	m_Array.ClearAllocation();

	m_RectTransform = GetManager()->GetComponent<RectTransformComponent>();
	if (!m_RectTransform) {
		AddLog(Error, "Failed to get RectTransformComponent instance!");
		return false;
	}

	::Graphic::GetRenderDevice()->RequestContextManip([this]() {
		if (!m_Shader) {
			if (!Graphic::GetShaderMgr()->GetSpecialShaderType<GUIShader>("GUI", m_Shader)) {
				AddLogf(Error, "Failed to load GUI shader");
			}
		}

		if (!m_RtShader) {
			if (!Graphic::GetShaderMgr()->GetSpecialShaderType<GUIShader>("rttest", m_RtShader)) {
				AddLogf(Error, "Failed to load m_RtShader shader");
			}
		}
	});
	
	m_TextProcessor.SetTables(GetDataMgr()->GetStringTables());

	return true;
}

bool TextComponent::Finalize() {
	return true;
}

//---------------------------------------------------------------------------------------

void TextComponent::Step(const Core::MoveConfig & conf) {
	auto &Queue = conf.m_RenderInput->m_CommandQueues[Renderer::RendererConf::CommandQueueID::GUI];
	bool CanRender = false;

	if (m_Shader) {
		CanRender = true;
	}

	size_t LastInvalidEntry = 0;
	size_t InvalidEntryCount = 0;

	for (size_t i = 0; i < m_Array.Allocated(); ++i) {
		auto &entry = m_Array[i];

		if (!entry.m_Flags.m_Map.m_Valid) {
			//mark and continue
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}

		if (!GetHandleTable()->IsValid(this, entry.m_SelfHandle)) {
			entry.m_Flags.m_Map.m_Valid = false;
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}

		auto *rtentry = m_RectTransform->GetEntry(entry.m_OwnerEntity);
		if (!rtentry) {
			LastInvalidEntry = i;
			++InvalidEntryCount;
			continue;
		}

		if (!entry.m_Flags.m_Map.m_Active)
			continue;

		Renderer::RendererConf::CommandKey key{ rtentry->m_Z };

		if (entry.m_Flags.m_Map.m_Dirty || rtentry->m_Flags.m_Map.m_Changed) {
			entry.Update(*rtentry, m_RectTransform->IsUniformMode(), m_TextProcessor);

			if (m_RtShader) {
				auto trt = conf.m_BufferFrame->GetDevice()->AllocateTextureRenderTask();
				if (trt) {
					auto s = emath::MathCast<emath::ivec2>(entry.m_FontInstance->GetSize());

					std::string processed;
					m_TextProcessor.Process(entry.m_Text, processed);
					std::wstring txt = Utils::Strings::towstring(processed);

					auto tsize = entry.m_Font->TextSize(txt, &entry.m_FontStyle, false);

					trt->SetFrame(conf.m_BufferFrame);
					trt->SetTarget(entry.m_TexHandle, emath::MathCast<emath::ivec2>(tsize.m_CanvasSize));

					trt->Begin();

					auto &q = trt->GetCommandQueue();

					m_RtShader->Bind(q, key);
					m_RtShader->SetModelMatrix(q, key, emath::MathCast<emath::fmat4>(glm::translate(glm::mat4(), math::vec3(tsize.m_TextPosition, 0))));// emath::MathCast<emath::fmat4>(entry.m_Matrix));

					Renderer::VirtualCamera Camera;
					Camera.SetDefaultOrthogonal(tsize.m_CanvasSize);

					m_RtShader->SetCameraMatrix(q, key, Camera.GetProjectionMatrix());

			//		m_RtShader->SetColor(q, key, math::vec4(abs(sin(col)), abs(cos(col)), abs(sin(col)*cos(col)), 1)); //math::vec4(entry.m_FontStyle.Color, 1.0f));
					//m_RtShader->SetTileMode(q, key, math::vec2(0, 0));
					entry.m_FontInstance->GenerateCommands(q, rtentry->m_Z);

					trt->End();

					//auto su = entry.m_FontInstance->GetSize();
					auto ScreenSize = math::fvec2(Graphic::GetRenderDevice()->GetContextSize());
					float Aspect = ScreenSize[0] / ScreenSize[1];
					auto su = tsize.m_CanvasSize / math::fvec2(ScreenSize) * math::fvec2(Aspect * 2.0f, 2.0f);

					Graphic::QuadArray3 Vertexes{
						Graphic::vec3(0, su[1], 0),
						Graphic::vec3(su[0], su[1], 0),
						Graphic::vec3(su[0], 0, 0),
						Graphic::vec3(0, 0, 0),
					};
					float w1 = 0.0f;
					float h1 = 0.0f;
					float w2 = 1.0f;
					float h2 = 1.0f;
					Graphic::QuadArray2 TexUV{
						Graphic::vec2(w1, h1),
						Graphic::vec2(w2, h1),
						Graphic::vec2(w2, h2),
						Graphic::vec2(w1, h2),
					};

					{
						auto frame = conf.m_BufferFrame;
						auto &m = frame->GetMemory();
						using ichannels = Renderer::Configuration::VAO::InputChannels;

						auto vaob = conf.m_BufferFrame->GetResourceManager()->GetVAOResource().GetVAOBuilder(q, entry.m_VAORes, true);

						vaob.BeginDataChange();

						vaob.CreateChannel(ichannels::Vertex);
						vaob.SetChannelData<float, 3>(ichannels::Vertex, (const float*)m.Clone(Vertexes), Vertexes.size());
						
						vaob.CreateChannel(ichannels::Texture0);
						vaob.SetChannelData<float, 2>(ichannels::Texture0, (const float*)m.Clone(TexUV), TexUV.size());
						
						//static const float normals[] = { 0 };
						//vaob.CreateChannel(entry.m_VAO.NormalChannel);
						//vaob.SetChannelData<float, 3>(entry.m_VAO.NormalChannel, normals, 0);
						
						vaob.CreateChannel(ichannels::Index);
						static constexpr std::array<uint8_t, 6> IndexTable = { 0, 1, 2, 0, 2, 3, };
						vaob.SetIndex(ichannels::Index, IndexTable);

						vaob.EndDataChange();
						vaob.UnBindVAO();
					}

					conf.m_BufferFrame->Submit(trt);
				}
			}
		}

		if (!entry.m_FontInstance)
			continue;
		if (!CanRender)
			continue;

	//m_Shader->SetWorldMatrix(Queue, key, emath::MathCast<emath::fmat4>(entry.m_Matrix), m_RectTransform->GetCamera().GetProjectionMatrix());
	//m_Shader->SetColor(Queue, key, math::vec4(entry.m_FontStyle.Color, 1.0f));
	//m_Shader->SetTileMode(Queue, key, math::vec2(0, 0));
	//entry.m_FontInstance->GenerateCommands(Queue, rtentry->m_Z);
		
		if (m_RtShader && entry.m_VAORes.m_TmpGuard != 0) {
			m_Shader->SetWorldMatrix(Queue, key, emath::MathCast<emath::fmat4>(entry.m_Matrix), m_RectTransform->GetCamera().GetProjectionMatrix());
			m_Shader->SetColor(Queue, key, math::vec4(entry.m_FontStyle.Color, 1.0f));

			auto texres = Queue.PushCommand<Renderer::Commands::Texture2DResourceBind>(key);
			texres->m_Handle = entry.m_TexHandle;
			texres->m_HandleArray = conf.m_BufferFrame->GetResourceManager()->GetTextureAllocator().GetHandleArrayBase();

			auto vaob = conf.m_BufferFrame->GetResourceManager()->GetVAOResource().GetVAOBuilder(Queue, entry.m_VAORes);
			//vaob.BindVAO();
			Queue.PushCommand<Renderer::Commands::VAOBindResource>(key)->m_VAO = vaob.m_HandlePtr;

			auto arg = Queue.PushCommand<Renderer::Commands::VAODrawTriangles>(key);
			arg->m_NumIndices = 6;
			arg->m_IndexValueType = Renderer::TypeId<uint8_t>;
		}
	}

	if (InvalidEntryCount > 0) {
		AddLogf(Performance, "TransformComponent:%p InvalidEntryCount:%lu LastInvalidEntry:%lu", this, InvalidEntryCount, LastInvalidEntry);
		TrivialReleaseElement(LastInvalidEntry);
	}
}

//---------------------------------------------------------------------------------------

bool TextComponent::Load(xml_node node, Entity Owner, Handle & hout) {
	size_t index;
	if (!m_Array.Allocate(index)) {
		AddLogf(Error, "Failed to allocate index!");
		return false;
	}
	auto &entry = m_Array[index];
	entry.Reset();
	if (!GetHandleTable()->Allocate(this, Owner, entry.m_SelfHandle, index)) {
		AddLog(Error, "Failed to allocate handle");
		//no need to deallocate entry. It will be handled by internal garbage collecting mechanism
		return false;
	}
	hout = entry.m_SelfHandle;
	entry.m_OwnerEntity = Owner;

	x2c::Component::TextComponent::TextEntry_t te;
	te.ResetToDefault();
	if (!te.Read(node)) {
		AddLog(Error, "Failed to read ImageEntry!");
		return false;
	}

	entry.m_Font = GetDataMgr()->GetFont(te.m_FontName);
	if (!entry.m_Font) {
		AddLogf(Error, "Unknown font: %s", te.m_FontName.c_str());
		return false;
	}

	entry.m_AlignMode = te.m_TextAlignMode;
	entry.m_FontStyle.Color = math::vec3(1, 1, 1);
	entry.m_FontStyle.Size = te.m_FontSize;
	entry.m_Text = te.m_Text;
	entry.m_Flags.m_Map.m_Active = te.m_Active;

	entry.m_Flags.m_Map.m_Valid = true;
	entry.m_Flags.m_Map.m_Dirty = true;
	entry.m_Flags.m_Map.m_TextDirty = true;
	m_EntityMapper.SetComponentMapping(entry);
	return true;
}

//---------------------------------------------------------------------------------------

void TextComponentEntry::Update(RectTransformComponentEntry & Parent, bool Uniform, TextProcessor &tproc) {

	if (m_Flags.m_Map.m_TextDirty) {
		std::string processed;
		tproc.Process(m_Text, processed);
		std::wstring txt = Utils::Strings::towstring(processed);

		m_FontInstance = m_Font->GenerateInstance(txt.c_str(), &m_FontStyle, false);
		m_Flags.m_Map.m_TextDirty = false;
	}

	auto tsize = m_FontInstance->GetSize();
	auto psize = Parent.m_ScreenRect.GetSize();

	if (Uniform) {
		auto ScreenSize = math::fvec2(Graphic::GetRenderDevice()->GetContextSize());
		float Aspect = ScreenSize[0] / ScreenSize[1];
		tsize = tsize / math::fvec2(ScreenSize) * math::fvec2(Aspect * 2.0f, 2.0f);
	}

	math::vec3 Pos(0);

	switch (m_AlignMode) {
	case TextAlignMode::LeftTop:
		break;
	case TextAlignMode::MiddleTop:
		Pos.x = psize.x / 2.0f - tsize.x / 2.0f;
		break;
	case TextAlignMode::RightTop:
		Pos.x = psize.x - tsize.x;
		break;

	case TextAlignMode::LeftMiddle:
		Pos.y = psize.y / 2.0f - tsize.y / 2.0f;
		break;
	case TextAlignMode::Middle:
		Pos = math::vec3((psize - tsize) / 2.0f, 0);
		break;
	case TextAlignMode::RightMiddle:
		Pos.x = psize.x - tsize.x;
		Pos.y = psize.y / 2.0f - tsize.y / 2.0f;
		break;

	case TextAlignMode::LeftBottom:
		Pos.y += psize.y - tsize.y;
		break;
	case TextAlignMode::MiddleBottom:
		Pos.y = psize.y - tsize.y;
		Pos.x = psize.x / 2.0f - tsize.x / 2.0f;
		break;
	case TextAlignMode::RightBottom:
		Pos = math::vec3(psize - tsize, 0);
		break;

		//case TextAlignMode::Justified: break;
	default:
		LogInvalidEnum(m_AlignMode);
		break;
	}

	m_translate = glm::translate(math::mat4(), Pos);
	m_Matrix = Parent.m_GlobalMatrix * m_translate;
	m_Flags.m_Map.m_Dirty = false;
}

} //namespace Component 
} //namespace GUI 
} //namespace MoonGlare 
