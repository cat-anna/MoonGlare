/*
	Generated by cppsrc.sh
	On 2014-12-16  6:13:04,05
	by Paweu
*/

#include <pch.h>
#include <MoonGlare.h>
#include <Engine/ModulesManager.h>
#include <Engine/DataClasses/iFont.h>
#include "Bitmap.h"

//#include <Renderer/Commands/OpenGL/ControllCommands.h>
//#include <Renderer/Commands/OpenGL/ShaderCommands.h>
#include <Renderer/Commands/OpenGL/TextureCommands.h>
#include <Renderer/Commands/OpenGL/ArrayCommands.h>
#include <Renderer/RenderInput.h>

#include <Renderer/Frame.h>
#include <Renderer/RenderDevice.h>
#include <Renderer/TextureRenderTask.h>
#include <Renderer/Resources/ResourceManager.h>

namespace MoonGlare {
namespace Modules {
namespace BitmapFont {
	
struct BitmapFontModule : public MoonGlare::Modules::ModuleInfo {
	BitmapFontModule(): BaseClass("BitmapFont", ModuleType::Functional) { }
	bool Initialize() override {
		FontClassRegister::Register<BitmapFont> ClassReg;
		return true;
	}
};
DEFINE_MODULE(BitmapFontModule);

//----------------------------------------------------------------

SPACERTTI_IMPLEMENT_STATIC_CLASS(BitmapFont);

BitmapFont::BitmapFont(const string& Name): 
		BaseClass(Name) {
}

BitmapFont::~BitmapFont() {
	Finalize();
}

//----------------------------------------------------------------

bool BitmapFont::DoInitialize(){
	if (!BaseClass::DoInitialize())
		return false;

	auto meta = OpenMetaData();
	if (!meta) {
		//silently ignore
		return false;
	}
	auto root = meta->document_element();

	if (!GetFileSystem()->OpenTexture(m_Texture, root.child("Bitmap").text().as_string(ERROR_STR), DataPath::Fonts, false)) {
		AddLog(Error, "Unable to load texture for bitmap font: " << m_TextureFile);
		return false;
	}

	auto &texref = m_Texture;
	Graphic::GetRenderDevice()->RequestContextManip([&texref] () {
		texref->SetNearestFiltering();
	});

	StarVFS::ByteTable data;
	if (!GetFileSystem()->OpenFile(root.child("BFD").text().as_string(ERROR_STR), DataPath::Fonts, data)) {
		AddLog(Error, "Unable to open the bfd file for font '" << GetName() << "'");
		return false;
	}
	memcpy(reinterpret_cast<char*>(&m_BFD), data.get(), sizeof(cBFDHeader));

	return true;
}

//-----------------------------------------------------------------------------

BitmapFont::FontRect BitmapFont::TextSize(const wstring & text, const Descriptor * style, bool UniformPosition) const {

//	Graphic::VAO::MeshData mesh;
//
//	auto ScreenSize = math::fvec2(Graphic::GetRenderDevice()->GetContextSize());
//	float Aspect = ScreenSize[0] / ScreenSize[1];
//
//	float y = 0/*, z = Pos.z*/;
	float h = static_cast<float>(m_BFD.CharWidth);
	if (style && style->Size > 0) 
		h = style->Size;
	float w_mult = h / static_cast<float>(m_BFD.CharWidth);
	unsigned fx = m_BFD.Width / m_BFD.CharWidth;
	float x = 0.0f;

	auto cstr = text.c_str();
	while (*cstr) {
		auto wc = *cstr;
		++cstr;
		char c = static_cast<char>(wc);

		unsigned kid = static_cast<unsigned>(c) - m_BFD.BeginingKey;
		if (kid > 255) 
			kid = fx;

		x += (m_BFD.KeyWidths[kid] + 1) * w_mult;
	}

//	if (UniformPosition)
//		wr->m_size = math::vec2(x, h) / math::fvec2(ScreenSize) * math::fvec2(Aspect * 2.0f, 2.0f);
//	else
//		wr->m_size = math::vec2(x, h);

	FontRect rect;
	rect.m_CanvasSize = math::vec2(x, h);
	rect.m_TextBlockSize = rect.m_CanvasSize;
	rect.m_TextPosition = math::vec2(0, 0);
	return rect;
}

FontInstance BitmapFont::GenerateInstance(const wstring &text, const Descriptor *style, bool UniformPosition) const {
	if (text.empty() || !IsReady()) {
		return FontInstance(new EmptyWrapper());
	}

	int textlen = text.length();
	std::vector<math::fvec3> Coords;
	std::vector<math::fvec2> UVs;
	std::vector<unsigned> Index;
	Coords.reserve(textlen * 4);
	UVs.reserve(textlen * 4);
	Index.reserve(textlen * 6);

	Graphic::VAO::MeshData mesh;

	auto ScreenSize = math::fvec2(Graphic::GetRenderDevice()->GetContextSize());
	float Aspect = ScreenSize[0] / ScreenSize[1];

	float y = 0/*, z = Pos.z*/;
	float h = static_cast<float>(m_BFD.CharWidth), w;
	if (style && style->Size > 0) h = style->Size;
	w = h;
	float w_mult = w / static_cast<float>(m_BFD.CharWidth);
	unsigned fx = m_BFD.Width / m_BFD.CharWidth; 
	float x = 0;
	float Cx = m_BFD.Width / static_cast<float>(m_BFD.CharWidth);
	float Cy = m_BFD.Height / static_cast<float>(m_BFD.CharHeight);
	float dw = 1 / Cx;
	float dh = 1 / Cy;

	static Graphic::IndexVector BaseIndex{ 0, 1, 2, 0, 2, 3, };

	auto cstr = text.c_str();
	while (*cstr) {
		auto wc = *cstr;
		++cstr;

		char c = static_cast<char>(wc);

		unsigned kid = static_cast<unsigned>(c) - m_BFD.BeginingKey;
		if (kid > 255) kid = fx;
		unsigned kol = kid % fx;
		unsigned line = kid / fx;
		float u = kol / Cx;
		float v = 1.0f - (line / Cy);

		math::fvec3 vertex[] = {
			math::fvec3(x + w,	y,		0),
			math::fvec3(x,		y,		0),
			math::fvec3(x,		y + h,	0),
			math::fvec3(x + w,	y + h,	0),
		};

		math::fvec2 uv[] = {
			math::fvec2(u + dw,	v),
			math::fvec2(u,		v),
			math::fvec2(u,		v - dh),
			math::fvec2(u + dw,	v - dh),
		};

		size_t basevertex = Coords.size();
		for (int i = 0; i < 4; ++i){
			if (UniformPosition) {
				Coords.push_back(vertex[i] / math::fvec3(ScreenSize, 1.0f) * math::fvec3(Aspect * 2.0f, 2.0f, 0.0f));
			} else
				Coords.push_back(vertex[i]);
			UVs.push_back(uv[i]);
		//	Index.push_back(Index.size());
		}

		for(auto idx: BaseIndex) 
			Index.push_back(idx + basevertex);

		x += (m_BFD.KeyWidths[kid] + 1) * w_mult;
	}

	auto wr = new BitmapFontWrapper(this);

	if (UniformPosition) 
		wr->m_size = math::vec2(x, h) / math::fvec2(ScreenSize) * math::fvec2(Aspect * 2.0f, 2.0f);
	else
		wr->m_size = math::vec2(x, h);

	mesh.ElementMode = Graphic::Flags::fTriangles;
	mesh.NumIndices = Index.size();
	wr->m_Mesh = mesh;

	Graphic::NormalVector Normals;
	wr->m_VAO.DelayInit(Coords, UVs, Normals, Index);

	if (style) {
		wr->m_Color = style->Color;
	} else {
		wr->m_Color = Graphic::vec3(1);
	}

	return FontInstance(wr);
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

bool BitmapFont::GenerateCommands(Renderer::Commands::CommandQueue &q, Renderer::Frame *frame, const std::wstring &text, const FontRenderRequest &foptions) {
	if (text.empty())
		return true;

	static const std::array<uint8_t, 6> BaseIndex{ 0, 1, 2, 0, 2, 3, };

	unsigned textlen = text.length();
	unsigned VerticlesCount = textlen * 4;
	unsigned IndexesCount = textlen * BaseIndex.size();

	emath::fvec3 *Verticles = frame->GetMemory().Allocate<emath::fvec3>(VerticlesCount);
	emath::fvec2 *TextureUV = frame->GetMemory().Allocate<emath::fvec2>(VerticlesCount);
	uint16_t *VerticleIndexes = frame->GetMemory().Allocate<uint16_t>(IndexesCount);

	float y = 0/*, z = Pos.z*/;
	float h = static_cast<float>(m_BFD.CharWidth), w;
	if (foptions.m_Size > 0) h = foptions.m_Size;
	w = h;
	float w_mult = w / static_cast<float>(m_BFD.CharWidth);
	unsigned fx = m_BFD.Width / m_BFD.CharWidth;
	float x = 0;
	float Cx = m_BFD.Width / static_cast<float>(m_BFD.CharWidth);
	float Cy = m_BFD.Height / static_cast<float>(m_BFD.CharHeight);
	float dw = 1 / Cx;
	float dh = 1 / Cy;


	auto CurrentVertexQuad = Verticles;
	auto CurrentTextureUV = TextureUV;
	auto CurrentIndex = VerticleIndexes;

	auto cstr = text.c_str();
	while (*cstr) {
		auto wc = *cstr;
		++cstr;

		char c = static_cast<char>(wc);

		unsigned kid = static_cast<unsigned>(c) - m_BFD.BeginingKey;
		if (kid > 255) kid = fx;
		unsigned kol = kid % fx;
		unsigned line = kid / fx;
		float u = kol / Cx;
		float v = 1.0f - (line / Cy);

		CurrentVertexQuad[0] = emath::fvec3(x + w,	y,		0);
		CurrentVertexQuad[1] = emath::fvec3(x,		y,		0);
		CurrentVertexQuad[2] = emath::fvec3(x,		y + h,	0);
		CurrentVertexQuad[3] = emath::fvec3(x + w,	y + h,	0);

		CurrentTextureUV[0] = emath::fvec2(u + dw,	v);
		CurrentTextureUV[1] = emath::fvec2(u,		v);
		CurrentTextureUV[2] = emath::fvec2(u,		v - dh);
		CurrentTextureUV[3] = emath::fvec2(u + dw,	v - dh);

		size_t basevertex = CurrentVertexQuad - Verticles;
		for (auto idx : BaseIndex) {
			*CurrentIndex = idx + basevertex;
			++CurrentIndex;
		}

		x += (m_BFD.KeyWidths[kid] + 1) * w_mult;

		CurrentVertexQuad += 4;
		CurrentTextureUV += 4;
	}

	Renderer::VAOResourceHandle vao{ 0 };
	{
		if (!frame->AllocateFrameResource(vao))
			return false;

		auto vaob = frame->GetResourceManager()->GetVAOResource().GetVAOBuilder(q, vao, false);
		vaob.BeginDataChange();

		using ichannels = Renderer::Configuration::VAO::InputChannels;
		vaob.CreateChannel(ichannels::Vertex);
		vaob.SetChannelData<float, 3>(ichannels::Vertex, &Verticles[0][0], VerticlesCount);

		vaob.CreateChannel(ichannels::Texture0);
		vaob.SetChannelData<float, 2>(ichannels::Texture0, &TextureUV[0][0], VerticlesCount);

		vaob.CreateChannel(ichannels::Index);
		vaob.SetIndex(ichannels::Index, VerticleIndexes, IndexesCount);

		vaob.EndDataChange();
	}
	using namespace ::MoonGlare::Renderer;
	auto key = Commands::CommandKey();

	q.PushCommand<Renderer::Commands::Texture2DBind>(key)->m_Texture = m_Texture->Handle();
	auto arg = q.PushCommand<Renderer::Commands::VAODrawTriangles>(key);
	arg->m_NumIndices = IndexesCount;
	arg->m_IndexValueType = Renderer::GLTypeInfo<std::remove_reference_t<decltype(*VerticleIndexes)>>::TypeId;

	return true;
}

bool BitmapFont::RenderText(const std::wstring &text, Renderer::Frame *frame, const FontRenderRequest &foptions, FontRect &outTextRect, FontResources &resources) {

	if (!m_RtShader) {
		if (!Graphic::GetShaderMgr()->GetSpecialShaderType<Graphic::Shaders::Shader>("Font/Simple", m_RtShader)) {
			AddLogf(Error, "Failed to load RtShader shader");
		}
	}

	if (!m_RtShader)
		return false;

	DataClasses::Fonts::Descriptor dummy;
	dummy.Size = foptions.m_Size;

	auto trt = frame->GetDevice()->AllocateTextureRenderTask();
	if (!trt)
		return false;

//	auto &fonti = instance;
	auto tsize = outTextRect = TextSize(text.c_str(), &dummy, false);

	trt->SetFrame(frame);
	trt->SetTarget(resources.m_Texture, emath::MathCast<emath::ivec2>(tsize.m_CanvasSize));

	trt->Begin();

	auto &q = trt->GetCommandQueue();

	using namespace ::MoonGlare::Renderer;
	using namespace ::MoonGlare::Renderer::Commands;
	auto key = CommandKey();

	m_RtShader->Bind(q, key);
	m_RtShader->SetModelMatrix(q, key, emath::MathCast<emath::fmat4>(glm::translate(glm::mat4(), math::vec3(tsize.m_TextPosition, 0))));// emath::MathCast<emath::fmat4>(entry.m_Matrix));

	VirtualCamera Camera;
	Camera.SetDefaultOrthogonal(tsize.m_CanvasSize);

	m_RtShader->SetCameraMatrix(q, key, Camera.GetProjectionMatrix());

	m_RtShader->SetColor(q, key, foptions.m_Color);
	
	if (!GenerateCommands(q, frame, text, foptions)) {
		int i = 0;
	}

	trt->End();

	auto su = tsize.m_CanvasSize;
	Graphic::QuadArray3 Vertexes{
		Graphic::vec3(0, su[1], 0),
		Graphic::vec3(su[0], su[1], 0),
		Graphic::vec3(su[0], 0, 0),
		Graphic::vec3(0, 0, 0),
	};
	float w1 = 0.0f;
	float h1 = 0.0f;
	float w2 = 1.0f;
	float h2 = 1.0f;
	Graphic::QuadArray2 TexUV{
		Graphic::vec2(w1, h1),
		Graphic::vec2(w2, h1),
		Graphic::vec2(w2, h2),
		Graphic::vec2(w1, h2),
	};

	{
		auto &m = frame->GetMemory();
		using ichannels = Renderer::Configuration::VAO::InputChannels;

		auto vaob = frame->GetResourceManager()->GetVAOResource().GetVAOBuilder(q, resources.m_VAO, true);
		vaob.BeginDataChange();

		vaob.CreateChannel(ichannels::Vertex);
		vaob.SetChannelData<float, 3>(ichannels::Vertex, (const float*)m.Clone(Vertexes), Vertexes.size());

		vaob.CreateChannel(ichannels::Texture0);
		vaob.SetChannelData<float, 2>(ichannels::Texture0, (const float*)m.Clone(TexUV), TexUV.size());

		vaob.CreateChannel(ichannels::Index);
		static constexpr std::array<uint8_t, 6> IndexTable = { 0, 1, 2, 0, 2, 3, };
		vaob.SetIndex(ichannels::Index, IndexTable);

		vaob.EndDataChange();
		vaob.UnBindVAO();
	}

	frame->Submit(trt);
	
	//instance.release();

	return true;
}

//----------------BitmapWrapper-------------------------------------------------------------

SPACERTTI_IMPLEMENT_STATIC_CLASS(BitmapFontWrapper);

BitmapFontWrapper::BitmapFontWrapper(const BitmapFont *font): 
		BaseClass(),
		m_Texture(font->GetTexture()) {
	m_AllowSubPixels = false;
}

BitmapFontWrapper::~BitmapFontWrapper() {
	m_VAO.Finalize();
}
 
void BitmapFontWrapper::Render(Graphic::cRenderDevice &dev) {
	dev.CurrentShader()->SetBackColor(m_Color);
	m_Texture->Bind();
	m_VAO.Bind();
	m_VAO.DrawElements(m_Mesh);
}

void BitmapFontWrapper::RenderMesh(Graphic::cRenderDevice &dev) {
	m_VAO.Bind();
	m_VAO.DrawElements(m_Mesh);
}

void BitmapFontWrapper::GenerateCommands(Renderer::Commands::CommandQueue & Queue, uint16_t key) {
	if (m_VAO.Handle() == 0)
		return;

	Renderer::RendererConf::CommandKey qkey{ key };

	Queue.PushCommand<Renderer::Commands::Texture2DBind>(qkey)->m_Texture = m_Texture->Handle();
	Queue.PushCommand<Renderer::Commands::VAOBind>(qkey)->m_VAO = m_VAO.Handle();

	auto arg = Queue.PushCommand<Renderer::Commands::VAODrawTriangles>(qkey);
	arg->m_NumIndices = m_Mesh.NumIndices;
	arg->m_IndexValueType = GL_UNSIGNED_INT;
}

//----------------BitmapFont::cBFDHeader-------------------------------------------------------------

BitmapFont::cBFDHeader::cBFDHeader(){
	Width = Height = CharWidth = CharHeight = 0;
	BeginingKey = 0;
	memset(KeyWidths, 0, 256);
}

} //namespace BitmapFont 
} //namespace Modules 
} //namespace MoonGlare 
