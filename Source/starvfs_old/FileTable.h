/*
  * Generated by cppsrc.sh
  * On 2015-12-10 18:00:09,91
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef FileTable_H
#define FileTable_H

namespace StarVFS {

class FileTable final {
public:
 	explicit FileTable(StarVFS *Owner);
 	~FileTable();

	void DumpStructure(std::ostream &out) const;
	void DumpFileTable(std::ostream &out) const;
	void DumpHashTable(std::ostream &out) const;

	File* AllocFile(const CString InternalFullPath);
	File* AllocFile(FileID Parent, FilePathHash PathHash, const CString FileName);

	struct FileStructureInfo {
		FileID m_Count;
		FilePathHash* m_PathHashTable;
		BaseFileInfo *m_FileTable;

		File* m_Parent;

		ContainerID m_OwnerContainer;

		bool IsValid() const { return m_OwnerContainer && m_Count && m_PathHashTable && m_FileTable && m_Parent; }
	};
	bool RegisterStructureTable(FileStructureInfo &info);
	
	template<class ... ARGS> FileID Lookup(ARGS... args) { return m_HashFileTable.Lookup(std::forward<ARGS>(args)...); }

	bool IsValid(FileID fid) const { return fid && fid < m_Allocated && m_FileTable[fid].m_Flags.ValidOrDeleted(); }
	File* GetFile(FileID fid) const {
		if (!IsValid(fid)) return nullptr;
		return &m_FileTable[fid];
	}
	File* GetRawFile(FileID fid) const {
		if (!fid || fid >= m_Allocated) return nullptr;
		return &m_FileTable[fid];
	}
	bool IsFile(FileID fid) const {
		auto f = GetFile(fid);
		return f && !f->m_Flags.Directory;
	}
	bool IsDirectory(FileID fid) const {
		auto f = GetFile(fid);
		return f && f->m_Flags.Directory;
	}

	File* GetFileParent(const File *f) const { return GetFile(f->m_ParentFileID); }
	File* GetFileFirstChild(const File *f) const { return GetFile(f->m_FirstChild); }
	File* GetFileNextSibling(const File *f) const { return GetFile(f->m_NextSibling); }

	CString GetFileName(FileID fid) const;
	String GetFileFullPath(FileID fid) const { return GetFilePath(fid, 0); }
	String GetFilePath(FileID fid, FileID ParentFID) const;
	bool GetFileData(FileID fid, ByteTable &data);
	bool SetFileData(FileID fid, const ByteTable &data);
	FileFlags GetFileFlags(FileID fid) const;

	const StringTable* GetStringTable() const { return m_StringTable.get(); }
	const File* GetTable() const { return m_FileTable.get(); }
	FileID GetAllocatedFileCount() const { return m_Allocated; }
	static FileID GetRootID() { return 1; }
	File* GetRoot() const { return m_FileTable.get() + GetRootID(); }

	bool DeleteFile(FileID fid);
	bool DeleteFile(FileID fid, ContainerID cid);

	Containers::FileTableInterface *AllocateInterface(const String& MountPoint);
	bool EnsureCapacity(FileID RequiredEmptySpace);

	void FindFilesByTypeHash(const CString ext, DynamicFIDTable &table) { return FindFilesByTypeHash(MakeFileTypeHash(ext), table); }
	void FindFilesByTypeHash(FileTypeHash fth, DynamicFIDTable &table);

	void InvalidateCID(ContainerID cid);
private:
	std::unique_ptr<StringTable> m_StringTable;
	std::vector<UniqueFileTableInterface> m_Interfaces;
	HashFileTable m_HashFileTable;
	std::unique_ptr<File[]> m_FileTable;
	std::unique_ptr<FileTypeHash[]> m_FileTypeHash;
	FileID m_Capacity, m_Allocated;
	StarVFS *m_Owner;

	bool Realloc(FileID NewCapacity);

	File* AllocNewFile();
	File* AllocNewFile(FileID ParentID, FilePathHash PathHash, const CString FName);
	File* AllocNewFile(const CString fullpath);

	FileTypeHash MakeFileTypeHash(const CString FName) {
		auto dot = strrchr(FName, '.');
		if (!dot)
			dot = "";
		else
			++dot;

		Char ext[128];
		auto len = strlen(dot);
        auto tr = [](Char c) {
            return static_cast<Char>(::tolower(static_cast<int>(c)));
        };
		std::transform(dot, dot + len, ext, tr);

		return Murmur3Hash32::Hash(ext, len);
	}
};

} //namespace StarVFS 

#endif
