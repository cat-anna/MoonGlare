/*
  * Generated by cppsrc.sh
  * On 2015-12-17 21:59:15,19
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include "../StarVFSInternal.h"
#include "RDCExporter.h"
#include "../RDC/nRDC.h"
//#include <boost/algorithm/string.hpp>

namespace StarVFS {
namespace Exporters {

using namespace RDC;

struct RDCExporter::Impl {
	Impl(RDCExporter *Owner) {
		m_Owner = Owner;
		m_FileList = &Owner->GetFileList();
		m_Builder = std::make_unique<RDC::Version_1::Builder_v1>();
	}

	ExportResult Export(const String &LocalFileName) {
		if (!m_Builder)
			return ExportResult::FatalError;

		if (!m_Builder->BeginFile(LocalFileName)) {
			//todo: log
			return ExportResult::LocalFileWriteError;
		}

		auto mountentry = m_Builder->CreateMountEntrySection();
		auto StringTable = m_Builder->CreateStringTableSection();
		auto rawdata = m_Builder->CreateRawDataSection();
		auto datablock = m_Builder->CreateOffsetDataBlockTable();
		auto structure = m_Builder->CreateFileStructureTable();
		auto hashtable = m_Builder->CreateHashTable();
		//todo: check if null

		mountentry->SetStringTable(StringTable);
		mountentry->SetRawDataSection(rawdata);
		mountentry->SetOffsetDataBlockTable(datablock);
		mountentry->SetFileStructureTable(structure);
		mountentry->SetHashTableSection(hashtable);

		if (m_CompressionMode != RDC::CompressionMode::None) {
			m_Builder->ForEachSection([this](RDC::Version_1::Sections::BaseSection * s) {
				s->SetCompression(m_CompressionMode, m_CompressionLevel);
			});
		}

		auto &inputfiles = m_Owner->GetFileList();
		
		auto &outputfiles = structure->GetTable();
		auto &blocktable = datablock->GetTable();
		auto &hasht = hashtable->GetTable();

		outputfiles.resize(inputfiles.size());
		blocktable.resize(inputfiles.size());
		hasht.resize(inputfiles.size());

		for (size_t i = 1, j = inputfiles.size(); i < j; ++i) {
			auto &inf = inputfiles[i];
			auto &outf = outputfiles[i];
			auto &outblock = blocktable[i];

			outf.NamePointer = StringTable->AllocString(inf.m_FileName);

			//outf.FistChild = inf.m_FirstChildID;
			//outf.NextSibling = inf.m_NextSiblingID;
			outf.ParentIndex = inf.m_ParentID;

			if (inf.m_Flags.Directory)
				outf.Flags |= Version_1::BaseFileInfo::FlagBits::Directory;

			hasht[i] = inf.m_Hash;
			//outf.SymLinkIndex = 

			if (m_CompressionMode != RDC::CompressionMode::None) {
				outblock.Compression.Mode = m_CompressionMode;
				outblock.Compression.Level = (RDC::u8)m_CompressionLevel;
			}
			
			if (inf.m_Flags.ValidFile()) {
				ByteTable ct;
				if (!m_Owner->GetSVFS()->GetFileData(inf.m_VFSFileID, ct)) {
					auto path = m_Owner->GetSVFS()->GetFullFilePath(inf.m_VFSFileID);
					STARVFSErrorLog("Failed to read content of file %d (%s)", inf.m_VFSFileID, path.c_str());
				} else {
					auto ret = rawdata->PushOffsetDataBlock(ct, outblock);
					if(!ret) {
						auto path = m_Owner->GetSVFS()->GetFullFilePath(inf.m_VFSFileID);
						STARVFSErrorLog("Failed to export content of file %d (%s)", inf.m_VFSFileID, path.c_str());
					}
					if (ret.m_Compression == Compression::CompressionResult::UnableToReduceSize) {
						auto path = m_Owner->GetSVFS()->GetFullFilePath(inf.m_VFSFileID);
						STARVFSDebugLog("File %d (%s) was not compressed. Reason: Unable to reduce size", inf.m_VFSFileID, path.c_str());
					}
				}
			}
		}
		
		//todo: work
		
		if (!m_Builder->CloseFile()) {
			//todo: log
			return ExportResult::FatalError;
		}

		return ExportResult::Sucess;
	}

	RDCExporter *m_Owner;
	std::unique_ptr<RDC::Version_1::Builder_v1> m_Builder;
	const std::vector<iExporter::ExporterFile> *m_FileList;

	String m_StringCompressionLevel, m_StringCompressionMode;

	RDC::CompressionMode m_CompressionMode = RDC::CompressionMode::None;
	Compression::Compressionlevel m_CompressionLevel;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

RDCExporter::RDCExporter(StarVFS *svfs) : iExporter(svfs) {
	m_Impl = std::make_unique<Impl>(this);
}

RDCExporter::~RDCExporter() {
}

//-----------------------------------------------------------------------------

ExportResult RDCExporter::WriteLocalFile(const String &LocalFileName) {
	return m_Impl->Export(LocalFileName);
}

//-----------------------------------------------------------------------------

void RDCExporter::SetCompressionMode(const String& value) {
	m_Impl->m_StringCompressionMode = value;

	//if (!boost::iequals(value.c_str(), "zlib")) {
	//	m_Impl->m_CompressionMode = RDC::CompressionMode::ZLib;
	//} else {
	//	m_Impl->m_CompressionMode = RDC::CompressionMode::None;
	//	STARVFSErrorLog("Unknown compression mode %s", value.c_str());
	//}
}

const String& RDCExporter::GetCompressionMode() const {
	return m_Impl->m_StringCompressionMode;
}

void RDCExporter::SetCompressionLevel(const String& value) {
	m_Impl->m_StringCompressionLevel = value;

	//if (!boost::iequals(value.c_str(), "low")) {
	//	m_Impl->m_CompressionLevel = Compression::Compressionlevel::Low;
	//} else {
	//	if (!boost::iequals(value.c_str(), "medium")) {
	//		m_Impl->m_CompressionLevel = Compression::Compressionlevel::Medium;
	//	} else {
	//		if (!boost::iequals(value.c_str(), "high")) {
	//			m_Impl->m_CompressionLevel = Compression::Compressionlevel::High;
	//		} else {
	//			if (!boost::iequals(value.c_str(), "none")) {
	//				m_Impl->m_CompressionLevel = Compression::Compressionlevel::NoCompression;
	//			} else {
	//				m_Impl->m_CompressionLevel = Compression::Compressionlevel::NoCompression;
	//				STARVFSErrorLog("Unknown compression level %s", value.c_str());
	//			}
	//		}
	//	}
	//}
}

const String& RDCExporter::GetCompressionLevel() const {
	return m_Impl->m_StringCompressionLevel;
}

} //namespace Exporters 
} //namespace StarVFS 
