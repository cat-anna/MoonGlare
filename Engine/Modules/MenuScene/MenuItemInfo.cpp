/*
  * Generated by cppsrc.sh
  * On 2015-05-24  9:54:01,64
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include <pch.h>
#include <MoonGlare.h>
#include <Engine/GUI/nGUI.h>
#include "MenuItemInfo.h"
#include <Engine/GUI/Widgets/Panel.h>
#include <Engine/GUI/Widgets/Table.h>
#include <Engine/GUI/Widgets/Label.h>
#include <Engine/GUI/Widgets/SplitPanel.h>
#include <Engine/GUI/Widgets/Image.h>
#include <Engine/GUI/Widgets/SteppedProgressBar.h>
#include "MenuWidget.h"
#include "MenuScene.h"

namespace MoonGlare {
namespace Modules {
namespace MenuScene {

GABI_IMPLEMENT_STATIC_CLASS(MenuItemInfo);
RegisterApiDerivedClass(MenuItemInfo, &MenuItemInfo::RegisterScriptApi);

MenuItemInfo::MenuItemInfo(MenuScene *Owner, SharedMenuItemInfo Parent) : 
		m_OwnerScene(Owner), 
		m_Parent(Parent) { 
}

void MenuItemInfo::RegisterScriptApi(ApiInitializer &api) {
	api
	.deriveClass<ThisClass, BaseClass>("cMenuSceneItem")
	.endClass();
}

bool MenuItemInfo::Load(xml_node root) {
	m_ItemNode = root;
		
	m_Events.LoadFromXML(root);
	m_ItemId = root.attribute(xmlAttr_Id).as_int(0);
	m_CaptionId = root.attribute("CaptionId").as_string(ERROR_STR);
	m_BaseWidgetName = root.attribute("BaseName").as_string(ERROR_STR);
		
	return true;
}

string MenuItemInfo::GetCaption() { 
	return GetDataMgr()->GetString(m_CaptionId, m_OwnerScene->GetConfiguration().StringTable); 
}

int MenuItemInfo::InvokeOnEnter() { SCRIPT_INVOKE(OnEnter, m_OwnerScene, m_ItemId); }
int MenuItemInfo::InvokeOnExit() { SCRIPT_INVOKE(OnExit, m_OwnerScene, m_ItemId); }
int MenuItemInfo::InvokeOnSubEnter() { SCRIPT_INVOKE(OnSubEnter, m_OwnerScene, m_ItemId); }
int MenuItemInfo::InvokeOnSubExit() { SCRIPT_INVOKE(OnSubExit, m_OwnerScene, m_ItemId); }
//----------------------------------------------------------------

class ListMenuItem : public MenuItemInfo {
	GABI_DECLARE_STATIC_CLASS(ListMenuItem, MenuItemInfo);
public:
	ListMenuItem(MenuScene *Owner, SharedMenuItemInfo Parent):
			BaseClass(Owner, Parent),
			m_ItemsGenerated(false) {
		m_Type = MenuItemType::List;
	}

	using ListMenuItems = std::vector < std::pair<int, string> >;

	enum class SubWidgetID {
		Unknown, LeftButton, RightButton,
	};

	struct ListItemsGenerator : public cRootClass {
		ListItemsGenerator(ListMenuItems &items): m_Items(items) { }
		ListItemsGenerator& operator=(const ListItemsGenerator&) = delete;
		ListItemsGenerator(const ListItemsGenerator&) = delete;

		void AddItem(const char* Title, int value) {
			m_Items.emplace_back(value, Title);
		}
	private:
		ListMenuItems &m_Items;
	};

	bool Load(xml_node root) {
		if (!BaseClass::Load(root))
			return false;

		auto config = root.child("Configuration");
		m_UseStringTables = config.child("UseStringTables").text().as_bool(true);
		m_LeftImg = config.child("LeftArrow").text().as_string(ERROR_STR);
		m_RightImg = config.child("RightArrow").text().as_string(ERROR_STR);
		m_ImageScale = config.child("ImageScale").text().as_float(1.0f);
		m_CurrentValue = config.child("Value").text().as_uint(0);
		
		XML::ForEachChild(root.child("Values"), "Item", [this](xml_node node)->int {
			int value = node.attribute("Value").as_int(0);
			const char *captid = node.attribute("CaptionId").as_string(ERROR_STR);
			m_ListItems.push_back(std::make_pair(value, captid));
			return 0;
		});

		m_ListItems.shrink_to_fit();

		return true;
	}

	bool BuildItemGUI(GUI::Widgets::Panel *parent) override {
		m_SplitPanel = new GUI::Widgets::SplitPanel(parent);
		m_SplitPanel->SetAlignMode(GUI::AlignMode::Parent);
		parent->AddWidget(m_SplitPanel);
		m_Widget = m_SplitPanel;
		m_SplitPanel->SetSplitPosition(0.5f);
		auto *left = m_SplitPanel->GetLeftPanel();
		auto *right = m_SplitPanel->GetRightPanel();
		auto sharedthis = shared_from_this();

		auto caption = new MenuLabel(m_OwnerScene, sharedthis, left);
		left->AddWidget(caption);
		//caption->SetEnabled(false);
		caption->SetUtf8Text(GetCaption());
		caption->SetTextAlignMode(GUI::TextAlignMode::RightMiddle);
		caption->SetAlignMode(GUI::AlignMode::Parent);

		auto imgleft = new MenuImage(m_OwnerScene, sharedthis, right, (int)SubWidgetID::LeftButton);
		imgleft->SetAlignMode(GUI::AlignMode::Left);
		imgleft->SetScaleMode(GUI::ScaleMode::User);
		imgleft->SetImageAlignMode(GUI::InnerAlignMode::LeftMiddle);
		imgleft->SetScale(m_ImageScale);
		imgleft->SetImage(m_LeftImg);
		right->AddWidget(imgleft);

		auto imgright = new MenuImage(m_OwnerScene, sharedthis, right, (int)SubWidgetID::RightButton);
		imgright->SetAlignMode(GUI::AlignMode::Right);
		imgright->SetScaleMode(GUI::ScaleMode::User);
		imgright->SetImageAlignMode(GUI::InnerAlignMode::RightMiddle);
		imgright->SetScale(m_ImageScale);
		imgright->SetImage(m_RightImg);
		right->AddWidget(imgright);

		if (m_ItemsGenerated || m_ListItems.empty()) {
			m_ItemsGenerated = true;
			m_ListItems.clear();
			ListItemsGenerator generator(m_ListItems);
			SCRIPT_INVOKE_NORETURN(GenerateList, m_OwnerScene, m_ItemId, &generator);
			if (m_ListItems.empty())
				return false;
			m_ListItems.shrink_to_fit();
		}

		SCRIPT_INVOKE_RESULT(m_CurrentValue, GetValue, m_OwnerScene, m_ItemId, m_CurrentValue);
		m_CurrentValue = math::clamp(m_CurrentValue, 0, (int)m_ListItems.size() - 1);

		auto valcaption = new MenuLabel(m_OwnerScene, sharedthis, right);
		right->AddWidget(valcaption);
		//valcaption->SetEnabled(false);
		valcaption->SetUtf8Text("ValueLabel");
		valcaption->SetName("ValueLabel");
		valcaption->SetTextAlignMode(GUI::TextAlignMode::Middle);
		valcaption->SetAlignMode(GUI::AlignMode::Parent);

		auto &value = m_ListItems[m_CurrentValue];

		if (m_UseStringTables)
			valcaption->SetUtf8Text(GetDataMgr()->GetString(value.second, m_OwnerScene->GetConfiguration().StringTable));
		else
			valcaption->SetUtf8Text(value.second);

		return true;
	}

	void HandleMouseUp(const GUI::Events::MouseUpEvent& ev, int WidgetID) {
		switch ((SubWidgetID)WidgetID) {
		case SubWidgetID::LeftButton:
			HandleLeftButton();
			break;
		case SubWidgetID::RightButton:
			HandleRightButton();
			break;
		default:
			return;
		}
	}

	static void RegisterScriptApi(ApiInitializer &api) {
		api
		.deriveClass<ThisClass, BaseClass>("cMenuSceneListItem")
		.endClass()
		.deriveClass<ListItemsGenerator, cRootClass>("cMenuSceneListItemGenerator")
			.addFunction("AddItem", &ListItemsGenerator::AddItem)
		.endClass();
	}
private:
	ListMenuItems m_ListItems;
	GUI::Widgets::SplitPanel *m_SplitPanel;
	string m_LeftImg, m_RightImg;
	float m_ImageScale;
	bool m_ItemsGenerated;
	bool m_UseStringTables;

	int m_CurrentValue;

	void HandleLeftButton() {
		if (m_CurrentValue <= 0)
			m_CurrentValue = m_ListItems.size() - 1;
		else
			--m_CurrentValue;
		ValueChanged();
	}
	void HandleRightButton() {
		if (m_CurrentValue >= (int)m_ListItems.size() - 1)
			m_CurrentValue = 0;
		else
			++m_CurrentValue;
		ValueChanged();
	}
	void ValueChanged() {
		if (!m_SplitPanel)
			return;
		auto w = m_SplitPanel->FindWidget("ValueLabel");
		if (!w)
			return;
		auto label = dynamic_cast<MenuLabel*>(w);
		if (!label)
			return;

		SCRIPT_INVOKE_NORETURN(SetValue, m_OwnerScene, m_ItemId, m_CurrentValue);
		auto &value = m_ListItems[m_CurrentValue];
		if (m_UseStringTables)
			label->SetUtf8Text(GetDataMgr()->GetString(value.second, m_OwnerScene->GetConfiguration().StringTable));
		else
			label->SetUtf8Text(value.second);
	}
};

GABI_IMPLEMENT_STATIC_CLASS(ListMenuItem);
RegisterApiDerivedClass(ListMenuItem, &ListMenuItem::RegisterScriptApi);

//----------------------------------------------------------------

class ButtonMenuItem : public MenuItemInfo {
	GABI_DECLARE_STATIC_CLASS(ButtonMenuItem, MenuItemInfo);
public:
	ButtonMenuItem(MenuScene *Owner, SharedMenuItemInfo Parent):
			BaseClass(Owner, Parent) {
		m_Type = MenuItemType::Button;
	}

	bool Load(xml_node root) {
		if (!BaseClass::Load(root))
			return false;

		return true;
	}

	void Click() {
		SCRIPT_INVOKE_NORETURN(OnClick, m_OwnerScene, m_ItemId);
	}

	bool BuildItemGUI(GUI::Widgets::Panel *parent) override {
		auto l = new MenuLabel(m_OwnerScene, shared_from_this(), parent);
		m_Widget = l;
		l->SetUtf8Text(GetCaption());
		l->SetTextAlignMode(GUI::TextAlignMode::Middle);
		l->SetAlignMode(GUI::AlignMode::Parent);
		parent->AddWidget(l);
		return true;
	}

	void HandleMouseUp(const GUI::Events::MouseUpEvent& ev, int WidgetID) {
		Click();
	}

	static void RegisterScriptApi(ApiInitializer &api) {
		api
		.deriveClass<ThisClass, BaseClass>("cMenuSceneButtonItem")
		.endClass();
	}
};

GABI_IMPLEMENT_STATIC_CLASS(ButtonMenuItem);
RegisterApiDerivedClass(ButtonMenuItem, &ButtonMenuItem::RegisterScriptApi);

//----------------------------------------------------------------

class GoBackMenuItem : public SubMenuItem {
	GABI_DECLARE_STATIC_CLASS(GoBackMenuItem, SubMenuItem);
public:
	GoBackMenuItem(MenuScene *Owner, SharedMenuItemInfo Parent):
			BaseClass(Owner, Parent) {
		m_Type = MenuItemType::Return;
	}
	void HandleMouseUp(const GUI::Events::MouseUpEvent& ev, int WidgetID) {
		m_OwnerScene->GoBack();
	}
	static void RegisterScriptApi(ApiInitializer &api) {
		api
		.deriveClass<ThisClass, BaseClass>("cMenuSceneReturnItem")
		.endClass();
	}
private:
};

GABI_IMPLEMENT_STATIC_CLASS(GoBackMenuItem);
RegisterApiDerivedClass(GoBackMenuItem, &GoBackMenuItem::RegisterScriptApi);

//----------------------------------------------------------------

class CheckBoxMenuItem : public MenuItemInfo {
	GABI_DECLARE_STATIC_CLASS(CheckBoxMenuItem, MenuItemInfo);
public:
	CheckBoxMenuItem(MenuScene *Owner, SharedMenuItemInfo Parent):
			BaseClass(Owner, Parent) {
		m_Type = MenuItemType::CheckBox;
	}

	bool Load(xml_node root) {
		if (!BaseClass::Load(root))
			return false;

		auto config = root.child("Configuration");
		m_UncheckedImage = config.child("Unchecked").text().as_string(ERROR_STR);
		m_CheckedImage = config.child("Checked").text().as_string(ERROR_STR);
		m_ImageScale = config.child("ImageScale").text().as_float(1.0f);
		m_CurrentValue = config.child("Value").text().as_bool(0);

		return true;
	}

	bool BuildItemGUI(GUI::Widgets::Panel *parent) override {
		m_SplitPanel = new GUI::Widgets::SplitPanel(parent);
		m_SplitPanel->SetAlignMode(GUI::AlignMode::Parent);
		parent->AddWidget(m_SplitPanel);
		m_Widget = m_SplitPanel;
		m_SplitPanel->SetSplitPosition(0.5f);
		auto *left = m_SplitPanel->GetLeftPanel();
		auto *right = m_SplitPanel->GetRightPanel();
		auto sharedthis = shared_from_this();

		auto caption = new MenuLabel(m_OwnerScene, sharedthis, left);
		left->AddWidget(caption);
		caption->SetUtf8Text(GetCaption());
		caption->SetTextAlignMode(GUI::TextAlignMode::RightMiddle);
		caption->SetAlignMode(GUI::AlignMode::Parent);

		int val = 0;
		SCRIPT_INVOKE_RESULT(val, GetValue, m_OwnerScene, m_ItemId, val);
		m_CurrentValue = static_cast<bool>(val);

		auto image = new MenuImage(m_OwnerScene, sharedthis, right, 0);
		image->SetAlignMode(GUI::AlignMode::Left);
		image->SetScaleMode(GUI::ScaleMode::User);
		image->SetImageAlignMode(GUI::InnerAlignMode::Middle);
		image->SetScale(m_ImageScale);
		image->SetImage(m_CurrentValue ? m_CheckedImage : m_UncheckedImage);
		image->SetName("ValueImage");
		right->AddWidget(image);

		return true;
	}

	void HandleMouseUp(const GUI::Events::MouseUpEvent& ev, int WidgetID) {
		m_CurrentValue = !m_CurrentValue;
		ValueChanged();
	}

	static void RegisterScriptApi(ApiInitializer &api) {
		api
		.deriveClass<ThisClass, BaseClass>("cMenuSceneChekcBoxItem")
		.endClass();
	}
private:
	GUI::Widgets::SplitPanel *m_SplitPanel;
	string m_UncheckedImage, m_CheckedImage;
	float m_ImageScale;
	bool m_CurrentValue;

	void ValueChanged() {
		if (!m_SplitPanel)
			return;
		auto w = m_SplitPanel->FindWidget("ValueImage");
		if (!w)
			return;
		auto image = dynamic_cast<MenuImage*>(w);
		if (!image)
			return;

		SCRIPT_INVOKE_NORETURN(SetValue, m_OwnerScene, m_ItemId, m_CurrentValue);

		image->SetImage(m_CurrentValue ? m_CheckedImage : m_UncheckedImage);
	}
};

GABI_IMPLEMENT_STATIC_CLASS(CheckBoxMenuItem);
RegisterApiDerivedClass(CheckBoxMenuItem, &CheckBoxMenuItem::RegisterScriptApi);

//----------------------------------------------------------------

class SteppedBarMenuItem : public MenuItemInfo {
	GABI_DECLARE_STATIC_CLASS(SteppedBarMenuItem, MenuItemInfo);
public:
	SteppedBarMenuItem(MenuScene *Owner, SharedMenuItemInfo Parent):
			BaseClass(Owner, Parent) {
		m_Type = MenuItemType::SteppedProgressBar;
	}

	bool Load(xml_node root) {
		if (!BaseClass::Load(root))
			return false;

		auto config = root.child("Configuration");
		m_StepImage = config.child("StepImage").text().as_string(ERROR_STR);
		m_StepCount = config.child("StepCount").text().as_uint(20);
		auto range = config.child("Range");
		m_Range[0] = range.attribute("Min").as_float(0.0f);
		m_Range[1] = range.attribute("Max").as_float(1.0f);
		XML::Vector::Read(config, "InactiveColor", m_InactiveColor, math::vec3(0.5f), XML::Captions::RGBA);

		return true;
	}

	bool BuildItemGUI(GUI::Widgets::Panel *parent) override {
		m_SplitPanel = new GUI::Widgets::SplitPanel(parent);
		m_SplitPanel->SetAlignMode(GUI::AlignMode::Parent);
		parent->AddWidget(m_SplitPanel);
		m_Widget = m_SplitPanel;
		m_SplitPanel->SetSplitPosition(0.5f);
		auto *left = m_SplitPanel->GetLeftPanel();
		auto *right = m_SplitPanel->GetRightPanel();
		auto sharedthis = shared_from_this();

		m_Label = new MenuLabel(m_OwnerScene, sharedthis, left);
		left->AddWidget(m_Label);
		m_Label->SetUtf8Text(GetCaption());
		m_Label->SetTextAlignMode(GUI::TextAlignMode::RightMiddle);
		m_Label->SetAlignMode(GUI::AlignMode::Parent);

		SCRIPT_INVOKE_RESULT(m_CurrentValue, GetValue, m_OwnerScene, m_ItemId, m_CurrentValue);

		m_Bar = new MenuWidget<GUI::Widgets::SteppedProgressBar>(m_OwnerScene, sharedthis, right, 1);
		m_Bar->SetAlignMode(GUI::AlignMode::Center);
		auto size = m_OwnerScene->GetConfiguration().ItemSize;
		size[0] /= 2.0f; size[1] *= 3.0f / 5.0f;
		m_Bar->SetSize(size);
		m_Bar->SetStepImage(m_StepImage);
		m_Bar->SetRange(m_Range[0], m_Range[1]);
		m_Bar->SetStepsCount(m_StepCount);
		m_Bar->SetValue(m_CurrentValue);
		m_CurrentValue = m_Bar->GetUniformValue();
		m_Bar->SetName("ValueBar");
		m_Bar->SetInactiveColor(m_InactiveColor);
		right->AddWidget(m_Bar);

		return true;
	}

	void HandleMouseUp(const GUI::Events::MouseUpEvent& ev, int WidgetID) {
		if (WidgetID != 1)//not a progressbar
			return;
		float pos = ev.MousePosition[0] / m_Bar->GetSize()[0];
		AddLog(Debug, "m: " << ev.MousePosition << "pos:" << pos);
		m_CurrentValue = pos;
		ValueChanged();
	}

	static void RegisterScriptApi(ApiInitializer &api) {
		api
		.deriveClass<ThisClass, BaseClass>("cMenuSceneChekcBoxItem")
		.endClass();
	}
private:
	GUI::Widgets::Label *m_Label;
	GUI::Widgets::SteppedProgressBar *m_Bar;
	string m_StepImage;
	unsigned m_StepCount;
	math::vec2 m_Range;
	math::vec3 m_InactiveColor;

	GUI::Widgets::SplitPanel *m_SplitPanel;
	
	float m_CurrentValue = 0.0f;

	void ValueChanged() {
		if (!m_Bar)
			return;

		m_Bar->SetUniformValue(m_CurrentValue);
		SCRIPT_INVOKE_NORETURN(SetValue, m_OwnerScene, m_ItemId, m_Bar->GetValue());
	}
};

GABI_IMPLEMENT_STATIC_CLASS(SteppedBarMenuItem);
RegisterApiDerivedClass(SteppedBarMenuItem, &SteppedBarMenuItem::RegisterScriptApi);

//----------------------------------------------------------------

class LabelMenuItem : public MenuItemInfo {
	GABI_DECLARE_STATIC_CLASS(LabelMenuItem, MenuItemInfo);
public:
	LabelMenuItem(MenuScene *Owner, SharedMenuItemInfo Parent):
		BaseClass(Owner, Parent) {
		m_Type = MenuItemType::Label;
	}

	bool Load(xml_node root) {
		if (!BaseClass::Load(root))
			return false;
		return true;
	}

	bool BuildItemGUI(GUI::Widgets::Panel *parent) override {
		auto l = new MenuLabel(m_OwnerScene, shared_from_this(), parent);
		m_Widget = l;
		l->SetUtf8Text(GetCaption());
		l->SetTextAlignMode(GUI::TextAlignMode::Middle);
		l->SetAlignMode(GUI::AlignMode::Parent);
		parent->AddWidget(l);
		l->SetEnabled(false);

		return true;
	}

	static void RegisterScriptApi(ApiInitializer &api) {
		api
			.deriveClass<ThisClass, BaseClass>("cMenuSceneLabelItem")
			.endClass();
	}
};

GABI_IMPLEMENT_STATIC_CLASS(LabelMenuItem);
RegisterApiDerivedClass(LabelMenuItem, &ButtonMenuItem::RegisterScriptApi);

//----------------------------------------------------------------

GABI_IMPLEMENT_STATIC_CLASS(SubMenuItem);
RegisterApiDerivedClass(SubMenuItem, &SubMenuItem::RegisterScriptApi);

SubMenuItem::SubMenuItem(MenuScene *Owner, SharedMenuItemInfo Parent):
		BaseClass(Owner, Parent) {
	m_Type = MenuItemType::Menu;
}

void SubMenuItem::RegisterScriptApi(ApiInitializer &api) {
	api
	.deriveClass<ThisClass, BaseClass>("cMenuSceneSubItem")
	.endClass();
}

bool SubMenuItem::BuildItemGUI(GUI::Widgets::Panel *parent) {
	auto l = new MenuLabel(m_OwnerScene, shared_from_this(), parent);
	m_Widget = l;
	l->SetUtf8Text(GetCaption());
	l->SetTextAlignMode(GUI::TextAlignMode::Middle);
	l->SetAlignMode(GUI::AlignMode::Parent);
	parent->AddWidget(l);
	return true;
}

bool SubMenuItem::Load(xml_node root) {
	if (!BaseClass::Load(root))
		return false;

	XML::ForEachChild(root.child("SubMenu"), "Item", [this](xml_node node)->int {
		auto type = MenuItemTypeEnum::ConvertSafe(node.attribute("Type").as_string(0));
		auto parent = this->shared_from_this();
		SharedMenuItemInfo item;
		switch (type) {
		case MenuItemType::Menu:
			item = std::make_shared<ThisClass>(m_OwnerScene, parent);
			break;			
		case MenuItemType::Return:
			item = std::make_shared<GoBackMenuItem>(m_OwnerScene, parent);
			break;
		case MenuItemType::List:
			item = std::make_shared<ListMenuItem>(m_OwnerScene, parent);
			break;
		case MenuItemType::Button:
			item = std::make_shared<ButtonMenuItem>(m_OwnerScene, parent);
			break;
		case MenuItemType::CheckBox:
			item = std::make_shared<CheckBoxMenuItem>(m_OwnerScene, parent);
			break;
		case MenuItemType::SteppedProgressBar:
			item = std::make_shared<SteppedBarMenuItem>(m_OwnerScene, parent);
			break;
		case MenuItemType::Label:
			item = std::make_shared<LabelMenuItem>(m_OwnerScene, parent);
			break;
		default:
			AddLog(Error, "Unknown menu item!");
			return false;
		}

		if (!item->Load(node)) {
			AddLog(Warning, "Unable to load menu item. Ignored.");
			return 0;
		}
		m_ChildItems->push_back(item);
		return 0;
	});
	return true;
}

void SubMenuItem::HandleMouseUp(const GUI::Events::MouseUpEvent& ev, int WidgetID) {
	m_OwnerScene->EnterMenu(shared_from_this());
}

//----------------------------------------------------------------

} //namespace MenuScene 
} //namespace Modules 
} //namespace MoonGlare 
