/*
	Generated by cppsrc.sh
	On 2014-12-29 18:46:32,92
	by Paweu
*/
#include <pch.h>
#include <MoonGlare.h>

namespace Physics {

GABI_IMPLEMENT_ABSTRACT_CLASS(ShapeSubBase);

//----------------------------------------------------------------

GABI_IMPLEMENT_CLASS_NOCREATOR(ShapeConstructor);

ShapeConstructor::ShapeConstructor() {
}

ShapeConstructor::~ShapeConstructor() {
}

ShapeConstructorPtr ShapeConstructor::LoadConstructor(const xml_node node) {
	if (!node) return 0;
	string Class = node.attribute(xmlAttr_Class).as_string("?");
	ShapeConstructor *sc = BodyShapeClassRegister::CreateClass(Class);
	if (!sc) {
		AddLog(Error, "Unable to create body shape constructor of class " << Class);
		return 0; 
	}
	if (!sc->LoadMeta(node)) {
		AddLog(Error, "Unable to load body shape constructor of class " << Class);
		delete sc;
		return 0;
	}
	return ShapeConstructorPtr(sc);
}

bool ShapeConstructor::AddVerticles(const Graphic::VertexVector &verticles) {
	//default implementation
	return true;
}

bool ShapeConstructor::AddTriangles(const Graphic::VertexVector &verticles, const Graphic::IndexVector &index) {
	//default implementation
	return true;
}

void ShapeConstructor::CommonInitShape(SharedShape shape) {
	shape->GetRawShape()->setMargin(0.00001f);
}

//----------------------------------------------------------------

GABI_IMPLEMENT_CLASS_NOCREATOR(BoxShape);
GABI_IMPLEMENT_CLASS(BoxShapeConstructor);
BodyShapeClassRegister::Register<BoxShapeConstructor> BoxShapeConstructorReg("BoxShape");

BoxShapeConstructor::BoxShapeConstructor() { }
BoxShapeConstructor::BoxShapeConstructor(const math::vec3 &Edge): m_Edge(Edge) { }
BoxShapeConstructor::~BoxShapeConstructor() { }

SharedShape BoxShapeConstructor::ConstructShape(float Scale) {
	auto it = m_ShapeDatabase.find(Scale);
	if (it != m_ShapeDatabase.end()) {
		return it->second;
	}

	auto NewScale = m_Edge * Scale;
	SharedShape ss(new BoxShape(convert(NewScale)));
	m_ShapeDatabase.insert(std::make_pair(Scale, ss));
	CommonInitShape(ss);
	return ss;
}

bool BoxShapeConstructor::LoadMeta(const xml_node node) {
	if (!node) return false;
	if (!XML::ReadVector(node, "Edge", m_Edge)) {
		AddLog(Warning, "Unable to read box edge length!");
		return false;
	}
	m_Edge /= 2.0f;
	return true;
}

//----------------------------------------------------------------

GABI_IMPLEMENT_CLASS_NOCREATOR(SphereShape);
GABI_IMPLEMENT_CLASS(SphereShapeConstructor);
BodyShapeClassRegister::Register<SphereShapeConstructor> SphereShapeConstructorReg("SphereShape");

SphereShapeConstructor::SphereShapeConstructor(float Radius) : m_Radius(Radius) { }
SphereShapeConstructor::~SphereShapeConstructor() { }

SharedShape SphereShapeConstructor::ConstructShape(float Scale) {
	auto it = m_ShapeDatabase.find(Scale);
	if (it != m_ShapeDatabase.end()) {
		return it->second;
	}

	auto R = m_Radius * Scale;
	SharedShape ss(new SphereShape(R));
	m_ShapeDatabase.insert(std::make_pair(Scale, ss));
	CommonInitShape(ss);
	return ss;
}

bool SphereShapeConstructor::LoadMeta(const xml_node node) {
	if (!node) return false;
	if (!XML::ReadExistingChildAttribute(node, "Radius", "Value", m_Radius)) {
		if (!XML::ReadExistingChildAttribute(node, "Diameter", "Value", m_Radius)) {
			AddLog(Warning, "Unable to read shpere radius!");
			return false;
		}
		m_Radius /= 2.0f;
	}
	return true;
}
//----------------------------------------------------------------

GABI_IMPLEMENT_CLASS_NOCREATOR(CapsuleShapeShape);
GABI_IMPLEMENT_CLASS(CapsuleShapeConstructor);
BodyShapeClassRegister::Register<CapsuleShapeConstructor> CapsuleShapeConstructorReg("CapsuleShape");

CapsuleShapeConstructor::CapsuleShapeConstructor(float Radius, float Height):
		m_Radius(Radius),
		m_Height(Height) { 
}
CapsuleShapeConstructor::~CapsuleShapeConstructor() { }

SharedShape CapsuleShapeConstructor::ConstructShape(float Scale) {
	auto it = m_ShapeDatabase.find(Scale);
	if (it != m_ShapeDatabase.end()) {
		return it->second;
	}

	auto NewH = m_Height * Scale;
	auto NewR = m_Radius * Scale;
	SharedShape ss(new CapsuleShapeShape(NewR, NewH));
	m_ShapeDatabase.insert(std::make_pair(Scale, ss));
	CommonInitShape(ss);
	return ss;
}

bool CapsuleShapeConstructor::LoadMeta(const xml_node node) {
	if (!node) return false;
	
	bool success = true;
	success &= XML::ReadExistingAttribute(node, "Radius", m_Radius);
	success &= XML::ReadExistingAttribute(node, "Height", m_Height);

	if (!success) {
		AddLog(Error, "Unable to read capsule shape configuration!");
		return false;
	}

	return true;
}

//----------------------------------------------------------------

GABI_IMPLEMENT_CLASS_NOCREATOR(CylinderShapeShape);
GABI_IMPLEMENT_CLASS(CylinderShapeConstructor);
BodyShapeClassRegister::Register<CylinderShapeConstructor> CylinderShapeConstructorReg("CylinderShape");

CylinderShapeConstructor::CylinderShapeConstructor(float Radius, float Height):
		m_Radius(Radius),
		m_Height(Height) { 
}
CylinderShapeConstructor::~CylinderShapeConstructor() { }

SharedShape CylinderShapeConstructor::ConstructShape(float Scale) {
	auto it = m_ShapeDatabase.find(Scale);
	if (it != m_ShapeDatabase.end()) {
		return it->second;
	}

	auto NewH = m_Height * Scale / 2.0f;
	auto NewR = m_Radius * Scale;
	SharedShape ss(new CylinderShapeShape(vec3(NewH, NewH, NewR)));
	m_ShapeDatabase.insert(std::make_pair(Scale, ss));
	CommonInitShape(ss);
	return ss;
}

bool CylinderShapeConstructor::LoadMeta(const xml_node node) {
	if (!node) return false;
	
	bool success = true;
	success &= XML::ReadExistingAttribute(node, "Radius", m_Radius);
	success &= XML::ReadExistingAttribute(node, "Height", m_Height);

	if (!success) {
		AddLog(Error, "Unable to read capsule shape configuration!");
		return false;
	}

	return true;
}

//----------------------------------------------------------------

GABI_IMPLEMENT_CLASS_NOCREATOR(ConvexMeshShape);

ConvexMeshShape::ConvexMeshShape(const Graphic::VertexVector &verticles):
		btConvexHullShape(&verticles[0][0], verticles.size(), sizeof(verticles[0])) {
}

//---

GABI_IMPLEMENT_CLASS(ConvexMeshShapeConstructor);
BodyShapeClassRegister::Register<ConvexMeshShapeConstructor> ConvexMeshShapeConstructorReg("ConvexHullMesh");

ConvexMeshShapeConstructor::ConvexMeshShapeConstructor() { }
ConvexMeshShapeConstructor::~ConvexMeshShapeConstructor() { }

SharedShape ConvexMeshShapeConstructor::ConstructShape(float Scale) {
	if (Scale - 1.0f > 0.0001) {
		AddLog(Warning, "ConvexMeshShapeConstructor does not support mesh scaling!");
	}
	return m_Shape;
}

bool ConvexMeshShapeConstructor::LoadMeta(const xml_node node) {
	if (!node) return false;
	//nothing there
	return true;
}

bool ConvexMeshShapeConstructor::AddVerticles(const Graphic::VertexVector &verticles) {
	if (verticles.empty()) {
		m_Shape.reset();
		return false;
	}
	auto *s = new ConvexMeshShape(verticles);
	s->setMargin(0.001f);
	m_Shape.reset(s);
	CommonInitShape(m_Shape);
	return true;
}

bool ConvexMeshShapeConstructor::AddTriangles(const Graphic::VertexVector &verticles, const Graphic::IndexVector &index) {
	return AddVerticles(verticles);
}

//----------------------------------------------------------------

GABI_IMPLEMENT_CLASS_NOCREATOR(TriangleMeshShape);
GABI_IMPLEMENT_CLASS(TriangleMeshShapeConstructor);
BodyShapeClassRegister::Register<TriangleMeshShapeConstructor> TriangleMeshShapeConstructorReg("TriangleMesh");

void TriangleMeshShape::CalculateLocalInertia(float mass, vec3 &Inertia) const {
	//calculateLocalInertia(mass, Inertia);
	mass /= 1000.0f;
	Inertia.setValue(mass, mass, mass);
}

TriangleMeshShapeConstructor::TriangleMeshShapeConstructor() {
}

TriangleMeshShapeConstructor::~TriangleMeshShapeConstructor() {
}

SharedShape TriangleMeshShapeConstructor::ConstructShape(float Scale) {
	if (Scale - 1.0f > 0.0001) {
		AddLog(Warning, "TriangleMeshShapeConstructor does not support mesh scaling!");
	}
	if (!m_Shape) {
		m_Shape.reset(new TriangleMeshShape(m_mesh.get()));
		CommonInitShape(m_Shape);
	}
	return m_Shape;
}

bool TriangleMeshShapeConstructor::LoadMeta(const xml_node node) {
	return true;
}

bool TriangleMeshShapeConstructor::AddVerticles(const Graphic::VertexVector &verticles) {
	AddLog(Warning, "Attempt to feed TriangleMeshShapeConstructor with points. Nothing was generated!");
	return false;
}

bool TriangleMeshShapeConstructor::AddTriangles(const Graphic::VertexVector &verticles, const Graphic::IndexVector &index) {
	if (!m_mesh)
		m_mesh.reset(new btTriangleMesh());

	for (size_t i = 0; i < index.size(); i += 3) {
		const unsigned *idx = &index[i];

		vec3 p1 = convert(verticles[idx[0]]);
		vec3 p2 = convert(verticles[idx[1]]);
		vec3 p3 = convert(verticles[idx[2]]);

		m_mesh->addTriangle(p1, p2, p3);

	}
	return true;
}

} //namespace Physics 
