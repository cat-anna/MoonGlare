/*
  * Generated by cppsrc.sh
  * On 2015-02-24 13:06:08,58
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include <pch.h>
#include <MoonGlare.h>

namespace MoonGlare {
namespace FileSystem {

	
const DataPathsTable DataSubPaths;

DataPathsTable::DataPathsTable() {
#define _at(X) m_table[(unsigned)DataPath::X] 
	_at(Root)		= "";
	_at(Maps)		= xmlModuleNode_Maps;
	_at(Models)		= xmlModuleNode_Models;
	_at(Fonts)		= xmlModuleNode_Fonts;
	_at(Scenes)		= xmlModuleNode_Scenes;
	_at(Shaders)	= xmlModuleNode_Shaders;
	_at(Scripts)	= xmlModuleNode_Scripts;
	_at(Sounds)		= xmlModuleNode_Sounds;
	_at(Music)		= xmlModuleNode_Music;
	_at(Texture)	= "Textures";
	_at(Tables)		= "Tables";
	_at(Objects)	= "Objects";
	
	_at(XML) = "XML";
#undef _at
}
	
void DataPathsTable::Translate(string& out, const string& in, DataPath origin) const {
	out.clear();
	out.reserve(StaticSettings::FileSystem::PathReserve);

	if (origin != DataPath::Root) {
		out += '/';
		out += m_table[(unsigned)origin];
		out += '/';
	} else {
		if (in.front() != '/')
			out += '/';
	}
	out += in;
}

void DataPathsTable::Translate(string& out, DataPath origin) const {
	out.clear();
	out.reserve(StaticSettings::FileSystem::PathReserve);

	if (origin != DataPath::Root) {
		out += '/';
		out += m_table[(unsigned)origin];
		out += '/';
	} else {
		out += '/';
	}
}
//-------------------------------------------------------------------------------------------------

GABI_IMPLEMENT_CLASS_SINGLETON(MoonGlareFileSystem)
RegisterDebugApi(MoonGlareFileSystem, &MoonGlareFileSystem::RegisterDebugScriptApi, "FileSystem");

MoonGlareFileSystem::MoonGlareFileSystem():
		BaseClass() {
	SetThisAsInstance();
}

MoonGlareFileSystem::~MoonGlareFileSystem() {
}

void MoonGlareFileSystem::RegisterDebugScriptApi(ApiInitializer &api) {
#ifdef DEBUG
	//api
	//.addFunction("SetWireFrameMode", &T::SetWireFrameMode)
	//;
#endif
}

//-------------------------------------------------------------------------------------------------

bool MoonGlareFileSystem::Initialize() {
	return true;
}

bool MoonGlareFileSystem::Finalize() {
	return true;
}

//-------------------------------------------------------------------------------------------------

FileReader MoonGlareFileSystem::OpenFile(const string& FileName, DataPath origin) {
	std::string path;
	DataSubPaths.Translate(path, FileName, origin);

	auto reader = BaseClass::OpenFile(path);
	if (!reader) {
		AddLogf(Warning, "Unable to load file '%s'", path.c_str());
		return nullptr;
	}
	return reader;
}

bool MoonGlareFileSystem::OpenResourceXML(XMLFile &doc, const string& Name, DataPath origin) {
	string buffer;
	buffer.reserve(128);
	switch (origin) {
	case DataPath::Models:
		buffer += Name;
		buffer += "/Model.xml";
		break;
	case DataPath::Maps:
		buffer += Name;
		buffer += "/Map.xml";
		break;
	case DataPath::Scenes:
	case DataPath::Shaders:
	case DataPath::Fonts:
	case DataPath::Objects:
	default:
		buffer += Name;
		buffer += ".xml";
		break;
	}
	return OpenXML(doc, buffer, origin);
}

bool MoonGlareFileSystem::OpenXML(XMLFile &doc, const string& FileName, DataPath origin) {
	std::string path;
	DataSubPaths.Translate(path, FileName, origin);
	return BaseClass::OpenXML(doc, path);
}

//-------------------------------------------------------------------------------------------------

bool MoonGlareFileSystem::OpenTexture(Graphic::Texture &tex, const string& FileName, DataPath origin, bool ApplyDefaultSettings) {
	auto file = OpenFile(FileName, origin);
	if (!file) {
		AddLogf(Error, "Unable to open texture '%s'", FileName.c_str());
		return false;
	}
	if (DataClasses::Texture::LoadTexture(tex, file, ApplyDefaultSettings)) {
		return true;
	}
	return false;
}

bool MoonGlareFileSystem::OpenTexture(TextureFile &tex, const string& FileName, DataPath origin, bool ApplyDefaultSettings) {
	auto file = OpenFile(FileName, origin);
	if (!file) {
		tex.reset();
		AddLogf(Error, "Unable to open texture '%s'", FileName.c_str());
		return false;
	}
	tex = std::make_unique<Graphic::Texture>();
	if (DataClasses::Texture::LoadTexture(*tex.get(), file, ApplyDefaultSettings)) {
		return true;
	}
	tex.reset();
	return false;
}

//----------------------------------------------------------------------------------

bool MoonGlareFileSystem::EnumerateFolder(DataPath origin, FileTable &files) {
	string path;
	DataSubPaths.Translate(path, origin);
	return BaseClass::EnumerateFolder(path, files);
}

bool MoonGlareFileSystem::EnumerateFolder(DataPath origin, const string& subpath, FileTable &files) {
	string path;
	DataSubPaths.Translate(path, subpath, origin);
	return BaseClass::EnumerateFolder(path, files);
}

//----------------------------------------------------------------------------------

void MoonGlareFileSystem::OnModuleLoad(iContainer *container, unsigned LoadFlags) {
	BaseClass::OnModuleLoad(container, LoadFlags);

	AddLog(TODO, "Check if container contain module metadata");

	auto module = std::make_unique<DataClasses::DataModule>(container);

	if (!GetDataMgr()->ImportModule(module)) {
		AddLog(Error, "Unable to import data  module");
	} else {
		AddLogf(Hint, "Container '%s' has been imported", container->GetFileName().c_str());
	}
}

InternalFileSystem::ContainerPrecheckStatus MoonGlareFileSystem::OnBeforeContainerAppend(iContainer *container, unsigned LoadFlags) {
	//querry module
	//TODO: ?	
	return ContainerPrecheckStatus::Append;
}

//----------------------------------------------------------------------------------

GABI_IMPLEMENT_STATIC_CLASS(DirectoryReader);
RegisterApiDerivedClass(DirectoryReader, &DirectoryReader::RegisterScriptApi);

void DirectoryReader::RegisterScriptApi(ApiInitializer &api) {
	api
	.deriveClass<ThisClass, BaseClass>("cDirectoryReader")
		//.addFunction("GetDataReader", &ThisClass::GetDataReader)
	.endClass()
	;
}

} //namespace FileSystem 
} //namespace MoonGlare 
