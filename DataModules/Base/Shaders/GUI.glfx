#include "Common.glsl"

uniform sampler2D Texture0;

uniform vec4 gBaseColor;

vec4 ProcessBaseColor(vec4 fragment)
{
	fragment *= gBaseColor.a;
	fragment.xyz = fragment.xyz * gBaseColor.xyz;
	return fragment;
}

//---------------------------------------------------------------------------------------

uniform vec2 gPanelSize;
uniform float gPanelAspect;
uniform ivec2 gTileMode;
uniform float gPanelBorder;

interface PanelVSOutput {
	vec2 VertexPosition;
};

const float TextureDivs = 3.0f;
const float TextureRatio = 1.0f / TextureDivs;

float ProcessTile(float pos, int TileMode, float Border) {
	if(TileMode == 0) {
		return pos;
	} else {
		float InvBorder = 1.0f / Border;
		float BorderRatio = InvBorder / 3.0f;

		if (pos < Border) {
			return pos * BorderRatio;
		} else {
			if (pos >= 1.0f - Border){
				return (1.0f - pos) * BorderRatio;
			} else {
				float d = (pos - Border) / (1.0f - 2 * Border);
				if(TileMode < 0) {
					if(InvBorder > TextureDivs)
						d *= int(InvBorder) - TextureDivs + 1.0f;
				} else {
					d *= TileMode;
				}
				d -= int(d);

				return TextureRatio * ( 1.0f + d);
			}
		}
	}

	return pos;//bug catcher, shall not reach here
}

shader PanelVSmain(in vec3 Pos : 0, in vec2 TexCoord : 1, out PanelVSOutput VSout) {
	vec4 vpos = WorldMatrix * vec4(Pos, 1.0);
	gl_Position = vpos;
	if ( gTileMode.x == 0 ){
		VSout.VertexPosition.x = TexCoord.x;
	} else {
		VSout.VertexPosition.x = Pos.x / gPanelSize.x;
	}
	if ( gTileMode.y == 0 ){
		VSout.VertexPosition.y = TexCoord.y;
	} else {
		VSout.VertexPosition.y = Pos.y / gPanelSize.y;
	}
};

shader PanelFSmain(in PanelVSOutput FSin, out vec4 FragColor) {
	vec2 posin = FSin.VertexPosition;

	vec2 tex;
	tex.x = ProcessTile(posin.x, gTileMode.x, gPanelBorder / gPanelAspect);
	tex.y = ProcessTile(posin.y, gTileMode.y, gPanelBorder);

	FragColor = ProcessBaseColor(vec4(texture2D(Texture0, tex)));
};

program Panel {
	vs(330) = PanelVSmain();
	fs(330) = PanelFSmain();
};
