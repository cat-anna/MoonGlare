/*
  * Generated by cppsrc.sh
  * On 2015-06-10 17:04:03,22
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef InternalFileSystem_H
#define InternalFileSystem_H

namespace MoonGlare {
namespace FileSystem {

class iContainer;
using Container = std::unique_ptr < iContainer > ;

class iFileReader;
using FileReader = std::shared_ptr < iFileReader > ;

class iFileWritter;
using FileWritter = std::shared_ptr < iFileWritter > ;

using FileSize = unsigned __int32;

struct InternalFilePointer;
struct InternalFileNode;

using XML = std::unique_ptr < xml_document > ;

enum class FileType {
	File,
	Directory,
};

struct FileInfo {
	string Name;
	FileType Type;
};
using FileTable = std::vector < FileInfo > ;

enum class InternalContainerImportPriority { 
	Primary, Major, Minor, Subsidiary, 
};

/*
DEFINES in code
	INTERNAL_FILE_SYSTEM_NO_CASE_SENSITIVE
	INTERNAL_FILE_SYSTEM_NO_WINDOWS_PATH_SUPPORT
*/

class InternalFileSystem : public GabiLib::GabiObject {
	GABI_DECLARE_STATIC_CLASS(InternalFileSystem, GabiLib::GabiObject)
public:
 	InternalFileSystem();
 	virtual ~InternalFileSystem();

	/** Set byte size limit of cached files */
	void SetCachedFilesLimit(FileSize value);
	FileSize GetCachedFilesLimit() const { return m_OpenedFilesSizeLimit;  }

	bool LoadModule(const string& FileName, unsigned LoadFlags = 0);
	/** InternalFileSystem takes ownership of the module */
	bool AppendModule(Container &module, unsigned AppendFlags = 0);
	bool LoadRegisteredContainers(unsigned LoadFlags = 0);

	bool OpenXML(XML &doc, const string& File);
	FileReader OpenFile(const string& File);
	bool EnumerateFolder(const string &RootFolder, FileTable &files);

	FileWritter OpenFileForWrite(const string& File);

	virtual void DumpStructure(std::ostream &out);

	/** Register internal data container with import priority to preserve order. */
	bool RegisterInternalContainer(const InternalFileNode *root, InternalContainerImportPriority Priority);

	enum class Flags {
		RegisteredContainerOpen,
	};
	DefineFlagGetter(m_Flags, FlagBit(Flags::RegisteredContainerOpen), RegisteredContainerOpen);
protected:
	std::recursive_mutex m_Lock;

	InternalFilePointer* InternalOpenFile(const string& File);
	InternalFilePointer *FindPointer(const string &FileName);

	enum class ContainerPrecheckStatus { Append, Discard, };
	virtual void OnModuleLoad(iContainer *container, unsigned LoadFlags);
	virtual ContainerPrecheckStatus OnBeforeContainerAppend(iContainer *container, unsigned LoadFlags);

	virtual void StructureChangedNotification();
	void FlushCache();

	DefineFlagSetter(m_Flags, FlagBit(Flags::RegisteredContainerOpen), RegisteredContainerOpen);
private: 
	using ContainerList = std::list < Container > ;
	using FileCache = std::unordered_map < string, InternalFilePointer* > ;

	std::unique_ptr<InternalFilePointer> m_Root;
	ContainerList m_Containers;
	FileCache m_FileCache;
	std::recursive_mutex m_CacheLock;
	FileSize m_OpenedFilesSizeLimit;
	std::atomic<FileSize> m_CurrentOpenedFilesSize;
	std::atomic<unsigned> m_CurrentOpenedFilesCount;
	unsigned m_Flags;
	std::unique_ptr<std::list<std::pair<const InternalFileNode*, InternalContainerImportPriority>>> m_InternalContainerRegister;

	Container OpenContainer(const string& FileName, unsigned LoadFlags);
	void ShadowFileSystem(iContainer *source);
	void PushFileCache(InternalFilePointer *ptr);
};

} //namespace FileSystem 
} //namespace MoonGlare 

#include "iContainer.h"
#include "iFileReader.h"
#include "iFileWritter.h"

#endif
