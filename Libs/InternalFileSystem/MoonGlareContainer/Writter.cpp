/*
  * Generated by cppsrc.sh
  * On 2015-03-13 23:11:53.79
  * by Immethis
*/
/*--END OF HEADER BLOCK--*/

#include <pch.h>
#include <nfMoonGlare.h>
#include "../InternalFileSystem.h"
#include "nMoonGlareContainer.h"

namespace MoonGlare {
namespace FileSystem {
namespace MoonGlareContainer {

using namespace Headers::CurrentVersion;

struct WritterContainerMeta {
	SectionIndex RawDataIndex;
	SectionIndex StringTableIndex;
	SectionIndex FileTableIndex;
	
	std::vector<SectionHeader> Sections;
	FileFooter Footer;

	DynamicStringTable StringTable;

	SectionHeader& GetRawDataSection() { return Sections[RawDataIndex]; }
	SectionHeader& GetStringTableSection() { return Sections[StringTableIndex]; }
	SectionHeader& GetFileTableSection() { return Sections[FileTableIndex]; }

	WritterContainerMeta() {
		Sections.resize(4);

		RawDataIndex = 1;
		auto &rds = GetRawDataSection();
		rds.Type = SectionType::RawData;

		StringTableIndex = 2;
		auto &sts = GetStringTableSection();
		sts.Type = SectionType::StringTable;

		FileTableIndex = 3;
		auto &fts = GetFileTableSection();
		fts.Type = SectionType::FileTable;
	}
};

//-------------------------------------------------------------------------------------------------

struct WritterFileNode : public FileNode {
	FilePointer StringTablePointer;
	UniqueCharTable Bytes;

	std::list<WritterFileNode*> Children;

	volatile bool Stored = false;

	bool ValidIndex = false;
	Headers::CurrentVersion::FileIndex FileIndex = 0;
};

//-------------------------------------------------------------------------------------------------

class ContainerFileWritter : public iFileWritter {
	GABI_DECLARE_STATIC_CLASS(ContainerFileWritter, iFileWritter);
public:
	ContainerFileWritter(Writter *Owner, WritterFileNode *File) :
			BaseClass(Owner), 
			m_Owner(Owner),
			m_File(File) {
	}
	~ContainerFileWritter() { 
		m_Owner->StoreFile(m_File);
	}

	bool SetFileData(const char* data, FileSize size) override { 
		m_File->Bytes.reset(new char[size + 1]);
		m_File->Bytes[size] = 0;
		memcpy(m_File->Bytes.get(), data, size);
		m_File->DataBlock.RealSize = size;
		return true;
	}
	bool OwnData(std::unique_ptr<char[]> data, FileSize size) override { 
		m_File->Bytes.reset();
		m_File->Bytes.swap(data);
		m_File->DataBlock.RealSize = size;
		return true;
	}

	virtual FileSize Size() const { return m_File->DataBlock.RealSize; }
	virtual const char* GetFileData() const { return m_File->Bytes.get(); }
	virtual const string& FileName() const { return m_File->Name; }
private:
	Writter *m_Owner;
	WritterFileNode *m_File;
};

GABI_IMPLEMENT_STATIC_CLASS(ContainerFileWritter)

//-------------------------------------------------------------------------------------------------

GABI_IMPLEMENT_STATIC_CLASS(Writter)

Writter::Writter(const string &File, const WritterConfiguration *configuration) :
		BaseClass(),
		m_ContainerFile(File),
		m_File(),
		m_Configuration() {
	SetReady(true);
	SetWritable(true);
	m_ContainerMeta = std::make_unique<WritterContainerMeta>();
	m_RootFile.reset(new WritterFileNode());
	m_RootFile->Name = "";
	m_RootFile->Flags.Directory = 1;
	m_RootFile->ValidIndex = true;
	m_RootFile->FileIndex = 0;
	if (configuration)
		m_Configuration = *configuration;
}

Writter::~Writter() {
	CloseContainer();
	m_ContainerMeta.reset();
}

FileReader Writter::GetFileReader(const string& file) const {
	return nullptr;
}

FileWritter Writter::GetFileWritter(const string& filename) {
	auto file = FindOrAlloc(filename);
	if (file->Stored)
		return nullptr;
	return std::make_shared<ContainerFileWritter>(this, file);
}

bool Writter::StoreFile(WritterFileNode *file, bool CanBeBuffered) {

	if (m_Configuration.BufferingEnabled && CanBeBuffered) {
		auto buffered = GetBufferedCount();
		while (buffered + file->DataBlock.RealSize >= m_Configuration.BufferSizeLimit && !m_BufferedFiles.empty()) {
			auto *f = m_BufferedFiles.front();
			m_BufferedFiles.pop_front();
			StoreFile(f, false);
			buffered = GetBufferedCount();
		}
		m_BufferedFiles.push_back(file);
		AddLog(Debug, "File '" << file->Path() << "' stored in buffer [" << GetBufferedCount() / 1024.0f << "kb in buffer]");
		return true;
	}

	AddLog(Debug, "Storing file '" << file->Path() << "'");

	CreateContainer();

	file->Stored = true;
	file->StringTablePointer = m_ContainerMeta->StringTable.CurrentLocation();
	m_ContainerMeta->StringTable.AddString(file->Name);

	m_File.WriteBlock(file->Bytes, file->DataBlock.RealSize, file->DataBlock);

	return true;
}

bool Writter::FileExists(const string& file) const {
	return false;
}

//-------------------------------------------------------------------------------------------------

bool Writter::CreateContainer() {
	if (m_File)
		return true;

	if (!m_File.open(m_ContainerFile.c_str()))
		throw ContainerException("Unable to open file '%s'", m_ContainerFile.c_str());

	Headers::FileHeader header;
	header.Version = Headers::CurrentVersion::Version::Value;

	if (!m_File.write(&header, sizeof(header)))
		throw ContainerException("Unable to write file header!");

	auto &rds = m_ContainerMeta->GetRawDataSection();
	rds.SectionBlock.FilePointer = m_File.WriteLocation();

	return true;
}

bool Writter::CloseContainer() {
	if (!m_File) return true;

	//write pending files
	{
		while (!m_BufferedFiles.empty()) {
			auto *f = m_BufferedFiles.front();
			m_BufferedFiles.pop_front();
			StoreFile(f, false);
		}

		auto &rds = m_ContainerMeta->GetRawDataSection();
		auto location = m_File.WriteLocation();
		rds.SectionBlock.RealSize = location - rds.SectionBlock.FilePointer;
		rds.SectionBlock.ContainerSize = rds.SectionBlock.RealSize;
	}

	//write file table
	{
		auto &fts = m_ContainerMeta->GetFileTableSection();
		std::unique_ptr<char[]> FileTable;
		Headers::u32 byteSize = sizeof(Headers::CurrentVersion::FileTableSection);
		unsigned FileEntryCount = static_cast<unsigned>(m_FileList.size());
		byteSize += FileEntryCount * sizeof(Headers::CurrentVersion::FileTableEntry);
		auto *section = (Headers::CurrentVersion::FileTableSection*) new char[byteSize];
		memset(section, 0, byteSize);

		FileTable.reset((char*)section);

		std::list<WritterFileNode*> processlist;
		for (auto &it : m_FileList)
			processlist.push_back(it.get());

		for (unsigned i = 0; i < FileEntryCount; ++i)
			section->Table[i].Flags = Headers::CurrentVersion::FileTableEntryFlags::InvalidEntry;

		section->Count = FileEntryCount;
		section->RawDataSection = m_ContainerMeta->RawDataIndex;
		section->StringTableSection = m_ContainerMeta->StringTableIndex;

		unsigned CurrentIndex = 0;

		AddLog(Debug, "Generating file table");
		while (!processlist.empty()) {
			auto *file = processlist.front();
			processlist.pop_front();
			if (!file->Parent) {
				AddLog(Error, "Parentless file entry '" << file->Path() << "'");
				continue;
			}
			WritterFileNode *parent = (WritterFileNode*)file->Parent;
			if (!parent->ValidIndex) {
				processlist.push_back(file);
				continue;
			}
			auto & entry = section->Table[CurrentIndex];
			++CurrentIndex;
			file->FileIndex = CurrentIndex;
			file->ValidIndex = true;

			if (!file->Stored) {
				if (file->Flags.Directory) {
					file->Stored = true;
					file->StringTablePointer = m_ContainerMeta->StringTable.CurrentLocation();
					m_ContainerMeta->StringTable.AddString(file->Name);
				}
			}

			entry.Flags &= ~Headers::CurrentVersion::FileTableEntryFlags::InvalidEntry;
			if (file->Flags.Directory)
				entry.Flags |= Headers::CurrentVersion::FileTableEntryFlags::Folder;

			entry.FileBlock = file->DataBlock;
			entry.NamePointer = file->StringTablePointer;
			entry.ParentIndex = parent->FileIndex;
		}

		m_File.WriteBlock(FileTable, byteSize, fts.SectionBlock);
	}

	//write string table
	{
		auto &sts = m_ContainerMeta->GetStringTableSection();
		auto table = m_ContainerMeta->StringTable.GetBytes();
		auto tablesize = m_ContainerMeta->StringTable.ByteSize();
		m_File.WriteBlock(table.get(), tablesize, sts.SectionBlock);
	}

	//write section table
	{
		m_ContainerMeta->Footer.SectionCount = static_cast<SectionIndex>(m_ContainerMeta->Sections.size());
		m_File.WriteStructBlock(&m_ContainerMeta->Sections[0], m_ContainerMeta->Footer.SectionsBlock, m_ContainerMeta->Footer.SectionCount);
	}

	//write file footer
	if (!m_File.write(&m_ContainerMeta->Footer, sizeof(m_ContainerMeta->Footer)))
		throw ContainerException("Unable to write file footer!");

	m_File.close();
	return true;
}

WritterFileNode* Writter::FindOrAlloc(const string& FileName) {
	WritterFileNode *ptr = m_RootFile.get();

	const char* p = FileName.c_str();
	for (;;){
		while (*p == '\\' || *p == '/') ++p;
		const char* next = strchr(p, '\\');
		if (!next) next = strchr(p, '/');
		try{
			auto it = ptr->Children.begin();
			auto jt = ptr->Children.end();
			for (; it != jt; ++it){
				WritterFileNode *i = *it;
				const char* s = p;
				const char* t = i->Name.c_str();
				for (;;){
					if ((*s == '\\' || *s == '/' || !*s) && !*t){
						throw i;
					}
					if ((*s | 0x20) != (*t | 0x20)) break;
					++s;
					++t;
				}
			}
			if (!next) {
				m_FileList.emplace_back();
				m_FileList.back().reset(new WritterFileNode());
				auto *newf = m_FileList.back().get();
				newf->Name = string(p);
				newf->Parent = ptr;
				AddLog(Debug, "Allocated file in container: " << newf->Name);
				return newf;
			}
			else 
			{
				m_FileList.emplace_back();
				m_FileList.back().reset(new WritterFileNode());
				auto *newf = m_FileList.back().get();
				newf->Flags.Directory = 1;
				newf->Name = string(p, next - p);
				newf->Parent = ptr;
				ptr->Children.push_back(newf);
				ptr = newf;
				p = next + 1;
				AddLog(Debug, "Allocated directory in container: " << newf->Name);
				continue;
			}
		}
		catch (WritterFileNode *i){
			if (!next) return i;
			p = next + 1;
			ptr = i;
			continue;
		}
	}
}

Headers::CurrentVersion::Size Writter::GetBufferedCount() {
	Headers::CurrentVersion::Size s = 0;
	for (auto *it : m_BufferedFiles)
		s += it->DataBlock.RealSize;
	return s;
}

} //namespace MoonGlareContainer 
} //namespace FileSystem 
} //namespace MoonGlare 
