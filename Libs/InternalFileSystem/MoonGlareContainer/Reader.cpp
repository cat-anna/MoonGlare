/*
  * Generated by cppsrc.sh
  * On 2015-03-13 23:11:22.87
  * by Immethis
*/
/*--END OF HEADER BLOCK--*/

#include <pch.h>
#include <nfMoonGlare.h>
#include "../InternalFileSystem.h"
#include "nMoonGlareContainer.h"
#include "ReaderFile.h"

namespace MoonGlare {
namespace FileSystem {
namespace MoonGlareContainer {

using namespace Headers::CurrentVersion;

//-------------------------------------------------------------------------------------------------

class RDCFileReader : public iFileReader {
	GABI_DECLARE_CLASS_NOCREATOR(RDCFileReader, iFileReader);
public:
	RDCFileReader(iContainer *Owner, const ReaderFile* file): BaseClass(Owner), m_File(file) { }
	~RDCFileReader() { }

	virtual FileSize Size() const override { return m_File->DataBlock.RealSize; }
	virtual const char* GetFileData() const override { 
		if (!m_Data) {
			((Reader*)GetOwner())->ReadBlock(m_Data, m_File->DataBlock);
		}
		return &m_Data[0]; 
	}
	virtual const string& FileName() const override { return m_File->Name; }
private:
	const ReaderFile* m_File;
	mutable UniqueCharTable m_Data;
};

GABI_IMPLEMENT_CLASS_NOCREATOR(RDCFileReader);

//-------------------------------------------------------------------------------------------------

GABI_IMPLEMENT_STATIC_CLASS(Reader)

Reader::Reader(const string &File) :
		BaseClass(),
		m_FileName(File) {
	m_RootFile = AllocFile();
	m_RootFile->Flags.Directory = 1;
	ReaderLoadMeta meta;
	if (OpenContainer(meta)) {
		SetReadable(true);
		SetReady(true);
	} else {
		AddLog(Error, "Unable to open container '" << File << "'");
	}
}

Reader::Reader() :
		BaseClass(),
		m_FileName("bad_file_name") {
	m_RootFile = AllocFile();
	m_RootFile->Flags.Directory = 1;
}

Reader::~Reader() {
	m_File.close();
	m_RootFile = nullptr;
	m_FileTableList.clear();
}

const string& Reader::GetFileName() const {
	return m_FileName;
}

//-------------------------------------------------------------------------------------------------

ReaderFile* Reader::AllocFile() {
	m_FileTableList.emplace_back();
	m_FileTableList.back().reset(new ReaderFile[1]);
	return m_FileTableList.back().get();
}

FileReader Reader::GetFileReader(const ReaderFile *file) const {
	if (!file || file->Flags.Directory)
		return nullptr;
	return std::make_shared<RDCFileReader>(const_cast<Reader*>(this), file);
}

FileReader Reader::GetFileReader(const string& FileName) const {
	auto file = FindFile(FileName);
	if (!file || file->Flags.Directory)
		return nullptr;
	return std::make_shared<RDCFileReader>(const_cast<Reader*>(this), file);
}

bool Reader::EnumerateFolder(const RawFilePointer *root, FolderEnumerateFunc func) const {
	REQUIRE_REIMPLEMENT();
#if 0
	auto file = FindFile(Path);
	if (!file || !file->Flags.Directory)
		return false;

	for (auto it : file->Children) {
		FileType ft;
		if (it->Flags.Directory)
			ft = FileType::Directory;
		else
			ft = FileType::File;
		func(it->Name, ft);
	}
#endif // 0
	return true;
}

bool Reader::FileExists(const string& file) const {
	return FindFile(file) != nullptr;
}

//-------------------------------------------------------------------------------------------------

const ReaderFile* Reader::FindFile(const string &FileName) const {
	ReaderFile *ptr = m_RootFile;

	const char* p = FileName.c_str();
	for (;;) {
		while (*p == '\\' || *p == '/') ++p;
		if (!*p)
			return ptr;
		const char* next = strchr(p, '\\');
		if (!next) next = strchr(p, '/');
		try {
			auto it = ptr->Children.begin();
			auto jt = ptr->Children.end();
			for (; it != jt; ++it) {
				auto &i = *it;
				const char* s = p;
				const char* t = i->Name.c_str();
				for (;;) {
					if ((*s == '\\' || *s == '/' || !*s) && !*t){
						throw i;
					}
					if ((*s | 0x20) != (*t | 0x20)) break;
					++s;
					++t;
				}
			}
			//file not found!
			return nullptr;
		}
		catch (ReaderFile *i) {
			if (!next) return i;
			p = next + 1;
			ptr = i;
			continue;
		}
	}
}

//-------------------------------------------------------------------------------------------------

bool Reader::OpenContainer(ReaderLoadMeta &meta) {
	meta.reset();
	if (!m_File.open(m_FileName.c_str()))
		return false;

	meta.reset(new ReaderLoadMetaStruct());
	m_File.seek_read(0);
	m_File.read(&meta->header, sizeof(meta->header));

	if (meta->header.FileSignature != Headers::Signature::FileHeader) {
		AddLog(Error, "Invalid file signature!");
		m_File.close();
		return false;
	}

	if (meta->header.UserSignature != Headers::Signature::MGCF) {
		AddLog(Error, "Invalid user signature!");
		m_File.close();
		return false;
	}

	if (meta->header.Version != Headers::CurrentVersion::Version::Value) {
		AddLog(Error, "Invalid container version!");
		m_File.close();
		return false;
	}

	m_File.seek_read_back(sizeof(Headers::CurrentVersion::FileFooter));
	meta->Footer.Reset();
	m_File.read(&meta->Footer, sizeof(meta->Footer));

	if (meta->Footer.Signature != Headers::Signature::FileFooter) {
		AddLog(Error, "Invalid footer signature!");
		m_File.close();
		return false;
	}

	try {
		if (!LoadSections(meta)) throw false;
	}
	catch(...) {
		m_File.close();
		return false;
	}
	return true;
}

bool Reader::LoadSections(ReaderLoadMeta &meta) {
	if (!m_File.ReadBlock(meta->SectionsData, meta->Footer.SectionsBlock)) return false;

	meta->Sections = (Headers::CurrentVersion::SectionHeader*)meta->SectionsData.get();
	bool success = true;
	for (Headers::CurrentVersion::SectionIndex i = 0; i < meta->Footer.SectionCount; ++i) {
		switch (meta->Sections[i].Type) {
		case SectionType::EmptyEntry:
			continue;
		case SectionType::FileTable:
			meta->FileTableIndex = i;
			success &= LoadFileStructure(meta);
			continue;
		case SectionType::RawData:
			//nothing todo here
			//meta->RawDataIndex = i;
			continue;
		case SectionType::StringTable:
			//nothing todo here
			//meta->StringTableIndex = i;
			continue;		
		default:
			AddLog(Warning, "Unknown section found in container: " << (unsigned)meta->Sections[i].Type);
			continue;
		}
	}
	return success;
}

bool Reader::LoadStringTable(ReaderLoadMeta &meta) {
	auto &sts = meta->GetStringTableSection();
	UniqueCharTable table;
	if (!m_File.ReadBlock(table, sts.SectionBlock))
		return false;
	meta->StringTable.reset((Headers::Version_0::StringTableSection*)table.release());
	return true;
}

bool Reader::LoadFileStructure(ReaderLoadMeta &meta) {
	auto &fts = meta->GetFileTableSection();

	if (!m_File.ReadBlock(meta->FileTableData, fts.SectionBlock)) {
		AddLog(Error, "Unable to read file table!");
		return false;
	}
	meta->FileTable = (FileTableSection*)meta->FileTableData.get();

	meta->StringTableIndex = meta->FileTable->StringTableSection;
	meta->RawDataIndex = meta->FileTable->RawDataSection;

	if (!LoadStringTable(meta)) {
		AddLog(Error, "Unable to read string table!");
		return false;
	}

	ReaderFile *CurrentFileTable;
	m_FileTableList.emplace_back(CurrentFileTable = new ReaderFile[meta->FileTable->Count]);

	for (unsigned i = 0; i < meta->FileTable->Count; ++i) {
		auto &rawfile = meta->FileTable->Table[i];
		auto &file = CurrentFileTable[i];
		auto &parent = rawfile.ParentIndex > 0 ? CurrentFileTable[rawfile.ParentIndex - 1] : *m_RootFile;
		file.DataBlock = rawfile.FileBlock;
		parent.Children.push_back(&file);
		file.Parent = &parent;
		file.Name = meta->StringTable->Table + rawfile.NamePointer;
		if (rawfile.Flags & Headers::CurrentVersion::FileTableEntryFlags::Folder)
			file.Flags.Directory = 1;
	}

	return true;
}

/*
struct FileTableSection {
	SectionIndex RawDataSection;
	SectionIndex StringTableSection;
	u16 Flags;
	u32 Count;
	FileTableEntry Table[0];
};
*/

} //namespace MoonGlareContainer 
} //namespace FileSystem 
} //namespace MoonGlare 
