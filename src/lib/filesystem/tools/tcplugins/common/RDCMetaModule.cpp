/*
* Generated by cppsrc.sh
* On 2016-01-08 22:38:03,59
* by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include <sstream>
#include <cassert>
#include <iomanip>

#include "RDCMetaModule.h"
#include <core/Container/VirtualFileContainer.h>
#include <core/Container/RDCContainer.h>

//-----------------------------------------------------------------------------

using namespace StarVFS::Containers;
using namespace StarVFS::RDC;

struct RDCMetaModule::Impl {
	VirtualFileContainer *m_Container;
	std::vector<SharedVirtualFileInterface> m_MetaFiles;
	RDCContainer *m_RDC;

	template<class T>
	void AddFile(const char * location) {
		auto f = std::make_shared<T>(m_RDC);
		m_MetaFiles.emplace_back(f);
		m_Container->AddFile(f, location);
	}
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

static char *SizeToString(char *buffer, float value) {
	int mag = 0;
	while (value > 1000.0f) {
		value /= 1024.0f;
		++mag;
	}
	static const char *MagTable[] = {
		"b", "KiB", "MiB", "GiB", "TiB", "?", "?",
	};
	sprintf(buffer, "%.2f %s", value, MagTable[mag]);
	return buffer;
}

template<class ... ARGS>
static char *dofmt(char *buffer, char *fmt, ARGS ... args) {
	sprintf(buffer, fmt, args...);
	return buffer;
}

struct FileHeaderMetaFile : public BaseDynamicFileInterface {
	FileHeaderMetaFile(RDCContainer *RDC) : m_RDC(RDC) {}
	virtual void GenerateContent(std::ostream &out) override {
		if (!m_RDC) {
			out << "Container is not opened!\n";
			return;
		}
		auto rdc = m_RDC->GetRDCReader();
		char buf128[128];

		auto h = rdc->GetHeader();

		out << "Reverse Data Container file header metafile";

		union {
			Signature sign;
			char t[4];
		} sign;
		sign.sign = h.FileSignature;

		out << dofmt(buf128, "Signature: %c%c%c%c\n", sign.t[0], sign.t[1], sign.t[2], sign.t[3]);
		out << dofmt(buf128, "Version %d.%02d\n", h.Version.Major, h.Version.Minor);
		out << dofmt(buf128, "Flags:\n");

		out << "\n";
	}
private:
	RDCContainer *m_RDC;
};

struct SectionsMetaFile : public BaseDynamicFileInterface {
	SectionsMetaFile(RDCContainer *RDC) : m_RDC(RDC) {
	}
	virtual void GenerateContent(std::ostream &out) override {
		if (!m_RDC) {
			out << "Container is not opened!\n";
			return;
		}
		auto rdc = m_RDC->GetRDCReader();

		auto &sections = rdc->GetSections();

		out << "Reverse Data Container section table meta file\n";
		out << "Container has " << sections.size() << " sections\n\n";

		for (size_t i = 0, j = sections.size(); i < j;++i) {
			auto &it = sections[i];
			char buf128[128];
			char buf128_2[128];

			using SectionType = StarVFS::RDC::SectionType;
			const char *stype = "Unknown";
			switch (it.Type) {
			case SectionType::EmptyEntry: stype = "Empty section"; break;
			case SectionType::MountEntry: stype = "Mount entry section"; break;
			case SectionType::RawData: stype = "Raw data section"; break;
			case SectionType::OffsetDataBlockTable: stype = "Offset datablock section"; break;
			case SectionType::StringTable: stype = "String table section"; break;
			case SectionType::FileStructureTable: stype = "File structure section"; break;
			case SectionType::HashTable: stype = "Hash section"; break;
			}
			auto RawSize = it.SectionBlock.GetRawSize();

			out << "Section " << i << "\n";
			out << dofmt(buf128, "Type:  %d (0x%02x) (%s)\n", (int)it.Type, (int)it.Type, stype);
			out << dofmt(buf128, "Location: %x\n", (int)it.SectionBlock.FilePointer);
			out << dofmt(buf128, "Size: %u bytes (%s)\n", (unsigned)RawSize, SizeToString(buf128_2, (float)RawSize));
			if (RawSize != it.SectionBlock.ContainerSize) {
				auto csize = it.SectionBlock.ContainerSize;
				out << dofmt(buf128, "Container size: %u bytes (%s)\n", (unsigned)csize, SizeToString(buf128_2, (float)csize));
			}
			if (it.SectionBlock.Compression.Mode != CompressionMode::None) {
				const char *cmode = "Unknown";
				switch (it.SectionBlock.Compression.Mode) {
				case CompressionMode::ZLib: cmode = "Zlib"; break;
				default:
					break;
				}

				out << dofmt(buf128, "Compression mode: 0x%02x (%s)\n", (int)it.SectionBlock.Compression.Mode, cmode);
				out << dofmt(buf128, "Compression level: %d\n", (int)it.SectionBlock.Compression.Level);
				float ratio = (float)it.SectionBlock.ContainerSize / (float)RawSize;
				out << dofmt(buf128, "Compression ratio: %.1f%%\n", ratio * 100.0f);
			}
			out << "\n";
		}
	}
private:
	RDCContainer *m_RDC;
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

RDCMetaModule::RDCMetaModule(StarVFS::StarVFS *svfs, RDCContainer *RDC) : StarVFS::Modules::iModule(svfs) {
	m_Impl = std::make_unique<Impl>();
	m_Impl->m_RDC = RDC;
}

RDCMetaModule::~RDCMetaModule() {
}

//-------------------------------------------------------------------------------------------------

bool RDCMetaModule::Enable() {
	if (m_Impl->m_Container)
		return true;

	auto ret = GetVFS()->CreateContainer<VirtualFileContainer>("/");
	if (!ret.second)
		return false;
	m_Impl->m_Container = dynamic_cast<VirtualFileContainer*>(ret.second);
	if (!m_Impl->m_Container)
		return false;

	m_Impl->AddFile<FileHeaderMetaFile>("/$Meta/$FileHeader");
	m_Impl->AddFile<SectionsMetaFile>("/$Meta/$SectionTable");

	return true;
}

bool RDCMetaModule::Disable() {
	if (m_Impl->m_Container)
		return true;

	m_Impl->m_MetaFiles.clear();

	//	m_MetaContainer = nullptr;
	return false;
}

//-----------------------------------------------------------------------------
