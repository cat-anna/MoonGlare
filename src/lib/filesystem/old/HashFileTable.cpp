/*
  * Generated by cppsrc.sh
  * On 2015-12-14  7:26:50,12
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include "StarVFSInternal.h"
#include <algorithm>

namespace StarVFS {

HashFileTable::HashFileTable() {
	m_Capacity = m_Allocated = m_MaxIndex = 0;
	m_Flags.intval = 0;
	m_Memory = nullptr;
	m_HashTable = nullptr;
	m_FileIDTable = nullptr;

	Resize(Settings::Initial::FileTableSize);
}

HashFileTable::~HashFileTable() {
	m_HashTable = nullptr;
	m_FileIDTable = nullptr;
	m_Capacity = m_Allocated = m_MaxIndex = 0;
	m_Memory.reset();
}

//-------------------------------------------------------------------------------------------------

FileID HashFileTable::Lookup(FilePathHash Hash) {
	//auto end = m_HashTable + m_Allocated;

	//printf("Lookup: %08x\n", Hash);
	//
	//for (FileID i = 1; i <= m_MaxIndex; ) {
	//	auto val = m_HashTable[i - 1];
	//	if (val == Hash)
	//		return m_FileIDTable[i - 1];
	//	if (val < Hash)
	//		i = 2 * i;
	//	else
	//		i = 2 * i + 1;
	//}
	//return 0;

	auto end = m_HashTable + m_Allocated;
	auto where = std::lower_bound(m_HashTable, end, Hash);
	if (end == where || *where != Hash)
		return 0;
	return m_FileIDTable[where - m_HashTable];
}

void HashFileTable::HeapPush(FileID fid, FilePathHash Hash) {

	FileID nid = 1;

	for ( ; ; ) {
		if (nid >= m_Capacity) {
			STARVFSDebugLog("out of capacity %d", nid);
			Resize(m_Capacity * 2);
		}

		if (nid > m_MaxIndex) {
			m_MaxIndex = nid;
			break;
		}

		if (m_FileIDTable[nid - 1] == 0) {
			break;
		}

		auto val = m_HashTable[nid - 1];
		if (val < Hash)
			nid = nid * 2;
		else
			nid = nid * 2 + 1;
	}

	--nid;
	m_HashTable[nid] = Hash;
	m_FileIDTable[nid] = fid;
}

void HashFileTable::Add(File* f, bool Rebuild) {
	StarVFSAssert(f);

//	if (Rebuild) {
//		m_Allocated++;
//		HeapPush(f->m_GlobalFileID, f->m_Hash);
//	} else {
//		auto nid = m_Allocated++;
//		while (m_FileIDTable[nid])
//			++nid;
//		m_HashTable[nid] = f->m_Hash;
//		m_FileIDTable[nid] = f->m_GlobalFileID;
//		m_Flags.Broken = 1;
//	}

//
//	printf("Insert: %08x\n", f->m_Hash);
//
//	if (!nid)
//		return;
//
//	++nid;
//	for (; nid > 1; ) {
//		FileID parent = nid / 2;
//
//		if (m_HashTable[parent - 1] > m_HashTable[nid - 1])
//			HashSwap(parent - 1, nid - 1);
//
//		nid = parent;
//	}

//	for (FileID i = 0; i < m_MaxIndex;++i)
//		if(m_HashTable[i])
//			printf("hash: %3d. %08x -> %d\n", i, m_HashTable[i], m_FileIDTable[i]);

//	while ((nid > 0) && (parent(index) >= 0) && (heap[parent(index)] > heap[index])) {
//
//		int tmp = heap[parent(index)];
//		heap[parent(index)] = heap[index];
//		heap[index] = tmp;
//
//		index = parent(index);
//	}

	if (Rebuild && m_Allocated > 0) {

		auto where = std::lower_bound(m_HashTable, m_HashTable + m_Allocated, f->m_Hash);
		int rawnid = where - m_HashTable;
		if (rawnid < 0) {
			//todo: do sth?
		}
		FileID nid = static_cast<FileID>(rawnid);

		auto collision = m_FileIDTable[nid];
		if (collision == f->m_GlobalFileID) {
			STARVFSDebugLog("Adding existing file (%d)", f->m_GlobalFileID);
			return;
		}
		if (*where == f->m_Hash) {
			STARVFSErrorLog("Hash collision! %08x (id %d & %d)", f->m_Hash, f->m_GlobalFileID, collision);
			return;
		}
		++m_Allocated;

		for (FileID m = m_Allocated; m >= nid + 1; --m) {
			HashSwap(m, m - 1);
			if (m == 1)
				break;
		}

		m_HashTable[nid] = f->m_Hash;
		m_FileIDTable[nid] = f->m_GlobalFileID;
	} else {
		FileID nid = m_Allocated++;
		m_HashTable[nid] = f->m_Hash;
		m_FileIDTable[nid] = f->m_GlobalFileID;
	}
}

//-------------------------------------------------------------------------------------------------

bool HashFileTable::Resize(FileID NewCapacity) {
	if (NewCapacity <= m_Capacity)
		return true;

	size_t element = sizeof(FilePathHash) + sizeof(FileID);
	auto NewMemory = std::unique_ptr<char[]>(new char[element * NewCapacity]);
	if (!NewMemory)
		return false;

	memset(NewMemory.get(), 0, element * NewCapacity);
	FilePathHash *NewHashTable = (FilePathHash*)NewMemory.get();
	FileID *NewFileIDTable = (FileID*)((char*)NewHashTable + sizeof(FilePathHash) * NewCapacity);

//	if (m_MaxIndex > 0) {
		memcpy(NewHashTable, m_HashTable, sizeof(FilePathHash) * m_Allocated);
		memcpy(NewFileIDTable, m_FileIDTable, sizeof(FileID) * m_Allocated);
//	}

	STARVFSDebugLog("Reallocated FileHashTable to %d entries", NewCapacity);
	m_Memory.swap(NewMemory);
	m_Capacity = NewCapacity;
	m_HashTable = NewHashTable;
	m_FileIDTable = NewFileIDTable;

	return true;
}

//-------------------------------------------------------------------------------------------------
/*
void FileTable::AddToHashTable(File* f) {

}

void FileTable::RebuildHashTable() {

}

void FileTable::SortHashTable() {

}

*/
} //namespace StarVFS 
