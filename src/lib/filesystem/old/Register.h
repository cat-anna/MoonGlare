/*
  * Generated by cppsrc.sh
  * On 2015-12-19 10:34:11,34
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef ModuleRegister_H
#define ModuleRegister_H
#ifndef STARVFS_DISABLE_REGISTER

namespace StarVFS {

class Register final {
public:
	explicit Register(StarVFS *Owner);
	Register(const Register&) = delete;
 	~Register();

	template<class T> 
	void RegisterContainer(const char *Name) {
		static_assert(std::is_base_of <Containers::iContainer, T>::value, "Invalid container class");
		m_ContainerMap[Name].CreateFunc = &DoCreateContainer<T>;
	}
	CreateContainerResult CreateContainer(const char *Name, const String &MountPoint = "/") const {
		auto it = m_ContainerMap.find(Name);
		if (it == m_ContainerMap.end())
			return CreateContainerResult(VFSErrorCode::InternalError, nullptr);
		return it->second.CreateFunc(m_Owner, MountPoint);
	}
	std::vector<String> GetRegisteredContainers() const {
		std::vector<String> v;
		v.reserve(m_ContainerMap.size());
		for (auto &it : m_ContainerMap)
			v.emplace_back(it.first);
		return v;
	}

	template<class T>
	void RegisterExporter(const char *Name) {
		static_assert(std::is_base_of <Exporters::iExporter, T>::value, "Invalid exporter class");
		m_ExporterMap[Name].CreateFunc = &DoCreateExporter<T>;
	}
	std::unique_ptr<Exporters::iExporter> CreateExporter(const char *Name) const {
		auto it = m_ExporterMap.find(Name);
		if (it == m_ExporterMap.end())
			return nullptr;
		return it->second.CreateFunc(m_Owner);
	}
	std::vector<String> GetRegisteredExporters() const {
		std::vector<String> v;
		v.reserve(m_ExporterMap.size());
		for (auto &it : m_ExporterMap)
			v.emplace_back(it.first);
		return v;
	}

	template<class T>
	void RegisterModule(const char *Name) {
		static_assert(std::is_base_of <Modules::iModule, T>::value, "Invalid module class");
		m_ModuleMap[Name].CreateFunc = &DoCreateModule<T>;
	}
	Modules::iModule* CreateModule(const char *Name) const {
		auto it = m_ModuleMap.find(Name);
		if (it == m_ModuleMap.end())
			return nullptr;
		return it->second.CreateFunc(m_Owner);
	}
	std::vector<String> GetRegisteredModules() const {
		std::vector<String> v;
		v.reserve(m_ModuleMap.size());
		for (auto &it : m_ModuleMap)
			v.emplace_back(it.first);
		return v;
	}
private: 
	StarVFS *m_Owner;

	template<class T>
	static Modules::iModule* DoCreateModule(StarVFS *svfs) { return svfs->AddModule<T>(); }
	template<class T>
	static std::unique_ptr<Exporters::iExporter> DoCreateExporter(StarVFS *svfs) { return svfs->CreateExporter<T>(); }
	template<class T>
	static CreateContainerResult DoCreateContainer(StarVFS *svfs, const String &MountPoint) { return svfs->CreateContainer<T>(MountPoint); }

	struct ModuleInfo {
		Modules::iModule*(*CreateFunc)(StarVFS *svfs);
		ModuleInfo(): CreateFunc(nullptr) {}
	};
	struct ExporterInfo {
		std::unique_ptr<Exporters::iExporter>(*CreateFunc)(StarVFS *svfs);
		ExporterInfo(): CreateFunc(nullptr) {}
	};
	struct ContainerInfo {
		CreateContainerResult(*CreateFunc)(StarVFS *svfs, const String &MountPoint);
		ContainerInfo(): CreateFunc(nullptr) {}
	};

	std::unordered_map<std::string, ModuleInfo> m_ModuleMap;
	std::unordered_map<std::string, ExporterInfo> m_ExporterMap;
	std::unordered_map<std::string, ContainerInfo> m_ContainerMap;
};

} //namespace StarVFS 

#endif
#endif
