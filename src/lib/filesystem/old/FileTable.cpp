/*
  * Generated by cppsrc.sh
  * On 2015-12-10 18:00:09,91
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#include "StarVFSInternal.h"
#include "FileTable.h"

namespace StarVFS {

FileTable::FileTable(StarVFS *Owner):
		m_Owner(Owner) {
	StarVFSAssert(Owner);

	m_Capacity = m_Allocated = 0;
	m_Interfaces.push_back(nullptr);

	m_StringTable = std::make_unique<StringTable>();
	Realloc(Settings::Initial::FileTableSize);
	m_Allocated = 1;//first entry is not valid

	auto *root = AllocNewFile();
	root->m_Flags.Valid = 1;
	root->m_Flags.Directory = 1;
	root->m_Hash = FilePathHashAlgorithm::Hash("/", 1);
	m_HashFileTable.Add(root);
}

FileTable::~FileTable() {
	m_Capacity = m_Allocated = 0;

	m_FileTable.reset();
	m_FileTypeHash.reset();

	m_StringTable.reset();
}

//-------------------------------------------------------------------------------------------------

void FileTable::DumpStructure(std::ostream &out) const {
	const char *fmt = "%5s. %3s:%-4s %8s:%8s %5s %6s %6s %6s %10s %s%s\n";
	char buf[512];
	sprintf_s(buf, fmt, "GFID", "CID", "CFID", "HASH", "TYPEHASH", "FLAGS", "PARENT", "FCHILD", "NEXT", "SIZE", "", "NAME");
	out << buf;

	std::function<void(FileID, int)> Printer;
	Printer = [&Printer, this, fmt, &out](FileID id, int level) {
		char buf[512];
		char idbuf[32];
		char containeridbuf[32];
		char containerfileidbuf[32];
		char hashbuf[32], typehashbuf[32];
		char sizebuf[32];
		char parentbuf[32];
		char firstchildbuf[32];
		char nextsyblingbuf[32];
		char levelbuf[128];

		for (int i = 0; i < level; ++i) {
			levelbuf[i * 3 + 0] = '|';
			levelbuf[i * 3 + 1] = ' ';
			levelbuf[i * 3 + 2] = ' ';
		}
		levelbuf[level * 3 + 0] = '}';
	//	levelbuf[level * 3 + 1] = ' ';
		levelbuf[level * 3 + 1] = 0;

		const auto &f = m_FileTable[id];
		const auto &fthash = m_FileTypeHash[id];
		char flagsbuf[6] = "     ";

		sprintf_s(idbuf, "%d", id);
		sprintf_s(containeridbuf, "%d", f.m_ContainerID);
		sprintf_s(containerfileidbuf, "%d", f.m_ContainerFileID);
		sprintf_s(hashbuf, "%08x", f.m_Hash);
		sprintf_s(typehashbuf, "%08x", fthash);

		sprintf_s(parentbuf, "%d", f.m_ParentFileID);
		sprintf_s(firstchildbuf, "%d", f.m_FirstChild);
		sprintf_s(nextsyblingbuf, "%d", f.m_NextSibling);

		sprintf_s(sizebuf, "%d", f.m_Size);

		if (f.m_Flags.Valid) flagsbuf[0] = 'V';
		if (f.m_Flags.Directory) flagsbuf[1] = 'D';
		if (f.m_Flags.SymLink) flagsbuf[2] = 'S';

		sprintf_s(buf, fmt, idbuf, containeridbuf, containerfileidbuf, hashbuf, typehashbuf, flagsbuf,
				parentbuf, firstchildbuf, nextsyblingbuf, sizebuf, levelbuf, m_StringTable->Get(f.m_NameStringID));
		out << buf;

		if (f.m_Flags.Directory && f.m_FirstChild) {
			Printer(f.m_FirstChild, level + 1);
		}
		if(f.m_NextSibling)
			Printer(f.m_NextSibling, level);
	};

	Printer(1, 0);
}

void FileTable::DumpFileTable(std::ostream &out) const {
	const char *fmt = "%5s. %3s:%-4s %8s %5s %6s %6s %6s %10s %s\n";

	char buf[512];
	char idbuf[32];
	char containeridbuf[32];
	char containerfileidbuf[32];
	char hashbuf[32];
	char sizebuf[32];
	char parentbuf[32];
	char firstchildbuf[32];
	char nextsyblingbuf[32];
	
	sprintf_s(buf, fmt, "GFID", "CID", "CFID", "HASH", "FLAGS", "PARENT", "FCHILD", "NEXT", "SIZE", "NAME");
	out << buf;

	for (FileID i = 0; i < m_Allocated; ++i) {
		auto &f = m_FileTable[i];

		char flagsbuf[6] = "     ";

		sprintf_s(idbuf, "%d", i);
		sprintf_s(containeridbuf, "%d", f.m_ContainerID);
		sprintf_s(containerfileidbuf, "%d", f.m_ContainerFileID);
		sprintf_s(hashbuf, "%08x", f.m_Hash);

		sprintf_s(parentbuf, "%d", f.m_ParentFileID);
		sprintf_s(firstchildbuf, "%d", f.m_FirstChild);
		sprintf_s(nextsyblingbuf, "%d", f.m_NextSibling);

		sprintf_s(sizebuf, "%d", f.m_Size);

		if (f.m_Flags.Valid) flagsbuf[0] = 'V';
		if (f.m_Flags.Directory) flagsbuf[1] = 'D';
		if (f.m_Flags.SymLink) flagsbuf[2] = 'S';

		sprintf_s(buf, fmt, idbuf, containeridbuf, containerfileidbuf, hashbuf, flagsbuf,
				parentbuf, firstchildbuf, nextsyblingbuf, sizebuf, m_StringTable->Get(f.m_NameStringID));
		out << buf;
	}
}

void FileTable::DumpHashTable(std::ostream &out) const {
	const char *fmt = "%4s %8s %s\n";

	char buf[512];
	char idbuf[32];
	char gfidbuf[32];
	char hashbuf[32];

	sprintf_s(buf, fmt, "ID", "HASH", "GFID");
	out << buf;

	for (FileID i = 0, j = m_HashFileTable.GetAllocated(); i < j; ++i) {
		auto fid = m_HashFileTable.GetFileIDAtIndex(i);
		auto hash = m_HashFileTable.GetPathHashAtIndex(i);

		sprintf_s(idbuf, "%d", i);
		sprintf_s(gfidbuf, "%u", (unsigned)fid);
		sprintf_s(hashbuf, "%08x", hash);

		sprintf_s(buf, fmt, idbuf, hashbuf, gfidbuf);
		out << buf;
	}
}

//-------------------------------------------------------------------------------------------------

File* FileTable::AllocNewFile() {
	if (!EnsureCapacity(1))
		return nullptr;

	auto id = m_Allocated++;

	auto *f = m_FileTable.get() + id;
	memset(f, 0, sizeof(*f)); //is this necessary?
	f->m_GlobalFileID = id;

	return f;
}

File* FileTable::AllocNewFile(const CString fullpath) {
	const CString path = strrchr(fullpath, '/');
	if (!path) {
		//TODO: log
		return nullptr;
	}

	size_t len = path - fullpath;

	File *parent = nullptr;
	if (len > 0) {
		auto pid = m_HashFileTable.Lookup(fullpath, len);
		if (pid)
			parent = m_FileTable.get() + pid;
	} else
		parent = GetRoot();

	if (!parent || !parent->m_Flags.ValidDirectory())
		return nullptr;

	return AllocNewFile(parent->m_GlobalFileID, FilePathHashAlgorithm::Hash(fullpath, strlen(fullpath)), path + 1);
}

File* FileTable::AllocNewFile(FileID ParentID, FilePathHash PathHash, const CString FName) {
	if (!ParentID)
		return nullptr;

	auto f = AllocNewFile();
	auto Parent = GetFile(ParentID);
	f->m_NameStringID = m_StringTable->Alloc(FName);
	f->m_ParentFileID = Parent->m_GlobalFileID;
	f->m_NextSibling = Parent->m_FirstChild;
	Parent->m_FirstChild = f->m_GlobalFileID;
	f->m_Hash = PathHash;

	m_FileTypeHash[f->m_GlobalFileID] = MakeFileTypeHash(FName);

	m_HashFileTable.Add(f);
	return f;
}

//-------------------------------------------------------------------------------------------------

File* FileTable::AllocFile(const CString InternalFullPath) {
	auto fid = m_HashFileTable.Lookup(InternalFullPath);
	if (fid) {
		STARVFSErrorLog("Alloc file returns existing one! %d (%s)", fid, InternalFullPath);
		return m_FileTable.get() + fid;
	}
	return AllocNewFile(InternalFullPath);
}

File* FileTable::AllocFile(FileID Parent, FilePathHash PathHash, const CString FileName) {
	if (!PathHash)
		return nullptr;
	auto fid = Lookup(PathHash);
	if (fid) {
		STARVFSErrorLog("Alloc file returns existing one! %d", fid);
		return m_FileTable.get() + fid;
	}
	auto p = GetFile(Parent);
	if (!p || !p->m_Flags.ValidDirectory())
		return nullptr;

	return AllocNewFile(Parent, PathHash, FileName);
}

//-------------------------------------------------------------------------------------------------

String FileTable::GetFilePath(FileID fid, FileID ParentFID) const {
	std::stringstream ss;
	auto f = GetFile(fid);
	if (!f)
		return String();
	struct T {
		static void Do(std::stringstream &ss, const File *f, const FileTable* This, FileID ParentFID) {
			if (!f || f->m_GlobalFileID <= 1 || ParentFID == f->m_GlobalFileID)
				return;
			Do(ss, This->GetFileParent(f), This, ParentFID);
			if(ParentFID != f->m_ParentFileID)
				ss << "/";
			ss << This->m_StringTable->Get(f->m_NameStringID);
		}
	};
	T::Do(ss, f, this, ParentFID);
	return ss.str();
}

CString FileTable::GetFileName(FileID fid) const {
	if (!fid || fid >= m_Allocated)
		return nullptr;
	return (CString)m_StringTable->Get(m_FileTable[fid].m_NameStringID);
}

bool FileTable::GetFileData(FileID fid, ByteTable &data) {
	auto f = GetFile(fid);
	if (!fid)
		//TODO: log
		return false;
	auto c = m_Owner->GetContainer(f->m_ContainerID);
	if (!c) {
		STARVFSErrorLog("Invalid cid for file %d", fid);
		return false;
	}
	return c->GetFileData(f->m_ContainerFileID, data);
}

bool FileTable::SetFileData(FileID fid, const ByteTable & data) {
	auto f = GetFile(fid);
	if (!fid)
		//TODO: log
		return false;
	auto c = m_Owner->GetContainer(f->m_ContainerID);
	if (!c) {
		STARVFSErrorLog("Invalid cid for file %d", fid);
		return false;
	}
	return c->SetFileData(f->m_ContainerFileID, data);
}

FileFlags FileTable::GetFileFlags(FileID fid) const {
	auto f = GetFile(fid);
	if (!fid) {
		FileFlags flags;
		flags.intval = 0;
		return flags;
	}
	return f->m_Flags;
}

bool FileTable::DeleteFile(FileID fid) {
	auto f = GetFile(fid);
	if (!f)
		return false;

	f->m_Flags.Valid = false;
	f->m_Flags.Deleted = true;

	return true;
}

bool FileTable::DeleteFile(FileID fid, ContainerID cid) {
	auto f = GetFile(fid);
	if (!f)
		return false;
	if (f->m_ContainerID != cid)
		return false;

	f->m_Flags.Valid = false;
	f->m_Flags.Deleted = true;

	return true;
}

//-------------------------------------------------------------------------------------------------

bool FileTable::EnsureCapacity(FileID RequiredEmptySpace) {
	if (m_Allocated + RequiredEmptySpace < m_Capacity)
		return true;
	return Realloc(m_Allocated + RequiredEmptySpace);
}

bool FileTable::Realloc(FileID NewCapacity) {
	if (NewCapacity <= m_Capacity)
		return true;

	auto NewMemory = std::unique_ptr<File[]>(new File[NewCapacity]);
	auto NewHashMemory = std::unique_ptr<FileTypeHash[]>(new FileTypeHash[NewCapacity]);
	if (!NewMemory || !NewHashMemory)
		return false;

	memset(NewMemory.get(), 0, sizeof(File) * NewCapacity);
	memset(NewHashMemory.get(), 0, sizeof(FileTypeHash) * NewCapacity);

	if (m_Allocated > 0) {
		memcpy(NewMemory.get(), m_FileTable.get(), sizeof(File) * m_Allocated);
		memcpy(NewHashMemory.get(), m_FileTypeHash.get(), sizeof(FileTypeHash) * m_Allocated);
	}

	STARVFSDebugLog("Reallocated FileTable to %d entries", NewCapacity);
	m_FileTable.swap(NewMemory);
	m_FileTypeHash.swap(NewHashMemory);
	m_Capacity = NewCapacity;
	 
	return m_HashFileTable.Resize(NewCapacity);
}

//-------------------------------------------------------------------------------------------------

Containers::FileTableInterface *FileTable::AllocateInterface(const String& MountPoint) {
	ContainerID cid = static_cast<ContainerID>(m_Interfaces.size());
	m_Interfaces.emplace_back(std::make_unique<Containers::FileTableInterface>(this, cid));
	return m_Interfaces.back().get();
}

//-------------------------------------------------------------------------------------------------

bool FileTable::RegisterStructureTable(FileStructureInfo &info) {
	if (!info.IsValid()) {
		STARVFSDebugLog("invalid info!");
		return false;
	}

	if (!EnsureCapacity(info.m_Count))
		return false;

	for (FileID i = 0; i < info.m_Count; ++i) {
		auto &basefile = info.m_FileTable[i];

		if (!basefile.m_Flags.Valid)
			continue;

		FilePathHash hash = info.m_PathHashTable[i];

		basefile.m_GlobalIndex = 0;
		
		File *fparent = nullptr;
		if (basefile.m_ParentIndex) {
			if (basefile.m_ParentIndex < info.m_Count && basefile.m_ParentIndex < i) {
				fparent = GetFile(info.m_FileTable[basefile.m_ParentIndex].m_GlobalIndex);
			}
		} else {
			fparent = info.m_Parent;
		}

		auto *f = AllocFile(fparent->m_GlobalFileID, hash, basefile.m_NamePointer);
		if (!f) {
			STARVFSErrorLog("Failed to allocate file!");
			return false;
		}

		bool changeownership = true;
		if (f->m_Flags.Valid) {
			if (f->m_Flags.Directory) {
				changeownership = false;
			} else {
			}
			if (basefile.m_Flags.Directory != f->m_Flags.Directory) {
				//todo: sth?
			}
		} else {
			f->m_Flags.Valid = 1;
			if (basefile.m_Flags.Directory) {
				f->m_Flags.Directory = 1;
			}
		}

		basefile.m_GlobalIndex = f->m_GlobalFileID;
		if (changeownership) {
			f->m_ContainerID = info.m_OwnerContainer;
			f->m_ContainerFileID = i;
			f->m_Size = basefile.m_Size;
		}
	}

	return true;
}

//-------------------------------------------------------------------------------------------------

void FileTable::FindFilesByTypeHash(FileTypeHash fth, DynamicFIDTable &table) {
	table.clear();
	for (FileID fid = 0; fid < m_Allocated; ++fid) 
		if (m_FileTypeHash[fid] == fth)
			table.push_back(fid);
}

void FileTable::InvalidateCID(ContainerID cid) {
	STARVFSErrorLog("Not implemented: %s", __FUNCTION__);
}

} //namespace StarVFS 
