/*
  * Generated by cppsrc.sh
  * On 2016-01-02 11:00:05,98
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef Sections_v1_H
#define Sections_v1_H

#include <sstream>

namespace StarVFS {
namespace RDC {
namespace Version_1 {
namespace Sections {

struct SectionFileBuilderInterface {
	virtual ~SectionFileBuilderInterface() {} ;
	virtual BlockProcessingResult WriteBlockAtEnd(const ByteTable &in, DataBlock &blockdesc) = 0;
	virtual BlockProcessingResult WriteBlockAtEndOwning(ByteTable in, DataBlock &blockdesc) = 0;
	virtual BlockProcessingResult OffsetBlockWriteAtEnd(const ByteTable &in, OffsetDataBlock &blockdesc, DataBlock &base) = 0;
	virtual BlockProcessingResult OffsetBlockWriteAtEndOwning(ByteTable in, OffsetDataBlock &blockdesc, DataBlock &base) = 0;

	template<class T>
	BlockProcessingResult WriteBlockAtEnd(const T *data, size_t Size, DataBlock &blockdesc) {
		ByteTable bt;
		bt.make_copy(data, Size);
		return WriteBlockAtEndOwning(std::move(bt), blockdesc);
	}

	template<class T>
	BlockProcessingResult OffsetBlockWriteAtEnd(const T *data, size_t Size, OffsetDataBlock &blockdesc, DataBlock &base) {
		ByteTable bt;
		bt.make_copy(data, Size);
		return OffsetBlockWriteAtEndOwning(std::move(bt), blockdesc, base);
	}
};

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

#define DefineSectionDependency(Name, Type) \
public:	\
	void Set ## Name(Type* sect) { m_ ## Name = sect; }	\
	Type *Get ## Name() const { return m_ ## Name; } \
	SectionIndex Get ## Name ## Index() const { return m_ ## Name ? m_ ## Name->GetIndex( ): 0; } \
private: \
	Type *m_ ## Name = 0;									

struct BaseSection {
	BaseSection(SectionFileBuilderInterface *sfbi, SectionIndex index, SectionType Type) : 
		m_Index(index), m_Type(Type), m_SFBI(sfbi) {}
	virtual ~BaseSection() {}

	SectionIndex GetIndex() const { return m_Index; }
	SectionType GetType() const { return m_Type; }

	const DataBlock& GetSectionDataBlock() const { return m_SectionDataBlock; }

	virtual BlockProcessingResult WriteSection()  /* = 0 */ { return BlockProcessingResult(); }

	SectionFileBuilderInterface *GetBuilderInterface() { return m_SFBI; }

	virtual void SetCompression(CompressionMode mode, Compression::Compressionlevel level) {
		m_SectionDataBlock.Compression.Mode = mode;
		m_SectionDataBlock.Compression.Level = static_cast<u8>(level);
	}

	bool ValidSection() const { return m_Type != SectionType::EmptyEntry; }
private:
	SectionIndex m_Index;
	SectionType m_Type;
	SectionFileBuilderInterface *m_SFBI;
protected:
	DataBlock m_SectionDataBlock;
};

//-----------------------------------------------------------------------------

struct StringTable : public BaseSection {
	StringTable(SectionFileBuilderInterface *sfbi, SectionIndex index) : BaseSection(sfbi, index, SectionType::StringTable) {
		m_data << '\0';
	}

	u32 AllocString(const CString cstr) {
		if (!cstr || !*cstr)
			return 0;
		auto pos = m_data.tellp();
		m_data << cstr << '\0';
		return static_cast<u32>(pos);
	}

	virtual BlockProcessingResult WriteSection() override {
		auto str = m_data.str();
		return GetBuilderInterface()->WriteBlockAtEnd(str.c_str(), static_cast<Size>(str.length()), m_SectionDataBlock);
	}
private:
	std::stringstream m_data;
};

//-----------------------------------------------------------------------------

struct RawDataSection : public BaseSection {
	RawDataSection(SectionFileBuilderInterface *sfbi, SectionIndex index) : BaseSection(sfbi, index, SectionType::RawData) {
		GetBuilderInterface()->WriteBlockAtEnd((char*)nullptr, 0, m_SectionDataBlock);
	}

	BlockProcessingResult PushOffsetDataBlock(const ByteTable &ct, OffsetDataBlock &offsetdatablock) {
		return GetBuilderInterface()->OffsetBlockWriteAtEnd(ct, offsetdatablock, m_SectionDataBlock);
	}

	virtual BlockProcessingResult WriteSection() override {
		if ((m_SectionDataBlock.ContainerSize % 8) == 0)
			return BlockProcessingResult();

		char buf[8] = {};
		OffsetDataBlock paddingblock;
		FileSize size = m_SectionDataBlock.ContainerSize % 8;

		return GetBuilderInterface()->OffsetBlockWriteAtEnd(buf, size, paddingblock, m_SectionDataBlock);
	}

	virtual void SetCompression(CompressionMode mode, Compression::Compressionlevel level) {
		STARVFSDebugLog("Compression settings ignored for RawDataSection");
	}
private:
};

//-----------------------------------------------------------------------------

struct OffsetDataBlockTable : public BaseSection {
	OffsetDataBlockTable(SectionFileBuilderInterface *sfbi, SectionIndex index) : BaseSection(sfbi, index, SectionType::OffsetDataBlockTable) {}

	std::vector<OffsetDataBlock>& GetTable() { return m_Table; }

	virtual BlockProcessingResult WriteSection() override {
		if (m_Table.empty()) {
			m_SectionDataBlock.Zero();
			return BlockProcessingResult();
		}
		return GetBuilderInterface()->WriteBlockAtEnd(&m_Table[0], m_Table.size(), m_SectionDataBlock);
	}
private:
	std::vector<OffsetDataBlock> m_Table;
};

//-----------------------------------------------------------------------------

struct FileStructureTable : public BaseSection {
	FileStructureTable(SectionFileBuilderInterface *sfbi, SectionIndex index) : BaseSection(sfbi, index, SectionType::FileStructureTable) {}

	std::vector<BaseFileInfo>& GetTable() { return m_Table; }

	virtual BlockProcessingResult WriteSection() override {
		if (m_Table.empty()) {
			m_SectionDataBlock.Zero();
			return BlockProcessingResult();
		}
		ByteTable bt;
		bt.make_copy(&m_Table[0], m_Table.size());
		return GetBuilderInterface()->WriteBlockAtEnd(bt, m_SectionDataBlock);
	}
private:
	std::vector<BaseFileInfo> m_Table;
};

//-----------------------------------------------------------------------------

struct HashTableSection : public BaseSection {
	HashTableSection(SectionFileBuilderInterface *sfbi, SectionIndex index) : BaseSection(sfbi, index, SectionType::HashTable) {}

	std::vector<HashSectionItemType>& GetTable() { return m_Table; }

	virtual BlockProcessingResult WriteSection() override {
		if (m_Table.empty()) {
			m_SectionDataBlock.Zero();
			return BlockProcessingResult();
		}
		return GetBuilderInterface()->WriteBlockAtEnd((char*)&m_Table[0], static_cast<Size>(m_Table.size() * sizeof(m_Table[0])), m_SectionDataBlock);
	}
private:
	std::vector<HashSectionItemType> m_Table;
};

//-----------------------------------------------------------------------------

struct MountEntrySection : public BaseSection {
	DefineSectionDependency(StringTable, StringTable);
	DefineSectionDependency(RawDataSection, RawDataSection);
	DefineSectionDependency(OffsetDataBlockTable, OffsetDataBlockTable);
	DefineSectionDependency(FileStructureTable, FileStructureTable);
	DefineSectionDependency(HashTableSection, HashTableSection);
public:
	MountEntrySection(SectionFileBuilderInterface *sfbi, SectionIndex index) : BaseSection(sfbi, index, SectionType::MountEntry) {}

	u16 m_MountEntryId = 0;

	virtual BlockProcessingResult WriteSection() override {
		Headers::MountEntrySection data;
		data.StringTable = GetStringTableIndex();
		data.RawDataSection = GetRawDataSectionIndex();
		data.DataBlockTable = GetOffsetDataBlockTableIndex();
		data.StructureSection = GetFileStructureTableIndex();
		data.HashTable = GetHashTableSectionIndex();
		data.MountEntryId = m_MountEntryId;

		ByteTable bt;
		bt.make_copy(&data, 1);
		return GetBuilderInterface()->WriteBlockAtEnd(bt, m_SectionDataBlock);
	}
private:
};

//-----------------------------------------------------------------------------

} //namespace Sections
} //namespace Version_1
} //namespace RDC 
} //namespace StarVFS 

#endif
