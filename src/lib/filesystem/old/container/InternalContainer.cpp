/*
  * Generated by cppsrc.sh
  * On 2015-02-26  2:51:49,93
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#include "../StarVFSInternal.h"
#include "InternalContainerHeaders.h"
#include "InternalContainer.h"

namespace StarVFS {
namespace Containers {

//class InternalFileReader : public iFileReader {
//	GABI_DECLARE_STATIC_CLASS(InternalFileReader, iFileReader);
//public:
//	InternalFileReader(iContainer *Owner, const InternalContainer::FileNode *f): BaseClass(Owner), m_File(f) { }
//	~InternalFileReader() { }
//
//	virtual FileSize Size() const { return (FileSize)m_File->Size; }
//	virtual const char* GetFileData() const { return (const char *)m_File->Data; }
//	virtual const string& FileName() const { return m_File->Name; }
//private:
//	const InternalContainer::FileNode *m_File;
//};

//GABI_IMPLEMENT_STATIC_CLASS(InternalFileReader);
//-------------------------------------------------------------------------------------------------

//InternalContainer::InternalContainer(const FileNode *Root):
//		BaseClass(),
//		m_Root(Root),
//		m_Name("{?}"){
//	SetReadable(true);
//	SetReady(true);
//	if (Root)
//		m_Name = Root->Name;
//}
//
//InternalContainer::~InternalContainer() {
//}

InternalContainer::InternalContainer(FileTableInterface  *fti):
		iContainer(fti) {

}

//-------------------------------------------------------------------------------------------------

String InternalContainer::GetContainerURI() const {
	return "";
}

FileID InternalContainer::FindFile(const String& ContainerFileName) const {
	return 0;
}

#if 0

const string& InternalContainer::GetFileName() const {
	return m_Name;
}

const string& InternalContainer::GetContainerName() const {
	return m_Name;
}

//-------------------------------------------------------------------------------------------------

FileReader InternalContainer::GetFileReader(const string& file) const {
	auto f = LookForFile(file);
	if (!f) return nullptr;
	return FileReader(new InternalFileReader(const_cast<InternalContainer*>(this), f));
}

FileReader InternalContainer::GetFileReader(const RawFilePointer *file) const {
	const FileNode* node = dynamic_cast<const FileNode*>(file);
	if (!node) {
		AddLog(Error, "Invalid file pointer!");
		return FileReader();
	}
	return FileReader(new InternalFileReader(const_cast<InternalContainer*>(this), const_cast<FileNode*>(node)));
}

bool InternalContainer::FileExists(const string& file) const {
	return LookForFile(file) != 0;
}

bool InternalContainer::EnumerateFolder(const RawFilePointer *root, FolderEnumerateFunc func) const {
	const FileNode *node;

	if (root)
		node = dynamic_cast<const FileNode*>(root);
	else
		node = m_Root;

	if (!node) {
		AddLog(Error, "Invalid file pointer!");
		return false;
	}

	auto p = node;// LookForFile(Path);
	if (!p) return false;
	if (!p->Children) return true;
	//string dir = Path;
	//dir += "/";
	for (auto *it = p->Children; it->Name; ++it) {
		string n = it->Name;
		FileType type;
		if (it->Flags & FileFlags::HasChildren)
			type = FileType::Directory;
		else
			type = FileType::File;
		func(n, type, it);
	}
	return true;
}

void InternalContainer::DumpFileTree(ostream& out) const {
	struct T {
		T() : count(0), size(0), Level(0) {};
		unsigned count, size;
		void start(const FileNode *ptr, std::ostream& out) {
			auto *child = ptr->Children;
			if (child)
				while (child->Flags & FileFlags::Valid){
					work(child, out);
					if (child->Flags & FileFlags::HasChildren){
						++Level;
						start(child, out);
						--Level;
					}
					++child;
				}
		}
	protected:
		unsigned Level;
		void work(const FileNode *node, std::ostream& out){
			++count;
			size += node->Size;
			char buffer[64];
			char * where = buffer + sprintf(buffer, "%7d ", node->Size);
			for (unsigned i = 0; i < Level; ++i)
				*where++ = '\t';
			sprintf(where, "%s", node->Name);

			out << buffer << "\n";
		}
	} t;
	out << "Dumping internal container\n";
	t.start(m_Root, out);
	char buf[64];
	sprintf(buf, "Total %.2f kbytes in %d files\n", t.size / (1024.0f), t.count);
	out << buf;
}


//-------------------------------------------------------------------------------------------------

const InternalContainer::FileNode* InternalContainer::LookForFile(const string& FileName) const {
	const FileNode *ptr = m_Root;

	const char* p = FileName.c_str();
	if (*p == '\\' || *p == '/') ++p;
	for (;;){
		const char* next = strchr(p, '\\');
		if (!next) next = strchr(p, '/');
		if (!next) next = p;
		try{
			auto *child = ptr->Children;
			if (child)
				while (child && child->Flags & FileFlags::Valid){
					const char* s = p;
					const char* t = child->Name;
					for (;;) {
						if ((*s == '\\' || *s == '/' || !*s) && !*t){
							throw child;
						}
						if ((*s | 0x20) != (*t | 0x20)) break;
						++s;
						++t;
					}
					++child;
				}
			return 0;
		}
		catch (const FileNode *i){
			if (p == next) return i;
			p = next + 1;
			if (!*p)
				return i;
			ptr = i;
			continue;
		}
	}
}
#endif

} //namespace Containers 
} //namespace StarVFS
