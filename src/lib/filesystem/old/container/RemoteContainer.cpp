/*
  * Generated by cppsrc.sh
  * On 2015-12-12 12:02:12,55
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/
#define _WIN32_WINNT 0x0501

#include <thread>
#include <boost/asio.hpp>

#undef CreateFile
#undef CreateDirectory

#include "../StarVFSInternal.h"
#include "RemoteContainer.h"
#include "../Module/RemoteHeaders.h"


using boost::asio::ip::tcp;

namespace StarVFS {
namespace Containers {

namespace RemoteHeaders = Modules::RemoteHeaders;

using BaseConnectionClass = RemoteHeaders::BaseConnection<boost::asio::io_service, tcp::socket>;
struct RemoteContainer::Connection : public BaseConnectionClass {
	RemoteContainer *m_Owner;
	using MessageBuffer = RemoteHeaders::MessageBuffer;
	mutable std::unique_ptr<MessageBuffer> m_MessageBuffer;

	std::vector<File> m_FileTable;
	std::vector<Char> m_ByteTable;
	FileID m_FileCount;

	virtual bool CanRun() const override { return true; }

	Connection(RemoteContainer *Owner) : BaseConnectionClass() {
		m_Owner = Owner;
	}

	FileID GetFileCount() {
		if(m_FileTable.size() > 0)
			return m_FileCount;
		m_MessageBuffer->Clear();
		auto hdr = m_MessageBuffer->GetHeader();

		hdr->CommandID = RemoteHeaders::Command::GetFileTable;
		if (!SendAndWait(*m_MessageBuffer.get()))
			return 0;

		hdr->CommandID = RemoteHeaders::Command::GetStringTable;
		if (!SendAndWait(*m_MessageBuffer.get()))
			return 0;

		return m_FileCount;
	}

	bool GetFileData(FileID ContainerFID, ByteTable &out) const {
		m_MessageBuffer->Clear();
		auto hdr = m_MessageBuffer->GetHeader();
		hdr->CommandID = RemoteHeaders::Command::GetFile;
		auto request = m_MessageBuffer->AllocAndZero<RemoteHeaders::GetFileRequest>();
		request->ID = ContainerFID;
		request->AccessMode = RWMode::R;
		request->FileOpenMode = OpenMode::OpenExisting;
		request->Mode = RemoteHeaders::GetFileRequest::FindMode::ID;

		if (!((Connection*)this)->WaitForResponse(*m_MessageBuffer.get()))
			return false;

		auto response = m_MessageBuffer->GetAndPull<RemoteHeaders::GetFileResponse>();
		if (response->Result)
			return false;

		out.make_new(response->DataSize);
		m_MessageBuffer->PullBytes(response->DataSize, (char*)out.get());
		out[response->DataSize] = 0;
		return true;
	}

	bool LoadMeta() {
		auto hdr = m_MessageBuffer->GetHeader();
		m_MessageBuffer->Clear();
		hdr->CommandID = RemoteHeaders::Command::Ping;
		WriteMessage(*m_MessageBuffer.get());
		return DispatchPendingCommand(*m_MessageBuffer.get());
	}

	bool Connect(const String& Host, int port) {
		tcp::resolver resolver(m_io_service);

		boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::address::from_string(Host), (short)port);
		boost::system::error_code error;
		m_Socket.connect(endpoint, error);

		//boost::asio::connect(m_Socket, resolver.resolve({ Host.c_str(), strPort }));

		if (error)
			return false;

		m_MessageBuffer = std::make_unique<MessageBuffer>();
		m_MessageBuffer->Fill(0);

		return LoadMeta();
	}

#if 0
	bool ProcessPingPong(MessageBuffer &message) {
		message.Clear();
		auto hdr = message.GetHeader();
		if (hdr->CommandID == RemoteHeaders::Command::Ping)
			hdr->CommandID = RemoteHeaders::Command::Pong;
		else
			hdr->CommandID = RemoteHeaders::Command::Ping;
		return WriteMessage(message);
	}
#endif


	bool ReadFileTable(MessageBuffer &message) {
		auto hdr = message.GetHeader();
		m_FileTable.resize(hdr->ElementCount);
		size_t len = hdr->ElementCount * sizeof(File);
		memcpy(&m_FileTable[0], message.PullBytes(len), len);
		m_FileCount = (FileID)hdr->ElementCount;
		STARVFSErrorLog("table %d %u", hdr->ElementCount, (unsigned)len);
		return true;
	}
	bool ReadStringTable(MessageBuffer &message) {
		auto hdr = message.GetHeader();
		m_ByteTable.resize(hdr->ElementCount);
		size_t len = hdr->ElementCount * sizeof(Char);
		memcpy(&m_ByteTable[0], message.PullBytes(len), len);
		STARVFSErrorLog("string %d %u", hdr->ElementCount, (unsigned)len);
		return true;
	}

	virtual bool ProcessCommand(MessageBuffer &message) override {
		auto hdr = message.GetHeader();

		switch (hdr->CommandID) {
		case RemoteHeaders::Command::GetFileTable:
			return ReadFileTable(message);
		case RemoteHeaders::Command::GetStringTable:
			return ReadStringTable(message);

		//case RemoteHeaders::Command::Ping:
		//case RemoteHeaders::Command::Pong:
		//	return ProcessPingPong(message);

		case RemoteHeaders::Command::NOP:
		default:
			return true;
		}
	}
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

RemoteContainer::RemoteContainer(FileTableInterface *fti):
		iContainer(fti), m_Host(), m_Port() {
}

RemoteContainer::RemoteContainer(FileTableInterface *fti, int port, const String& host):
		iContainer(fti), m_Host(host), m_Port(port) {
}

RemoteContainer::~RemoteContainer() {
}

//-------------------------------------------------------------------------------------------------

String RemoteContainer::GetContainerURI() const {
	char buff[128];
	sprintf_s(buff, "tcp://%s:%d", m_Host.c_str(), m_Port);
	return buff;
}

RWMode RemoteContainer::GetRWMode() const { return RWMode::R; }

//-------------------------------------------------------------------------------------------------

bool RemoteContainer::ReloadContainer() {
	//m_Connection.reset();
	//
	//m_Connection = std::make_unique<Connection>(this);
	//if (!m_Connection->Connect(m_Host, m_Port)) {
	//	m_Connection.reset();
	//	return false;
	//}

	return false;
}

FileID RemoteContainer::GetFileCount() const {
	if (!m_Connection) return false;//wonderfull :)
	return m_Connection->GetFileCount();
}

bool RemoteContainer::RegisterContent() const {
//	if (!m_Connection) return false;
//
//	auto count = m_Connection->GetFileCount();
//
//	std::vector<FileID> idtable;
//	idtable.resize(count + 1, 1);
//
//	for (FileID i = 2; i < count; ++i) {
//		auto f = &m_Connection->m_FileTable[i];
//		auto pid = idtable[f->m_ParentFileID];
//		auto name = &m_Connection->m_ByteTable[f->m_NameStringID];
//		auto fptr = table->AllocFile(pid, f->m_Hash, name);
//
//		if (!fptr) {
//			STARVFSErrorLog("ERROR %d", i);
//			return false;
//		}
//
//		idtable[i] = fptr->m_GlobalFileID;
//
//		fptr->m_Flags.Directory = f->m_Flags.Directory;
//		fptr->m_Flags.Valid = f->m_Flags.Valid;
//		fptr->m_ContainerFileID = i;
//		fptr->m_ContainerID = GetContainerID();
//		fptr->m_Size = f->m_Size;
//	}

	return true;
}

FileID RemoteContainer::FindFile(const String& ContainerFileName) const {
	throw "RemoteContainer::FindFile is not implemented";
}

//-------------------------------------------------------------------------------------------------

bool RemoteContainer::GetFileData(FileID ContainerFID, ByteTable &out) const {
	out.reset();
	if (!m_Connection)
		return false;

	return m_Connection->GetFileData(ContainerFID, out);
}

//-------------------------------------------------------------------------------------------------

bool RemoteContainer::CanOpen(const String& Location) {
	return strncmp(Location.c_str(), "tcp://", 6) == 0;
}

CreateContainerResult RemoteContainer::CreateFor(StarVFS *svfs, const String& MountPoint, const String& Location) {
//	String uri = Location;
//	auto port = (char*)strrchr(uri.c_str(), ':');
//	auto host = (char*)strrchr(uri.c_str(), '/');
//
//	if (port < host)
//		port = 0;
//
//	if (port)
//		*port++ = 0;
//
//	if (host) {
//		*host++ = 0;
//		int intport = port ? strtol(port, nullptr, 10) : 0;
//		return svfs->CreateContainer<RemoteContainer>(MountPoint, intport, host);
//	}
	return CreateContainerResult(VFSErrorCode::InternalError, nullptr);
}

} //namespace Containers 
} //namespace StarVFS 
