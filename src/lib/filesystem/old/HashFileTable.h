/*
  * Generated by cppsrc.sh
  * On 2015-12-14  7:26:50,12
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef HashFileTable_H
#define HashFileTable_H

namespace StarVFS {

class HashFileTable {
public:
 	HashFileTable();
 	~HashFileTable();
	
	FileID Lookup(FilePathHash Hash);

	FileID Lookup(ConstCString Path, size_t PathLen) { return Lookup(FilePathHashAlgorithm::Hash(Path, PathLen)); }
	FileID Lookup(const String &Path) { return Lookup((const CString)Path.c_str(), Path.length()); }
	FileID Lookup(ConstCString Path) { return Lookup(Path, strlen(Path)); }

	void Add(File* f, bool Rebuild = true);

	//void SortHashTable();

	bool Resize(FileID NewCapacity);
	FileID GetAllocated() const { return m_Allocated; }

	FileID GetFileIDAtIndex(FileID index) const {
		if (index >= m_Allocated)
			return 0;
		return m_FileIDTable[index];
	}
	FilePathHash GetPathHashAtIndex(FileID index) const {
		if (index >= m_Allocated)
			return 0;
		return m_HashTable[index];
	}
private:
	union Flags_t {
		uint8_t intval;
		struct {
			uint8_t Locked : 1;
			uint8_t Broken : 1;
		};
	};

	FilePathHash *m_HashTable;   //these tables must be synchronized
	FileID *m_FileIDTable;	   //these tables must be synchronized
	FileID m_Allocated;
	FileID m_MaxIndex;
	FileID m_Capacity;
	Flags_t m_Flags;
	std::unique_ptr<char[]> m_Memory;

	void HashSwap(size_t a, size_t b) {
		std::swap(m_HashTable[a], m_HashTable[b]);
		std::swap(m_FileIDTable[a], m_FileIDTable[b]);
	}

	void HeapPush(FileID fid, FilePathHash Hash);
	void RebuildHeap(FileID begin);
};

} //namespace StarVFS 

#endif

/*

	extract hashfiletable
	add container mountpoints
	add filetable interface for containers

*/
