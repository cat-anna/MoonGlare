/*
  * Generated by cppsrc.sh
  * On 2015-12-10 18:56:28,59
  * by Paweu
*/
/*--END OF HEADER BLOCK--*/

#pragma once
#ifndef StringTable_H
#define StringTable_H

namespace StarVFS {

template<class T, class INDEX>
class DynamicStringTable {
public:
	DynamicStringTable() {
		m_Allocated = 1;
		m_Capacity = 0;
		Realloc(1024);
	}
	~DynamicStringTable() { }

	using Index = INDEX;

	Index Alloc(const T* src) {
		if (!src)
			return Index(0);
		Index s = Len(src);
		if (!s)
			return Index(0);
		if (m_Allocated + s + 1>= m_Capacity) {
			Realloc(m_Capacity * 2);
		}
		Index i = m_Allocated;
		auto ptr = m_Memory.get() + m_Allocated;
		memcpy(ptr, src, sizeof(T) * s);
		ptr[s] = 0;
		m_Allocated += s + 1;

		return i;
	}

	const T* Get(Index index) const {
		if (index >= m_Allocated)
			return nullptr;
		return m_Memory.get() + index;
	}

	const T* GetMemory() const { return m_Memory.get(); }
	Index GetAllocatedCount() const { return m_Allocated; }

	static Index Len(const char *c) { return (Index)strlen(c); }
private: 
	std::unique_ptr<T[]> m_Memory;
	Index m_Capacity, m_Allocated;

	void Realloc(Index NewCapacity) {
		if (m_Capacity >= NewCapacity)
			return;
		auto p = m_Memory.release();
		auto mem = (T*)realloc(p, NewCapacity * sizeof(T));
		if(!mem) {
			return;
		}
		if (!m_Capacity)
			mem[0] = 0;
		m_Memory.reset(mem);
		m_Capacity = NewCapacity;
	}
};

} //namespace StarVFS 

#endif
