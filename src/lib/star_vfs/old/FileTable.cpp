/*
 * Generated by cppsrc.sh
 * On 2015-12-10 18:00:09,91
 * by Paweu
 */
/*--END OF HEADER BLOCK--*/
#include "FileTable.h"
#include "StarVFSInternal.h"

namespace StarVFS {

FileTable::FileTable(StarVFS *Owner) : m_Owner(Owner) {
    StarVFSAssert(Owner);

    m_Capacity = m_Allocated = 0;
    m_Interfaces.push_back(nullptr);

    m_StringTable = std::make_unique<StringTable>();
    Realloc(Settings::Initial::FileTableSize);
    m_Allocated = 1; // first entry is not valid

    auto *root = AllocNewFile();
    root->m_Flags.Valid = 1;
    root->m_Flags.Directory = 1;
    root->m_Hash = FilePathHashAlgorithm::Hash("/", 1);
    m_HashFileTable.Add(root);
}

FileTable::~FileTable() {
    m_Capacity = m_Allocated = 0;

    m_FileTable.reset();
    m_FileTypeHash.reset();

    m_StringTable.reset();
}

//-------------------------------------------------------------------------------------------------

File *FileTable::AllocNewFile() {
    if (!EnsureCapacity(1))
        return nullptr;

    auto id = m_Allocated++;

    auto *f = m_FileTable.get() + id;
    memset(f, 0, sizeof(*f)); // is this necessary?
    f->m_GlobalFileID = id;

    return f;
}

File *FileTable::AllocNewFile(const CString fullpath) {
    const CString path = strrchr(fullpath, '/');
    if (!path) {
        // TODO: log
        return nullptr;
    }

    size_t len = path - fullpath;

    File *parent = nullptr;
    if (len > 0) {
        auto pid = m_HashFileTable.Lookup(fullpath, len);
        if (pid)
            parent = m_FileTable.get() + pid;
    } else
        parent = GetRoot();

    if (!parent || !parent->m_Flags.ValidDirectory())
        return nullptr;

    return AllocNewFile(parent->m_GlobalFileID, FilePathHashAlgorithm::Hash(fullpath, strlen(fullpath)), path + 1);
}

File *FileTable::AllocNewFile(FileID ParentID, FilePathHash PathHash, const CString FName) {
    if (!ParentID)
        return nullptr;

    auto f = AllocNewFile();
    auto Parent = GetFile(ParentID);
    f->m_NameStringID = m_StringTable->Alloc(FName);
    f->m_ParentFileID = Parent->m_GlobalFileID;
    f->m_NextSibling = Parent->m_FirstChild;
    Parent->m_FirstChild = f->m_GlobalFileID;
    f->m_Hash = PathHash;

    m_FileTypeHash[f->m_GlobalFileID] = MakeFileTypeHash(FName);

    m_HashFileTable.Add(f);
    return f;
}

//-------------------------------------------------------------------------------------------------

File *FileTable::AllocFile(const CString InternalFullPath) {
    auto fid = m_HashFileTable.Lookup(InternalFullPath);
    if (fid) {
        STARVFSErrorLog("Alloc file returns existing one! %d (%s)", fid, InternalFullPath);
        return m_FileTable.get() + fid;
    }
    return AllocNewFile(InternalFullPath);
}

File *FileTable::AllocFile(FileID Parent, FilePathHash PathHash, const CString FileName) {
    if (!PathHash)
        return nullptr;
    auto fid = Lookup(PathHash);
    if (fid) {
        STARVFSErrorLog("Alloc file returns existing one! %d", fid);
        return m_FileTable.get() + fid;
    }
    auto p = GetFile(Parent);
    if (!p || !p->m_Flags.ValidDirectory())
        return nullptr;

    return AllocNewFile(Parent, PathHash, FileName);
}

//-------------------------------------------------------------------------------------------------

String FileTable::GetFilePath(FileID fid, FileID ParentFID) const {
    std::stringstream ss;
    auto f = GetFile(fid);
    if (!f)
        return String();
    struct T {
        static void Do(std::stringstream &ss, const File *f, const FileTable *This, FileID ParentFID) {
            if (!f || f->m_GlobalFileID <= 1 || ParentFID == f->m_GlobalFileID)
                return;
            Do(ss, This->GetFileParent(f), This, ParentFID);
            if (ParentFID != f->m_ParentFileID)
                ss << "/";
            ss << This->m_StringTable->Get(f->m_NameStringID);
        }
    };
    T::Do(ss, f, this, ParentFID);
    return ss.str();
}

CString FileTable::GetFileName(FileID fid) const {
    if (!fid || fid >= m_Allocated)
        return nullptr;
    return (CString)m_StringTable->Get(m_FileTable[fid].m_NameStringID);
}

bool FileTable::GetFileData(FileID fid, ByteTable &data) {
    auto f = GetFile(fid);
    if (!fid)
        // TODO: log
        return false;
    auto c = m_Owner->GetContainer(f->m_ContainerID);
    if (!c) {
        STARVFSErrorLog("Invalid cid for file %d", fid);
        return false;
    }
    return c->GetFileData(f->m_ContainerFileID, data);
}

bool FileTable::SetFileData(FileID fid, const ByteTable &data) {
    auto f = GetFile(fid);
    if (!fid)
        // TODO: log
        return false;
    auto c = m_Owner->GetContainer(f->m_ContainerID);
    if (!c) {
        STARVFSErrorLog("Invalid cid for file %d", fid);
        return false;
    }
    return c->SetFileData(f->m_ContainerFileID, data);
}

FileFlags FileTable::GetFileFlags(FileID fid) const {
    auto f = GetFile(fid);
    if (!fid) {
        FileFlags flags;
        flags.intval = 0;
        return flags;
    }
    return f->m_Flags;
}

bool FileTable::DeleteFile(FileID fid) {
    auto f = GetFile(fid);
    if (!f)
        return false;

    f->m_Flags.Valid = false;
    f->m_Flags.Deleted = true;

    return true;
}

bool FileTable::DeleteFile(FileID fid, ContainerID cid) {
    auto f = GetFile(fid);
    if (!f)
        return false;
    if (f->m_ContainerID != cid)
        return false;

    f->m_Flags.Valid = false;
    f->m_Flags.Deleted = true;

    return true;
}

//-------------------------------------------------------------------------------------------------

bool FileTable::EnsureCapacity(FileID RequiredEmptySpace) {
    if (m_Allocated + RequiredEmptySpace < m_Capacity)
        return true;
    return Realloc(m_Allocated + RequiredEmptySpace);
}

bool FileTable::Realloc(FileID NewCapacity) {
    if (NewCapacity <= m_Capacity)
        return true;

    auto NewMemory = std::unique_ptr<File[]>(new File[NewCapacity]);
    auto NewHashMemory = std::unique_ptr<FileTypeHash[]>(new FileTypeHash[NewCapacity]);
    if (!NewMemory || !NewHashMemory)
        return false;

    memset(NewMemory.get(), 0, sizeof(File) * NewCapacity);
    memset(NewHashMemory.get(), 0, sizeof(FileTypeHash) * NewCapacity);

    if (m_Allocated > 0) {
        memcpy(NewMemory.get(), m_FileTable.get(), sizeof(File) * m_Allocated);
        memcpy(NewHashMemory.get(), m_FileTypeHash.get(), sizeof(FileTypeHash) * m_Allocated);
    }

    STARVFSDebugLog("Reallocated FileTable to %d entries", NewCapacity);
    m_FileTable.swap(NewMemory);
    m_FileTypeHash.swap(NewHashMemory);
    m_Capacity = NewCapacity;

    return m_HashFileTable.Resize(NewCapacity);
}

//-------------------------------------------------------------------------------------------------

Containers::FileTableInterface *FileTable::AllocateInterface(const String &MountPoint) {
    ContainerID cid = static_cast<ContainerID>(m_Interfaces.size());
    m_Interfaces.emplace_back(std::make_unique<Containers::FileTableInterface>(this, cid));
    return m_Interfaces.back().get();
}

//-------------------------------------------------------------------------------------------------

bool FileTable::RegisterStructureTable(FileStructureInfo &info) {
    if (!info.IsValid()) {
        STARVFSDebugLog("invalid info!");
        return false;
    }

    if (!EnsureCapacity(info.m_Count))
        return false;

    for (FileID i = 0; i < info.m_Count; ++i) {
        auto &basefile = info.m_FileTable[i];

        if (!basefile.m_Flags.Valid)
            continue;

        FilePathHash hash = info.m_PathHashTable[i];

        basefile.m_GlobalIndex = 0;

        File *fparent = nullptr;
        if (basefile.m_ParentIndex) {
            if (basefile.m_ParentIndex < info.m_Count && basefile.m_ParentIndex < i) {
                fparent = GetFile(info.m_FileTable[basefile.m_ParentIndex].m_GlobalIndex);
            }
        } else {
            fparent = info.m_Parent;
        }

        auto *f = AllocFile(fparent->m_GlobalFileID, hash, basefile.m_NamePointer);
        if (!f) {
            STARVFSErrorLog("Failed to allocate file!");
            return false;
        }

        bool changeownership = true;
        if (f->m_Flags.Valid) {
            if (f->m_Flags.Directory) {
                changeownership = false;
            } else {
            }
            if (basefile.m_Flags.Directory != f->m_Flags.Directory) {
                // todo: sth?
            }
        } else {
            f->m_Flags.Valid = 1;
            if (basefile.m_Flags.Directory) {
                f->m_Flags.Directory = 1;
            }
        }

        basefile.m_GlobalIndex = f->m_GlobalFileID;
        if (changeownership) {
            f->m_ContainerID = info.m_OwnerContainer;
            f->m_ContainerFileID = i;
            f->m_Size = basefile.m_Size;
        }
    }

    return true;
}

//-------------------------------------------------------------------------------------------------

void FileTable::FindFilesByTypeHash(FileTypeHash fth, DynamicFIDTable &table) {
    table.clear();
    for (FileID fid = 0; fid < m_Allocated; ++fid)
        if (m_FileTypeHash[fid] == fth)
            table.push_back(fid);
}

void FileTable::InvalidateCID(ContainerID cid) { STARVFSErrorLog("Not implemented: %s", __FUNCTION__); }

} // namespace StarVFS
