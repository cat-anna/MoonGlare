local description = [=[
Usage: lua bin2c.lua -c -o [optput file] -n [name of array] -x [? or value] [input filename]

switches:
    c - compile script, applicable only to lua files
    o - select output file, defaults to [input filename] + '.h'
    n - name of created array, defaults to [input filename] without path
    x - xor file data, use ? to generate random mask

]=]

function GetFileName(url)
    return url:match("^.+[/\\](.+)$")
end

function GetFileExtension(url)
return url:match("^.+(%..+)$")
end

function ParseArgs(args)

    local cfg = { }
    local switches = {
        ["-o"] = { 
            c = 1,
            h = function(v)
                cfg.output = v
            end,
        },
        ["-n"] = { 
            c = 1,
            h = function(v)
                cfg.name = v
            end,   
        }, 
        ["-c"] = { 
            c = 0,
            h = function(v)
                cfg.compile = true
            end,     
        },      
        ["-x"] = { 
            c = 0,
            h = function(v)
                if v == "?" then
                    math.randomseed( os.time() )
                    cfg.xor = math.random(255)   
                else
                    cfg.xor = tonumber(v)
                end
            end,     
        }            
    }
    
    local opcode
    for _,v in ipairs(arg) do
        if opcode == nil then
            local sw = switches[v]
            if sw then
                assert(opcode == nil)
                if sw.c > 0 then 
                    opcode = v
                end
            else
                assert(cfg.filename == nil)
                cfg.filename = v
            end
        else
            local h = switches[opcode]
            assert(h)
            h.h(v)        
            opcode = nil
        end
    end
    assert(cfg.filename)

    if not cfg.output then
        cfg.output = cfg.filename .. ".h"
    end

    if not cfg.name then
        cfg.name = GetFileName(cfg.filename):gsub(".", "_")
    end

    cfg.islua = GetFileExtension(cfg.filename) == ".lua"

    return cfg
end

function BitXOR(a,b)--Bitwise xor
    local p,c=1,0
    while a>0 and b>0 do
        local ra,rb=a%2,b%2
        if ra~=rb then c=c+p end
        a,b,p=(a-ra)/2,(b-rb)/2,p*2
    end
    if a<b then a=b end
    while a>0 do
        local ra=a%2
        if ra>0 then c=c+p end
        a,p=(a-ra)/2,p*2
    end
    return c
end

function write(cfg, data)
    local header = [=[
//code automatically generated by bin2c -- DO NOT EDIT

]=]
    local footer = [=[
    
]=]
    local out = assert(io.open(cfg.output, "wb"))
    out:write(header);
    
    if cfg.xor then
        out:write(string.format("static constexpr uint8_t %s_xor = 0x%02x;\n", cfg.name, cfg.xor))
    end
    out:write(string.format("static constexpr uint32_t %s_size = %d;\n", cfg.name, data:len()))
    out:write(string.format("static constexpr unsigned char %s[%d] = {\n    ", cfg.name, data:len()))
    
    for idx=1,data:len() do
        local byte = data:byte(idx)
        if cfg.xor then
            byte = BitXOR(byte, cfg.xor)
        end
        out:write(string.format("0x%02x, ", byte))
        if (idx % 16) == 0 then
            out:write("\n    ")
        end
    end
    
    out:write("\n};\n")
    out:write(footer);
    out:close()
end

function LoadFile(cfg) 
    return assert(io.open(cfg.filename,"rb")):read"*a"
end

function LoadLua(cfg) 
    local bin = assert(loadfile(cfg.filename))
    if cfg.compile then
        return string.dump(bin)
    else
        return LoadFile(cfg)
    end
end

local succ, cfg = pcall(ParseArgs,arg)
if not succ then
    print(description)
    print(cfg)
    os.exit(1)
end

local content
if cfg.islua then
    content = LoadLua(cfg)
else
    content = LoadFile(cfg)
end

write(cfg, content)
